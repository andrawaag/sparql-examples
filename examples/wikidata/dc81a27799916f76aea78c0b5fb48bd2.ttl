@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix schema: <https://schema.org/> .

<https://www.wikidata.org/#query-dc81a27799916f76aea78c0b5fb48bd2> a sh:SPARQLExecutable;
  rdfs:comment """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start [edit] While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics [edit] A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds.A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query [edit] Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion [edit] That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it.For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.)And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns [edit] So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above.Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query.Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions!Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this.Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario…Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren?Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s).In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.)And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes [edit] Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on.Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do.This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”.To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31).So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching.One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.)Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths [edit] In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax.An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# means:
?item wdt:P31 ?class
# or
?item wdt:P31/wdt:P279 ?class
# or
?item wdt:P31/wdt:P279/wdt:P279 ?class
# or
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# or ... In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b.A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself.A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”.You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.)You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.) Qualifiers [edit] (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?)So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple.The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now).That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface?Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT [edit] We return to our regular scheduled program of more SPARQL features.So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank).This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT.ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.)LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result.(You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.)Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses.Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise [edit] We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books [edit] Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Chemical elements [edit] Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi [edit] Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II [edit] Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL [edit] In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577).A first attempt might look like this: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier!The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results.The solution is to tell WDQS that those triples are optional: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set.Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND [edit] This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types [edit] Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators [edit] The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER [edit] Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example.FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used.For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  # This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet.Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”.One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P6357 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P6357 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF [edit] These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples.A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones).BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause.IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\".BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.)IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense.You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE [edit] The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping [edit] So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator).But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations [edit] Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.)Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.)This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials [edit] Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable.One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer [edit] What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages [edit] What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING [edit] A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata.How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary [edit] Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations [edit] A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instanzen a Klassen 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercice 7.1.1 Arthur Conan Doyle books 7.1.2 Cheemesch Elementer 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natierlech Sprooch Beispill SPARQL Beispill Saz Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. Komma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ].  Instanzen a Klassen Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Hei ass meng Léisung: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Hei ass meng Léisung: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values.  Exercice We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Beispillléisung SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Cheemesch Elementer Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Beispillléisung SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Beispillléisung SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Beispillléisung SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, שירות התשאול של ויקינתונים, הוא כלי רב עוצמה להפקת תובנות לפי התוכן של ויקינתונים. המדריך הזה ילמד אותך איך להשתמש בו. ר׳ גם את המדריך האינטראקטיבי של ויקימדיה ישראל.לפני שנכתוב שאילתת SPARQL משלך, כדאי להסתכל על {{Item documentation}} או על כל תבנית שאילתת SPARQL כללית אחרת ולראות אם השאילתה הנחוצה לך כבר שם. Contents 1 לפני שנתחיל 2 יסודות SPARQL 3 השאילתה הראשונה שלנו 4 השלמה אוטומטית 5 תבניות שלישיות מתקדמות 6 מופעים ומחלקות 6.1 נתיבי מאפיינים 7 מבחינים 8 ORDER ו־LIMIT (סידור והגבלה) 8.1 תרגול 8.1.1 ספרים של ארתור קונאן דויל 8.1.2 יסודות כימיים 8.1.3 נחלים שזורמים לתוך נהר המיסיסיפי 8.1.4 נחלים שזורמים לתוך נהר המיסיסיפי 2 9 OPTIONAL (רשות) 10 ביטויים, FILTER ו־BIND (סינון ואיגוד) 10.1 טיפוסי נתונים 10.2 פעולות 10.3 FILTER (סינון) 10.4 BIND,‏ BOUND,‏ IF (איגוד, תיחום, ברירה) 10.5 COALESCE (החזרת הערך התקין מבין האפשרויות) 11 קיבוץ 11.1 אוכלוסיות עירוניות 11.2 חומרי ציור 11.3 אקדחים לפי יצרן 11.4 מוציאים לאור לפי מספר דפים 11.4.1 HAVING (שיש לו) 11.5 סיכום על פונקציות כינוס 11.6 wikibase:Label וכינוסים 12 VALUES (ערכים) 13 Label in multiple languages 14 ועוד הרבה מעבר… 15 ר׳ גם לפני שנתחיל למרות שהמדריך הזה נראה ארוך ומאיים, אין סיבה לחשוש! למידת היסודות של SPARQL תיקח אותך הרחק - אפילו אם בחרת להפסיק לקרוא אחרי #השאילת הראשונה שלנו, כבר תתגבש אצלך הבנה מספקת להרכבת מגוון רחב של שאילתות מעניינות. כל סעיף במדריך הזה יעשיר אותך בכתיבת שאילתות יותר ויותר מדויקות.אם מעולם לא שמעת על ויקינתונים, SPARQL או WQDS לפני כן, הנה הסבר קצר של המונחים האלה: ויקינתונים הוא מסד נתוני ידע. הוא מכיל מיליוני קביעות, כגון „עיר הבירה של קנדה היא אוטווה”, או „ציור המונה ליזה צויר בשמן על עץ צפצפה”, או „נקודת ההתכה של זהב היא 1,064.18 מעלות צלזיוס”. SPARQL היא שפה לביטוי נוסחאי של שאלות (שאילתות) במסדי נתוני ידע. עם מסד הנתונים הנכון, שאילתת SPARQL יכולה לענות על שאלות כמו „מה הטונליות הנפוצה ביותר במוזיקה?” או „איזו דמות שיחקו הכי הרבה שחקנים?” או „מה היא התפלגות סוגי הדם?” או „איזו יצירה של אומנים הונגשה לנחלת הכלל השנה?”. WDQS, שירות התשאול של ויקינתונים, מחבר בין השניים: כותבים שאילתת SPARQL, היא רצה כנגד סדרת הנתונים של ויקינתונים ומציגה לך את התוצאות.  יסודות SPARQL שאלת SPARQL פשוטה נראית ככה: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} הפסוקית SELECT כוללת את המשתנים שנרצה להחזיר (משתנים מתחילים בסימן שאלה), והפסוקית WHERE מכילה מגבלות עליהם, בעיקר בצורת שלישיות. כל המידע בוויקינתונים (ומסדי נתוני ידע דומים) מאוחסן בצורת שלישיות, כשמריצים את השאילתה, שירות התשאול ינסה למלא את המשתנים בערכים בפועל כדי שהשלישיות המתקבלות תופענה במסד נתוני הידע ותוחזרנה תוצאה אחת לכל צירוף משתנים שנמצאו. שלישייה יכולה להיות כמו משפט (לכן היא מסתיימת בנקודה) עם נושא (subject), נשוא (predicate) ועצם (object): SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} התוצאות לשאילתה הזאת יכולות לכלול, למשל, „לימון”. בוויקינתונים, רוב המאפיינים הם מסוג „יש” (has), לכן השאילתה יכולה להיראות כך: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} שיפורש בצורה ‎„?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’”)‎ ובעברית: ל?פרי יש את הצבע ‚צהוב’” (לא “?פרי הוא הצבע של ‚צהוב’”) - חשוב לזכור את זה לטובת צמדי מאפיינים מהצורה „הורה”/„צאצא”!.עם זאת, זאת לא דוגמה טובה ל־WQDS. טעם הוא סובייקטיבי, לכן לוויקינתונים אין מאפיין לזה. במקום, אפשר לחשוב על יחסי הורה/צאצא, שהם בדרך כלל חד־משמעיים. השאילתה הראשונה שלנו נניח שנרצה להציג את כל הצאצאים של המלחין מתקופת הבארוק יוהאן סבסטיאן באך. באמצעות רכיבים מדומים כמו בשאילתות להלן, איך כדאי לכתוב את השאילתה הזאת?אמור היה לצאת משהו כזה: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach (‏(ל)צאצא ''יש הורה'' באך)
  ?child parent Bach.
  # ‫(נא לשים לב: כל מה שנכתב אחרי ‚#’ נחשב הערה ו־WQDS יתעלם ממנו.)
} או ככה, SELECT ?child
WHERE
{
  # child \"has parent\" Bach (‏(ל)צאצא ''יש אבא'' באך) 
  ?child father Bach. 
} או ככה, SELECT ?child
WHERE
{
  #  Bach \"has child\" child (‏(ל)באך ''יש צאצא'' צאצא)
  Bach child ?child.
} שתי השלישיות הראשונות טוענות של־‎?child חייב להיות הורה/אבא בשם Bach, השלישית טוענת של־Bach יש את הצאצא ‎?child. בואו נמשיך עם האפשרות השנייה כרגע.אם כן, מה צריך לעשות כדי להפוך את זה לשאילתה תקפה של WQDS? בוויקינתונים פריטים ומאפיינים לא מזוהים בשם שמובן לבני אדם כמו „אבא” (מאפיין) או „באך” (פריט). (יש לכך סיבה טובה: „יוהאן סבסטיאן באך” הוא גם השם של צייר גרמני, ו„באך” יכול גם להיות שם משפחה, קהילה צרפתית, מכתש בכוכב חמה וכן הלאה). במקום, לפריטים ולמאפיינים בוויקינתונים מוקצים מזהים. כדי למצוא מזהה של פריט עלינו לחפש את הפריט ולהעתיק את מספר ה־Q של התוצאה שנשמעת כמו הפריט שאנחנו מחפשים (לפי התיאור למשל). כדי למצוא מזהה של מאפיין, נעשה את אותו הדבר, אך נחפש אחר „‪P:<ביטוי לחיפוש>‬” במקום רק „ביטוי לחיפוש”, מה שיגביל את החיפוש למאפיינים. כך נוכל למצוא שהמלחין המפורסם יוהאן סבסטיאן באך מיוצג על ידי Q1339, ושהמאפיין להקצאת הורה לפריט הוא P:P22.ואחרון חביב, צריך לכלול קידומות. לשלישיות פשוטות של WQDS, יש להוסיף קידומת wd:‎ לפריטים, ולמאפיינים את wdt:‎. (אך זה חל רק על ערכים קבועים - משתנים לא מקבלים קידומת!)אם נחבר הכול יחד, נגיע לשאילתת ה־WDQS הראויה הראשונה שלנו: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! נלחץ על הקישור „לנסות את זה”, לאחר מכן על „ביצוע שאילתה” בעמוד ה־WDQS. מה יוצא? child wd:Q57225 wd:Q76428 … קצת מאכזב. רואים רק את המזהים. אפשר ללחוץ עליהם כדי לראות את העמוד שלהם בוויקינתונים (כולל תווית שבני אדם יכולים להבין), אבל אין דרך טובה יותר לראות את התוצאות?נו, כמובן שיש! (שאלות רטוריות זה דבר נפלא, לא?) אם כוללים את מלל הקסם SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } איפשהו בתוך פסוקית ה־WHERE יש משתנים נוספים: לכל משתנה ‎?foo בשאילתה שלך יש עכשיו גם משתנה ‎?fooLabel, which שמכיל את תווית הפריט שמאחורי ‎?foo. אם נוסיף אותו לפסוקית ה־SELECT יופיע הפריט וגם התווית שלו: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כדאי לנסות להריץ את השאילתה הזאת - אמורים להופיע לא רק מספרי הפריטים אלא גם שמות הצאצאים השונים. child childLabel wd:Q57225 יוהאן כריסטוף פרידריך באך wd:Q76428 קארל פיליפ עמנואל באך …  השלמה אוטומטית לא נראה שקל כל כך לזכור את מקטע הקוד הזה עם SERVICE, נכון? ולהשתמש בחיפוש כל פעם בזמן כתיבת השאילתה זה גם די מייגע. למרבה המזל, WDQS מציע לכך פתרון נהדר: autocompletion (השלמה אוטומטית). בעורך השאילתות query.wikidata.org אפשר ללחוץ על Ctrl+רווח (or Alt+אנטר או Ctrl+Alt+אנטר) בכל נקודה בשאילתה ולקבל הצעות לקוד שיכול להתאים, את ההצעה המתאימה ניתן לבחור עם מקשי החצים למעלה/למטה ואז על אנטר כדי לבחור אותה.למשל, במקום לכתוב SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } כל פעם מחדש, אפשר פשוט להקליד SERV, ללחוץ על Ctrl+רווח, והתוצאה הראשונה תהיה כישוף שירות התווית המלא, מוכן לשימוש! עכשיו צריך רק ללחוץ על אנטר כדי לאשר אותו. (העיצוב יהיה מעט שונה אבל זה לא משנה.)השלמה אוטומטית יכולה גם לחפש עבורך. אם הקלדת את אחת מהקידומות של ויקינתונים כגון wd:‎ או wdt:‎, ואז את הטקסט לאחר מכן, Ctrl+רווח תחפש את הטקסט הזה בוויקינתונים ותציע תוצאות. wd:‎ מחפשת אחר פריטים, wdt:‎ אחר מאפיינים. למשל, במקום לחפש את הפריטים עבור Johann Sebastian Bach (Q1339) וfather (P22), אפשר פשוט להקליד wd:Bach ו־wdt:fath ואז פשוט לבחור את הרשומה המתאימה מההשלמה האוטומטית. (עובד אפילו עם רווחים בטקסט, למשל: wd:Johann Sebastian Bach.) תבניות שלישיות מתקדמות אז עכשיו פגשנו את כל הצאצאים של יוהאן סבסטיאן באך - יותר נכון: את כל הפריטים שהאבא שלהם הוא יוהאן סבסטיאן באך. אך לבאך היו שתי נשים, לכן לפריטים האלה יש שתי אימהות שונות: מה אם אנחנו רוצים לראות רק את הצאצאים של יוהאן סבסטיאן באך עם אשתו הראשונה, מריה ברברה באך (Q57487)? כדאי לנסות לכתוב את זה בשאילתה, לפי המידע שיש לנו.סיימנו? מצוין, נעבור לפתרון! הדרך הפשוטה ביותר לעשות זאת היא להוסיף שלישייה שניה עם המגבלה הזאת: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! בעברית המשמעות היא: לילד יש אבא יוהאן סבסטיאן באך. לילד יש אימא מריה ברברה באך. נשמע מוזר, לא? בשפה טבעית נוכל לקצר את זה לביטוי: לילד יש אבא יוהאן סבסטיאן באך ואימא מריה ברברה באך. למעשה, אפשר לבטא את אותו הקיצור גם ב־SPARQL: אם סוגרים את השלישייה בנקודה פסיק (;) במקום בנקודה, אפשר להוסיף עוד צמד נשוא-עצם. כך נוכל לקצר את השאילתה שלעיל לכדי: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! שמציגה את אותן תוצאות אך עם פחות חזרות בשאילתה.עכשיו נניח, שמתוך התוצאות האלו, מעניינים אותנו רק הצאצאים שהיו גם מלחינים ופסנתרנים. המאפיינים והפריטים הרלוונטיים הם occupation (P106), composer (Q36834) וpianist (Q486748). עכשיו ננסה לשנות את השאילתה שלהלן כדי להוסיף לה את המגבלות האלה!הינה הפתרון שלי: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כאן נעשה שימוש בקיצור ; פעמיים נוספות כדי להוסיף את שני העיסוקים הנחוצים. אך כפי שניתן לשים לב, עדיין יש חזרתיות. זה כמו שנגיד: לילד יש עיסוק מלחין ועיסוק פסנתרן. מה שבדרך כלל נוכל לקצר לביטוי: לילד יש עיסוק מלחין ופסנתרן. ול־SPARQL יש תחביר גם לזה: ממש כמו ש־; מאפשר להוסיף צמד נשוא-עצם לשלישייה (תוך שימוש בנושא לשתי מטרות), , מאפשר לך להוסיף עצם נוסף לסוף שלישייה (תוך ניצול של הנושא והנשוא לשתי מטרות). כך, אפשר לקצר את השאילתה לכדי: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כדאי לשים לב: אין משמעות להזחות ולרווחים נוספים - הם רק מקלים על הקריאה. אפשר גם לכתוב את זה ככה: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # שני העיסוקים באותה שורה
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! או, בצורה הפחות נוחה לקריאה: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # אין הזחה, מקשה על הבדלה בין ; לבין ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! למרבה המזל, העורך של WDQS מזיח את השורות עבורך אוטומטית, כך שזה בדרך כלל לא אמור להטריד אותך.מצוין, נערוך סיכום ביניים. ראינו ששאילתות בנויות כמו טקסט. כל שלישייה על נושא נסגרת בנקודה. מספר נשואים על אותו הנושא מופרדים בנקודה פסיק, ומגוון עצמים לאותו הנושא והנשוא ניתן לכתוב עם פסיקים ביניהם. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} עכשיו נציג קיצור נוסף ש־SPARQL מציע. כל עוד נוכל לזרום בצחוק על עוד תרחיש מומצא…נניח שאנחנו לא באמת מעוניינים בילדים של באך. (טוב, אולי אותך זה כן מעניין!) אבל אנחנו מעוניינים בנכדים שלו. (לכאורה.) יש כאן סיבוך מסוים: נכד יכול להיות קשור לבאך דרך האימא או דרך האבא. אלו שני מאפיינים שונים, שזה מצב לא נוח. במקום, נהפוך את הזיקה: לנתונים יש גם מאפיין „צאצא”, P:P40, שמפנה מההורה לצאצא ללא תלות במגדר. עם המידע הזה, אפשר לכתוב שאילתה שמחזירה את הנכדים של באך?הינה הפתרון שלי: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! בשפה טבעית, המשמעות היא: לבאך יש ילד ‎?child. ל־‎?child יש ילד ?grandChild. גם כאן, אני מציע לקצר את המשפט הזה ואז ארצה להראות איך SPARQL תומך בקיצור דומה. בדרך הזאת לא ממש אכפת לנו מהצאצא: אנחנו לא משתמשים במשתנה למעט כדי לדבר על הנכד. לכן עלינו לקצר את המשפט הזה לכדי: לבאך יש איזשהו ילד שיש לו ילד ‎?grandChild. במקום להגיד איזה ילד זה של באך, אנחנו פשוט מציינים „מישהו”: לא אכפת לנו מי הוא. אבל אפשר להתייחס אליהם בחזרה כיוון שאמרנו „איזשהו/מישהו ש”: בכך פתחנו בפסוקית זיקה, ובתוך פסוקית הזיקה הזאת נוכל לציין דברים על „איזשהו/מישהו” (למשל: ש„יש להם ילד ‎?grandChild”). למעשה, „איזשהו/מישהו” הוא משתנה, אך מיוחד שתקף רק בתוך פסוקית הזיקה הזאת וכזה שאנחנו לא פונים אליו במפורש (אנחנו מציינים ש„למישהו שהוא זה ועושה את זה”, לא „מישהו שהוא זה ומישהו שעושה את זה” - זה לא אותו „מישהו”).ב־SPARQL אפשר לכתוב את זה בתור: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! אפשר להשתמש בצמד סוגריים מרובעים ([]) במקום משתנה, שמתנהג כמו משתנה אלמוני. בתוך הסוגריים, אפשר לציין צמדים של נשוא-עצם, בדיוק כמו אחרי ; שאחרי שלישייה רגילה, הנושא המרומז הוא במקרה הזה המשתנה האלמוני שהסוגריים האלה מייצגים. (לתשומת ליבך: כמו מיד אחרי code>;, אפשר להוסיף עוד צמדי נשוא-עצם עם יותר נקודות פסיקים או יותר עצמים לאותו הנשוא עם פסיקים.)זה הכול על תבניות שלישיות! יש עוד מה לגלות על SPARQL, אך כיוון שאנחנו מתכננים לעזוב את החלקים ממנו שהם אנלוגיים לטובת שפה טבעית, ארצה לסכם את היחס הזה פעם נוספת: שפה טבעית דוגמה SPARQL דוגמה משפט יוליה אוהבת את רומיאו. תקופה יוליה אוהבת את רומיאו. חיבור (פסוקית) רומיאו אוהב את יוליה וגם הורג את עצמו. נקודה פסיק רומיאו אוהב את יוליה; הורג את רומיאו. חיבור (שם עצם) רומיאו הורג את טיבלט וגם את עצמו. פסיק רומיאו הורג את טיבלט, רומיאו. פסוקית זיקה יוליה אוהבת מישהו אשר הורג את טיבלט. סוגריים מרובעים יוליה אוהבת את [ הורג את טיבלט ].  מופעים ומחלקות לפני כן, ציינתי שרוב המאפיינים של ויקינתונים הם זיקה מסוג „יש” (has): יש צאצא, יש אבא, יש עיסוק. אבל לפעמים (למעשה, לעיתים קרובות), צריך גם לדבר על אופיו של משהו (is). אך זה מתחלק למעשה לשני סוגים של קשרים: חלף עם הרוח הוא סרט. סרט הוא יצירת אומנות. חלף עם הרוח הוא סרט מסוים אחד. יש לו במאי מסוים (ויקטור פלמינג), אורך מסוים (238 דקות), רשימת שחקנים (קלארק גייבל, ויויאן לי…), ועוד.סרט הוא עקרון כללי. לסרטים יכולים להיות במאים, אורכים ושחקנים, אבל לעקרון „סרט” כפי שהוא אין במאי, משך או ליהוק מסוים. ולמרות שסרט הוא יצירת אומנות, וליצירת אומנות בדרך כלל יש יוצר, לעקרון „סרט” לכשעצמו אין יוצר – רק למופעים מסוימים של העקרון הזה יש.ההבדל הזה הוא הסיבה לכך שיש שני מאפיינים עבור „is” (תת־קבוצה של/מופע של) בוויקינתונים: instance of (P31) וsubclass of (P279). חלף עם הרוח הוא מופע מסוים של המחלקה „סרט”, המחלקה „סרט” היא תת־מחלקה (ליתר דיוק מחלקה, התמחות) של מחלקה כללית יותר בשם „יצירת אומנות”.כדי לסייע להבין את ההבדלים, אפשר לנסות להשתמש בשני פעלים שונים: „תת־קבוצה” ו„מופע של”. אם „תת־קבוצה” מתאים (למשל: סרט הוא „תת־קבוצה של” יצירת אומנות), זה אומר שמדובר בתת־מחלקה. מומחיות של מחלקה רחבה יותר ויש להשתמש בsubclass of (P279). אם „תת־מחלקה של” לא מתאים (למשל: המשפט חלף עם הרוח הוא „מופע של” סרט אין בו היגיון), זה אומר שמדובר במופע מסוים ושצריך להשתמש בinstance of (P31).אז מה זה אומר לגבינו בעת כתיבת שאילתות SPARQL? כשאנו רוצים לחפש אחר „כל יצירות האומנות”, לא מספיק לחפש את כל הפריטים שהם מופעים ישירים של „יצירת אומנות”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # מופע של יצירת אומנות
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! בזמן תרגום המדריך (דצמבר 2023), השאילתה הזאת החזירה רק 31,308 תוצאות - כמובן שיש הרבה יותר יצירות אומנות מהכמות הזאת! הבעיה היא שהשאילתה מחמיצה פריטים כמו חלף עם הרוח, שזה מופע של „סרט” בלבד ולא של „יצירת אומנות”. „סרט” זאת תת־מחלקה של „יצירת אומנות” אבל אנחנו צריכים לדרוש מ־SPARQL לקחת את זה בחשבון בזמן החיפוש.פתרון אחד לכך הוא התחביר [] שדיברנו עליו: חלף עם הרוח הוא מופע של איזושהי תת־מחלקה של „יצירת אומנות”. (לצורך התרגול, כדאי לנסות לכתוב את השאילתה הזאת!) אך גם בגישה הזאת עדיין יש בעיות: אנחנו לא כוללים עוד פריטים שהם מופעים ישירים של יצירת אומנות. אנחנו עדיין מחמיצים פריטים שהם מופעים של תת־מחלקה כלשהי של איזה תת־מחלקה אחרת של „יצירת אומנות” - למשל, שלגיה ושבעת הגמדים הוא סרט מונפש, שהוא סרט, שהוא יצירת אומנות. במקרה הזה אנחנו צריכים לעקוב אחר שתי קביעות מסוג „תת־מחלקה של” - אבל זה יכול להיות גם שלושה, ארבעה, חמישה ולמעשה כל מספר. הפתרון: ‎?item wdt:P31/wdt:P279* ?class‎. המשמעות היא שיש „מופע של” אחד ואז מספר כלשהו של קביעות מסוג „תת־מחלקה של” בין הפריט ובין המחלקה. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # מופע של תת־מחלקה כלשהי של יצירת אומנות
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (לא מומלץ להריץ את השאילתה הזאת. WDQS יכול להתמודד איתה (ממש בקושי), אבל הדפדפן שלך עלול לקרוס בעת ניסיון להציג את התוצאות כי יש הרבה מהן.)עכשיו יותר ברור איך לחפש אחר כל יצירות האומנות או כל הבניינים או כל היישובים לבני אדם: כישוף הקסם wdt:P31/wdt:P279*‎, יחד עם המחלקה המתאימה. לשם כך נעשה שימוש בעוד כמה יכולות SPARQL שעדיין לא הסברתי עליהן, אבל למען ההגינות, זה בערך השימוש הרלוונטי היחידי של היכולות האלה כך שאין צורך אמיתי להבין איך זה עובד כדי להשתמש ב־WDQS ביעילות. אם חשוב לך לדעת, אסביר זאת בקצרה אבל אפשר פשוט לדלג לסעיף הבא ולשנן או להעתיק ולהדביק את wdt:P31/wdt:P279*‎ מכאן בעת הצורך. נתיבי מאפיינים נתיבי מאפיינים הן דרך לכתוב נתיב של מאפיינים בין שני פריטים בצורה תמציתית. הנתיב הפשוט ביותר הוא מאפיין יחיד, שמתגבש לכדי שלישייה פשוטה: ?item wdt:P31 ?class. אפשר להוסיף רכיבי נתיב עם לוכסן (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. שקול לאחד מהבאים: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. תרגיל: נא לשכתב את שאילתת „הנכדים של באך” מקודם לשימוש בתחביר הזה.כוכבית (*) אחרי רכיב נתיב משמעה „אפס או יותר מהרכיב הזה”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> אם אין רכיבים אחרים בנתיב, המשמעות של ‎?a something* ?b היא ש־‎?b יכול גם פשוט ‎?a ישירות בלי רכיבים ביניהם כלל. פלוס (+) דומה לכוכבית, אך המשמעות שלו היא „אחד או יותר מהרכיב הזה”. השאילתה הבאה מוצאת את כל יוצאי חלציו של באך: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! אם היינו משתמשים כאן בכוכבית במקום בפלוס, תוצאות השאילתה היו כוללות את באך בכבודו ובעצמו.סימן שאלה (?) דומה לכוכבית או פלוס אך המשמעות שלו היא „אפס או אחד מהרכיב הזה”.אפשר להפריד רכיבי נתיב בקו אנכי (|) במקום לוכסן, המשמעות היא „או או/או ש… או ש…” (either-or): הנתיב יכול להשתמש בכל אחד מהמאפיינים האלה. (אך לא במשולב - מקטע נתיב „או או” תמיד תואם לנתיב באורך אחד.)אפשר גם לקבץ רכיבים עם סוגריים (()), ולשלב בחופשיות את כל רכיבי התחביר האלה (/|*+?). המשמעות היא שדרש נוספת למצוא את כל יוצאי חלציו של באך היא: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! במקום להשתמש במאפיין „צאצא” כדי לעבור מבאך לדורות המאוחרים, אנו משתמש במאפיינים „אבא” ו„אימא” כדי לעבור מהדורות המאוחרים לבאך. הנתיב יכול לכלול שתי אימהות ואבא אחד או ארבע אבות או אבא-אימא-אימא-אבא או כל שילוב אחר. (למרות, שבאך כמובן לא יכול להיות אימא של מישהו, לכן הרכיב האחרון תמיד יהיה אבא.) מבחינים (נפתח בחדשות הטובות: הפרק הזה לא מציג תחביר נוסף ב־SPARQL - היאח! אפשר לקחת הפסקה קצרה ולהירגע, זה אמור להיות קלי קלות. לא?)עד כה דיברנו רק על קביעות פשוטות: נושא, מאפיין, עצם. אך הקביעות של ויקינתונים הן הרבה מעבר לזה: יכולים להיות להם גם מבחינים והפניות למקורות. למשל, למונה ליזה (Q12418) יש שלוש קביעות מסוג made from material (P186): oil paint (Q296955), החומר העיקרי, poplar wood (Q291034), עם המבחין applies to part (P518)painting support (Q861259) – זה החומר שעליו צוירה המונה ליזה, וגם wood (Q287), עם המבחינים applies to part (P518)stretcher (Q1737943) וstart time (P580) 1951 – זה החלק שנוסף לתמונה בשלב מאוחר יותר. נניח שאנחנו רוצים למצוא את כל הציבורים עם משטח הציור שלהם, כלומר, קביעות made from material (P186) עם המבחין applies to part (P518)painting support (Q861259) . איך עושים את זה? זה יותר מידע ממה שאפשר להציג בשלישייה אחת.התשובה היא: עוד שלישיות! (כלל אצבע: הפתרון של ויקינתונים כמעט לכל דבר הוא „עוד פריטים”, והכלל התואם ב־WDQS הוא „עוד שלישיות”. הפניות למקורות, דיוק עשרוני, ערכים עם יחידות, נקודות ציון גאוגרפיות וכו׳, על כל אלה שאנחנו מדלגים עליהם כאן, עובדים כך גם כן.) עד כה, השתמשנו בקידומת wdt:‎ לשלישיית הקביעות שלנו, שמפנה ישירות לעצם הקביעה. אך יש גם קידומת נוספת p:‎, שמצביעה לא לעצם אלא לצומת קביעה. הצומת הזה הוא הנושא של שלישיות אחרות: הקידומת ps:‎ (ראשי תיבות של property statement - צומת קביעה) למבחינים ו־prov:wasDerivedFrom מפנה לצמתי הפניה למקורות (אנחנו נתעלם מזה כרגע).זה היה המון טקסט מופשט. הנה דוגמה מוחשית למונה ליזה: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) נוכל לקצר את זה משמעותית עם התחביר [] שיחליף את משתני ‎?statement: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. ננסה להשתמש בידע הזה כדי לכתוב שאילתה לכל הציורים עם משטח הציור שלהם?הינה הפתרון שלי: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! קודם, נגביל את ‎?painting לכל המופעים של painting (Q3305213) או תת־מחלקה שלו. לאחר מכן, נחלץ את החומר מצומת הקביעה p:P186 שיגביל את הקביעות לאלו שיש להן את המבחין applies to part (P518)painting support (Q861259) . ORDER ו־LIMIT (סידור והגבלה) אנו חוזרים לתוכנית המקורית שלנו עם עוד יכולות של SPARQL.עד עכשיו, נתקלנו בשאילתות שבהן היינו מעוניינים בכל התוצאות. בקשה יחסית נפוצה היא שרק חלק מהתוצאות נחוצות: בדרך כלל לקיצון מסוים - הוותיקות ביותר, הצעירות ביותר, הקדומות ביותר, העדכניות ביותר, עם כמות האוכלוסיה הגדולה ביותר, נקודת ההתכה הנמוכה ביותר, הכי הרבה ילדים, הכי הרבה חומרים לייצור וכן הלאה. הגורם המשותף כאן הוא שהתוצאות מדורגות באופן כלשהו, ואז אכפת לנו מכמות מסוימת של כמה תוצאות ראשונות בלבד (אלו עם הדירוג הטוב ביותר).השליטה הזאת מתאפשרת באמצעות שתי פסוקיות שמצטרפות למקטע WHERE {}‎ (אחרי הסוגריים, לא בתוכם!): ORDER BY ו־LIMIT.‪ORDER BY משהו‬ מסדר את התוצאות לפי משהו. משהו יכול להיות כל ביטוי שהוא – לבינתיים, הביטוי היחידי שאנחנו מכירים הם משתנים פשוטים (‎?something‎), אך בהמשך נראה סוגים אחרים. אפשר לעטוף את הביטוי הזה ב־ASC()‎ או ב־DESC()‎ כדי לציין את כיוון הסידור (ascending או descending - עולה או יורד בהתאמה). (כשלא מציינים אף אחד מהם, ברירת המחדל היא סדר עולה, לכן ‪ASC(משהו)‬ שקול לחלוטין לביטוי משהו כפי שהוא.)‪LIMIT כמות‬ חותכת את רשימת התוצאות לכמות תוצאות, כאשר כמות הוא כל מספר טבעי שהוא. למשל, LIMIT 10 מגביל את השאילתה ל־10 תוצאות. LIMIT 1 מחזיר תוצאה אחת בלבד.(אפשר גם להשתמש ב־LIMIT בלי ORDER BY. במקרה שכזה, התוצאות לא תסודרנה כך שאין שום ערובה לתוצאות שתתקבלנה. שזה בסדר אם במקרה ברור לך שיש כמות מסוימת של תוצאות, או שפשוט מעניין אותך להציג תוצאות כלשהן אבל לא אכפת לך איזה בדיוק. בכל מקרה, הוספת LIMIT יכולה להאיץ את השאילתה משמעותית, מאחר ש־WDQS יכול לעצור את החיפוש ברגע שנמצאו מספיק תוצאות למלא את הכמות.)זמן לתרגל! נא לנסות לכתוב שאילתה שמחזירה את עשר המדינות המאוכלסות ביותר. (מדינה זה sovereign state (Q3624078), ומאפיין האוכלוסיה הוא P:P1082.) אפשר להתחיל על ידי חיפוש אחר מדינות עם האוכלוסיה שלהן, ואז להוסיף את הפסוקיות ORDER BY ו־LIMIT.הינה הפתרון שלי: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! נא לשים לב שאם רצינו את המדינות המאוכלסות ביותר, צריך לסדר לפי אוכלוסיה בסדר יורד, כך שהתוצאות הראשונות תהיינה אלו עם הערכים הגדולים ביותר. תרגול כיסינו הרבה יסודות עד כה - לדעתי הגיע הזמן לקצת תרגולים. (אפשר לדלג על החלק הזה אם אין לך פנאי.) ספרים של ארתור קונאן דויל נא לכתוב שאילתה שמחזירה את כל הספרים של סיר ארתור קונאן דויל. רמז הפריטים והמאפיינים הרלוונטיים הם: Arthur Conan Doyle (Q35610), author (P50). פתרון לדוגמה SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  יסודות כימיים נא לכתוב שאילתה שמחזירה את כל היסודות הכימיים עם הסימול והמספר האטומי שלהם בסדר עולה לפי המספר האטומי. רמז הפריטים והמאפיינים הרלוונטיים הם: chemical element (Q11344), element symbol (P246). פתרון לדוגמה SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  נחלים שזורמים לתוך נהר המיסיסיפי נא לכתוב שאילתה שמחזירה את כל הנחלים שזורמים ישירות לנהר המסיסיפי. (האתגר העיקרי פה הוא למצוא את המאפיין הנכון…) רמז הפריטים והמאפיינים הרלוונטיים הם: Mississippi River (Q1497), mouth of the watercourse (P403). פתרון לדוגמה SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  נחלים שזורמים לתוך נהר המיסיסיפי 2 נא לכתוב שאילתה שמחזירה את כל הנחלים שזורמים לתוך נהר המיסיסיפי, בישירות או בעקיפין. רמז השאילתה הזאת כמעט זהה לקודמת. ההבדל הוא שהפעם צריך נתיב במקום שלישייה. (אם דילגת על הסעיף על נתיבים, צריך לדלג גם על התרגיל הזה.) פתרון לדוגמה SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  OPTIONAL (רשות) בתרגיל שלעיל, התבקשנו לבנות שאילתה שתמצא את כל הספרים מאת סר ארתור קונאן דויל: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! אבל זה קצת משעמם. יש המון נתונים מעניינים על ספרים, ואנחנו מציגים רק את התווית? בואו ננסה להכין שאילתה שכוללת גם את title (P1476), illustrator (P110), publisher (P123) וגם publication date (P577).ניסיון ראשוני יכול להיראות כך: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! יש להריץ את השאילתה הזאת. בזמן תרגום המסמך הזה, מוחזרות רק 21 תוצאות - ממש טיפה בים! למה זה ככה? לפני כן מצאנו למעלה ממאה ספרים!הסיבה לכך היא שכדי לענות על השאילתה הזאת, על תוצאה אפשרית (ספר) לענות על כל השלישיות שהצבנו: זאת חייבת להיות כותרת, ומאייר, והוצאה לאור ותאריך פרסום. אם לספר יש כמה מהמאפיינים האלה אך לא את כולם הוא לא יענה לחיפוש. וזה לא מה שאנחנו רוצים במקרה הזה: אנחנו בעיקר רוצים רשימה של כל הספרים - אם יש מידע נוסף, נרצה לכלול אותו, אך לא נרצה שהוא יגביל את רשימת התוצאות שלנו.הפתרון הוא לומר ל־WDQS שהשלישיות האלה הן בגדר רשות (optional): SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כך מתקבלים משתנים נוספים (‎?title,‏ ‎?publisher וכו׳) אם הקביעה המתאימה קיימת, אך אם הקביעה לא קיימת, התוצאה לא נזרקת מהרשימה - המשתנה פשוט לא מוגדר.נא לשים לב: חשוב מאוד להשתמש כאן בפסוקיות OPTIONAL נפרדות. אם שמים את כל השלישיות בפסוקית אחת, כמו פה - SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! - מיד יתחוור לך שרוב התוצאות לא כוללות מידע נוסף כלשהו. זה כיוון שפסוקית רשות עם מגוון שלישיות מוצאת אותן רק כאשר כל השלישיות האלו מסופקות. כלומר: אם לספר יש כותרת, מאייר, הוצאת ספרים ותאריך פרסום, אז פסוקית הרשות תמצא אותן, והערך האלו מוקצים למשתנים המתאימים. אך אם לספר יש, למשל, כותרת אך לא מאייר, כל פסוקית הרשות לא תמצא פריטים ולמרות שהתוצאה לא תיזרק מהרשימה, כל ארבעת המשתנים יישארו ריקים. ביטויים, FILTER ו־BIND (סינון ואיגוד) הסעיף הזה עלול להיראות פחות מאורגן מהשאר, כיוון שהוא מכסה נושא יחסית רחב ומגוון. העיקרון הבסיסי הוא שנרצה לעשות משהו עם ערך שעד כה בחרנו והחזרנו ללא הבחנה. וביטויים הן דרך לבטא את הפעולות האלה על ערכים. יש סוגים רבים של ביטויים, ומגוון רחב של דברים שאפשר לעשות איתם - אך קודם כל, נתחיל ביסודות: טיפוסי נתונים. טיפוסי נתונים לכל ערך ב־SPARQL יש טיפוס, שאומר לו איזה סוג של ערך הוא ומה אפשר לעשות איתו. הטיפוסים החשובים ביותר הם: פריט, כמו wd:Q42 לציון Douglas Adams (Q42). בוליאני, עם שני הערכים האפשריים true ו־false. ערכים בוליאנים לא מאוחסנים בקביעות, אך ביטויים רבים מחזירים ערך בוליאני, למשל: 2 < 3 (true) או \"a\" = \"b\" (false). מחרוזת, קטע טקסט. ביטויי טקסט נכתבים בתוך מירכאות. טקסט חד־לשוני, מחרוזת שמצורף לה תג שם. בביטוי, אפשר להוסיף את תג השפה אחרי המחרוזת עם הסימן @, למשל: \"דאגלס אדמס\"@he. מספרים, שלמים (1) או עם נקודה עשרונית (1.23). תאריכים. אפשר לציין ביטויי תאריכים על ידי הוספת ‎^^xsd:dateTime (תלוי רישיות – ‎^^xsd:datetime לא יעבוד!) לתאריך בתסדיר ISO 8601 מחרוזת תאריך: ‎\"2012-10-29\"^^xsd:dateTime‎.  פעולות סימני פעולות החשבון הנפוצות זמינים: +,‏ -,‏ *,‏ / כדי להוסיף, להחסיר, להכפיל או לחלק מספרים, code><,‏ >,‏ =,‏ <=,‏ >= כדי להשוות ביניהם. בדיקת אי השוויון ≠ נכתבת כך: !=. השוואה מוגדרת גם לסוגים אחרים, למשל: \"abc\" < \"abd\" זה ביטוי אמת (השוואה מילונית), וגם \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime ו־wd:Q4653 != wd:Q283111. ואפשר לשלב תנאים בוליאניים עם && (וגם לוגי: a && b הוא ביטוי אמת אם גם a וגם b הם ביטויי אמת) וגם || (או לוגי: a || b הוא אמת אם אחד מהביטויים (או שניהם) of a וגם b הם ביטויי אמת). FILTER (סינון) מידע לחלופה שלעיתים היא מהירה יותר ל־FILTER, אפשר לעיין ב־MINUS, הינה דוגמה.FILTER(condition). היא פסוקית שאפשר להוסיף לשאילתת ה־SPARQL שלך כדי לסנן את התוצאות. בתוך הסוגריים, אפשר להוסיף כל ביטוי מסוג בוליאני, ורק התוצאות בהן הביטוי מחזיר אמת יהיו בשימוש.למשל, כדי לקבל רשימה של כל האנשים שנולדו ב־2015, קודם נמשוך את כל האנשים עם תאריך הלידה שלהם - SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} - ואז לסנן את זה להחזיר רק את התוצאות שבהן שנת הלידה היא 2015. יש שתי דרכים לעשות את זה: לחלץ את השנה של התאריך עם הפונקציה YEAR ולבדוק שהיא 2015 - FILTER(YEAR(?dob) = 2015). - או לבדוק שהתאריך הוא בין 1 בינואר, 2015 (כולל) ועד 1 בינואר, 2016 (לא כולל): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). אפשר לומר שהאפשרות הראשונה היא יותר ישירה אך מסתבר שהשנייה היא מהירה יותר, אז בואו נשתמש בה: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! שימוש אפשרי ב־FILTER קשור לתוויות. שירות התוויות הוא מאוד שימושי אם נרצה רק להציג תווית של משתנה. אך כדי לעשות כל מיני דברים עם התווית - למשל: לבדוק אם היא מתחילה ב־„Mr. ‎” - נראה שזה למעשה לא עובד: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! השאילתה הזאת מוצאת את כל המופעים של fictional human (Q15632617) ובודקת האם התוויות שלהם מתחילות ב־„Mr. ‎”‏ (STRSTARTS הוא קיצור של הביטוי „string starts [with]” (המחרוזת מתחילה ב־), יש גם את STRENDS (המחרוזת מסתיימת ב־) ואת CONTAINS (המחרוזת מכילה)). הסיבה שזה לא עובד היא ששירות התוויות מוסיף את המשתנים שלו מאוד מאוחר במהלך הערכת השאילתה, בנקודה שבה אנחנו מנסים לסנן לפני ‎?humanLabel, שירות התוויות עדיין לא יצר את המשתנה הזה.למרבה המזל, שירות התוויות הוא לא הדרך היחידה שבה אפשר לקבל את תווית הפריט. תוויות מאוחסנות גם הן כשלישיות רגילות, שמשתמשות בנשוא rdfs:label. כמובן שהכוונה היא לכל התוויות, לא רק לאלו שבאנגלית, אם אנחנו רוצים רק את התוויות באנגלית, נצטרך לסנן לפי שפת התווית: FILTER(LANG(?label) = \"en\"). הפונקציה LANG מחזירה את השפה של מחרוזת חד־לשונית, וכאן אנו בוחרים רק את התוויות האלה באנגלית. השאילתה המלאה היא: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! אנחנו מקבלים את התווית עם השלישייה ?human rdfs:label ?label, מגבילים אותה לתוויות באנגלית ואז בודקים אם היא מתחילה ב־„Mr. ‎”.אפשר גם להשתמש ב־FILTER עם ביטוי רגולרי. כמו בדוגמה הבאה SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! אם אילוץ התסדיר למזהה הוא ‎[A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! אפשר לסנן החוצה רכיבים מסוימים באופן הבא FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) אפשר לסנן ושיופיעו רכיבים שלא מולאו: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND,‏ BOUND,‏ IF (איגוד, תיחום, ברירה) בשלוש יכולות אלו משתמשים בדרך כלל בשילוב זו עם זו, נתחיל בהסבר על שלושתן ואז נעבור לכמה דוגמאות.בפסוקית ‪BIND(ביטוי AS ?variable).‬ אפשר להשתמש כדי להקצות את תוצאת הביטוי למשתנה (בדרך כלל משתנה חדש אבל אפשר גם לדרוס קיימים).BOUND(?variable) בודק אם משתנה תחום לערך (מחזיר true (אמת) או false (שקר)). שימושי מאוד למשתנים שהוקמו על ידי פסוקית OPTIONAL.IF(condition,thenExpression,elseExpression) מפוענח לכדי thenExpression אם condition (תנאי) מפוענח לכדי true, ול־elseExpression אם condition מפוענח ל־false. כלומר, IF(true, \"yes\", \"no\") יפוענח ל־\"yes\", ו־IF(false, \"great\", \"terrible\") יפוענח ל־\"terrible\".ב־BIND אפשר להשתמש כדי לאגד את תוצאות חלק מהחישוב למשתנה חדש. זאת יכולה להיות תוצאת ביניים של חישוב גדול יותר או פשוט תוצאה ישירות של השאילתה. למשל, כדי לאתר את גיל הנידונים לעונש מוות: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ב־BIND אפשר גם להשתמש כדי פשוט לאגד ערכים קבועים למשתנים כדי לשפר את נוחות הקריאה. למשל, שאילתה שמוצאת את כל הכמרות (נשים שמכהנות בתפקידי כמורה): SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! אפשר גם לשכתב לצורה הזאת: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! החלק המשמעותי של השאילתה, מ־‎?woman ועד ‎?priest.‎, הוא עכשיו קריא יותר. עם זאת, מקטע ה־BIND הגדול שלפני די מפריע, לכן צריך להשתמש בטכניקה הזאת במשורה. (בממשק המשתמש של WDQS, אפשר גם לרחף עם העכבר מעל תיאור הישות שלך, ואז ‎?female זה רק קריא יותר מ־wd:Q6581072 אם מתעלמים מהיכולת הזאת.)בביטויי IF בדרך כלל נעשה שימוש בתנאי-ביטויים שנבנו עם BOUND. למשל, נניח שיש לך שאילתה שמציגה כל מיני אנשים ובמקום פשוט להציג את התווית שלהם, נרצה להציג את המאפיין pseudonym (P742) שלהם אם יש להם כזה, ורק להשתמש בתווית אם לא קיים שם בדוי. לשם כך, יש לבחור את השם הבדוי בפסוקית OPTIONAL (זה חייב להיות בגדר רשות – אנחנו לא רוצים לנפות תוצאות שאין להן שם בדוי), ואז להשתמש ב־BIND(IF(BOUND(…‎ כדי לבחור או את השם הבדוי או את התווית. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! מאפיינים נוספים שאפשר להשתמש בהם באופן הזה הם nickname (P1449), posthumous name (P1786) וtaxon common name (P1843) – כל מקום שהגיוני להשתמש בו בסוג כלשהו של „נסיגה/גיבוי”.אפשר גם לשלב את BOUND עם FILTER כדי לוודא שלפחות אחת מבין הדרישות במקטעי ה־OPTIONAL מולאו. למשל, בואו ניקח את האסטרונאוטים שהגיעו לירח, לרבעות החברים של Apollo 13 (Q182252) (מספיק קרוב, לא?). אי אפשר לבטא את האילוץ הזה כנתיב מאפיין יחיד, לכן אנחנו צריכים פסוקית OPTIONAL עבור „חברים במשימת ירח כלשהי” ואחת נוספת עבור „חברי 13”. אבל אנחנו רוצים לבחור רק את התוצאות האלו שבהן לפחות אחד מהתנאים האלה הוא אמת (true). SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  COALESCE (החזרת הערך התקין מבין האפשרויות) אפשר להשתמש בפונקציית COALESCE כקיצור לתבנית ‎BIND(IF(BOUND(?x), ?x, ?y) AS ?z).‎ לנסיגות כדי שצוינו להלן: היא מקבלת מספר ביטויים ומחזיר את הראשון שמפוענח ללא שגיאה. למשל, הנסיגה של „השם הבדוי” הבא BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). אפשר לכתוב בצורה יותר מתומצתת בתור BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). ותמיד קל להוסיף תווית נסיגה נוספת למקרה שגם ‎?writerLabel לא מוגדר: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  קיבוץ עד השלב הזה, כל השאילתות שראינו הן שאילתות שמצאו את כל הפריטים שעונים על חלק מהתנאים, בחלק מהמקרים, כללנו גם קביעות נוספות על הפריט (ציורים עם החומרים, ספרים של ארתור קונאן דויל עם כותרת ואיור).אבל זה מאוד נפוץ לא לרצות רשימה ארוכה של כל התוצאות. במקום, נוכל לשאול שאלות כאלו: כמה ציורים צוירי על קנבס / עץ צפצפה / וכו׳? מה כמות האוכלוסיה הגדולה ביותר של ערים בכל מדינה? מה המספר הכולל של אקדחים שנוצרים על ידי כל יצרן ויצרן? מי מפרסם, בממוצע, את הספרים הארוכים ביותר?  אוכלוסיות עירוניות בואו נתמקד בשאלה שנייה כרגע. קל יחסית לכתוב שאילתה שמציגה את כל הערים לרבות האוכלוסיה והמדינה שהן נמצאות בה, תוך סידור התוצאות לפי מדינה: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (לתשומת ליבך: השאילתה הזאת מחזיקה המון תוצאות, שיכולות להאט את הדפדפן שלך. אולי עדיף להוסיף פסוקית LIMIT.)מאחר שאנחנו מסדרים את התוצאות לפי מדינה, כל הערים ששיכים למדינה יוצרים מקטע אחד ארוך בתוצאות. כדי למצוא את כמות האוכלוסיה הגדולהל ביותר במקטע הזה, נרצה להתייחס למקטע כקבוצה ולכנס את כל ערכי האוכלוסיה הפרטניים לערך אחד: המרבי. את זה אפשר לעשות עם פסוקית GROUP BY (קיבוץ לפי) מתחת למקטע ה־WHERE (כאשר) ופונקציית כינוס (MAX) בפסוקית ה־SELECT. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! החלפנו את ORDER BY (סידור לפי) ב־GROUP BY (קיבוץ לפי). ההשפעה של זה היא שכל התוצאות עם אותו ערך ב־‎?country תקובצנה יחד לתוצאה אחת. משמעות הדבר היא שצריך לשנות את גם את פסוקית ה־SELECT. אילו היינו משאיכים את פסוקית ה־SELECT ?country ?city ?population הישנה, אילו ?city ו־?population יוחזרו? כדאי לזכור, יש מגוון תוצאות בתוצאה היחידה הזאת, לכולן יש את אותו ערך ב־‎?country, כך שנוכל לבחור את זה, אך מאחר שלכל אחת מהן יכול להיות ‎?city ו־‎?population שונים, עלינו לספר ל־WDQS איזה מהערכים האלה לבחור. זאת העבודה של פונקציית הכינוס. במקרה הזה, השתמשנו ב־MAX: מתוך כל ערכי ה־‎?population, נבחר את המרבי לתוצאה המקובצת. (אנחנו גם צריכים לתת לערך הזה שם חדש עם המבנה AS (בתור), אבל זה פרט שולי.)זאת התבנית הכללית לכתיבת שאילתות קיבוץ: לכתוב שאילתה רגילה שמחזירה את הנתונים המבוקשים (ללא קיבוץ, עם הרבה תוצאות לכל „קבוצה”), לאחר מכן להוסיף פסוקית GROUP BY ולהוסיף פונקציית כינוס לכל המשתנים שאינם מקובצים בפסוקית ה־SELECT. חומרי ציור בואו ננסה את זה עם שאלה נוספת: כמה ציורים צוירו על כל סוג של חומר? קודם כל נכתוב שאילתה שרק מחזירה את כל הציורים יחד עם החומר עליהם צוירו. (כדאי לקחת בחשבון להשתמש רק בקביעות made from material (P186) כאלו שהן עם מבחין applies to part (P518)painting support (Q861259) .) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! עכשיו, צריך להוסיף פסוקית GROUP BY על ‎?material, ואז להוסיף פונקציית כינוס על המשתנה השני שנבחר (‎?painting). במקרה הזה, אנחנו מעוניינים במספר הציורים, פונקציית הכינוס לחישוב הזה היא COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! אחת הבעיות עם זה היא שאין לנו את התווית לחומרים, לכן לא כל כך נוח לפענח את התוצאות. אם פשוט נוסיף את משתנה התווית, נקבל שגיאה: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate „כינוס שגוי” (Bad aggregate) היא הודעת שגיאה שמאוד נפוץ לפגוש כשעובדים עם שאילתות קיבוץ, המשמעות היא שאחד מהמשתנים צריך פונקציית כינוס אבל אין לו כזאת, או שיש לו פונקציית כינוס אבל לא אמורה להיות לו. במקרה הזה, מנגנון WDQS חושב שיכולים להיות מגוון ‎?materialLabel על כל ‎?material (למרות שאנחנו יודעים שזה לא יכול להיות), ולכן הוא מתלונן שלא צוינה פונקציית כינוס למשתנה הזה.פתרון אחד הוא ליצור קיבוץ על מספר משתנים. אם מציגים מספר משתנים בפסוקית ה־GROUP BY, יש תוצאה אחת לכל שילוב של המשתנים האלה ואפשר לבחור את כל המשתנים האלה בלי פונקציית כינוס. במקרה הזה, נקבץ גם על גבי ‎?material וגם על גבי ‎?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! כמעט סיימנו עם השאילתה - רק עוד שיפור קטן: אנחנו רוצים לראות את החומרים השכיחים ביותר בהתחלה. למזלנו, מותר לנו להשתמש במשתנים החדשים המכונסים מפסוקית ה־SELECT, (כאן הם נקראים ‎?count) בפסוקית ORDER BY כך שזאת משימה די פשוטה: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! לשם התרגול, בואו נעשה גם את שאר השאילתות. אקדחים לפי יצרן מס מספר האקדחים הכולל שמיוצר על ידי כל אחד מהיצרנים? רמז הפריטים והמאפיינים הרלוונטיים הם: firearm (Q12796), manufacturer (P176), total produced (P1092). פתרון לדוגמה SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  מוציאים לאור לפי מספר דפים מה מספר הדפים הממוצע (פונקציה: AVG) של ספרים לפי מוציא לאור? רמז הפריטים והמאפיינים הרלוונטיים הם: publisher (P123), number of pages (P1104). פתרון לדוגמה SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it!  HAVING (שיש לו) תוספת קטנה לשאילתה האחרונה - אם מסתכלים על התוצאות, אפשר להבחין שלתוצאה המובילה יש ממוצע גדול בצורה מוגזמת, יותר מפי עשרה מהמקום השני. חקירה שטחית חושפת שזה כיוון שאותו מוציא לאור (UTET (Q4002388)) פרסם רק ספר אחד עם קביעה מסוג number of pages (P1104), Grande dizionario della lingua italiana (Q3775610), מה שמטה קצת את התוצאות. כדי להסיר חריגות כאלה, אפשר לבחור רק מוציאים לאור שהוציא לפחות שני ספרים עם קביעות מסוג number of pages (P1104) בוויקינתונים.איך עושים את זה? בדרך כלל, נגדיל את התוצאות עם פסוקית FILTER, אבל במקרה הזה אנחנו רוצים להגביל לפי הקבוצה (מספר הספרים), לא על כל תוצאה בנפרד. אפשר לעשות את זה עם פסוקית HAVING (שיש לו), שאפשר להוסיף מייד לאחר הפסוקית GROUP BY והיא מקבלת ביטוי באותו האופן כמו FILTER: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  סיכום על פונקציות כינוס הינה תקציר של פונקציות הכינוס הזמינות: COUNT: מספר הרכיבים. אפשר גם לכתוב COUNT(*) כדי לספור את כל התוצאות. SUM,‏ AVG: הסיכום או הממוצע של כל הרכיבים, בהתאמה. אם הרכיבים אינם מספרים תתקבלנה תוצאות מוזרות. MIN,‏ MAX: הערך הקטן או הגדול ביותר מבין כל הרכיבים, בהתאמה. עובד בכל סוגי הערכים; מספרים מסודרים לפי הגודל, מחרוזות וסוגים אחרים מילונית. SAMPLE: כל רכיב שהוא. על פי רוב זה שימושי אם ברור לך שיש תוצאה אחת או אם לא אכפת לך איזה ערך מוחזר. GROUP_CONCAT: משרשרת את כל הרכיבים אחד אחרי השני. שימושי, למשל, אם נרצה תוצאה אחת בלבד לפריט אבל לכלול מגוון פרטי מידע למאפיין שיש בו מספר קביעות לפריט הזה, כמו למשל עיסוק של אדם. את תחומי העיסוק השונים אפשר לקבץ מחדש ולשרשר כדי שיופיעו במשתנה אחד בלבד במקום במספר שורות. אם זה מסקרן אותך, אפשר לחפש את זה במפרט של SPARQL. בנוסף, אפשר להוסיף מבחין DISTINCT לכל אחת מהפונקציות האלה כדי להעלים את התוצאות הכפולות. למשל, אם יש שתי תוצאות אך לשתיהן יש את אותו הערך ב־‎?var, אז COUNT(?var) תחזיר 2 אבל COUNT(DISTINCT ?var) תחזיר 1 בלבד. בדרך כלל צריך להשתמש ב־DISTINCT כאשר השאילתה שלך יכולה להחזיר את אותו הפריט מספר פעמים - זה יכול לקרות אם, למשל, בחרת להשתמש ב־‎?item wdt:P31/wdt:P279* ?class, וישנם מספר נתיבים מ־‎?item אל ‎?class: תתקבל תוצאה חדשה לכל אחד מהנתיבים האלה, למרות שכל הערכים בתוצאה זהים. (אם לא קיבצת, אפשר לסלק את התוצאות הכפולות האלה על ידי התחלת השאילתה עם SELECT DISTINCT במקום רק SELECT.) wikibase:Label וכינוסים שאילתה כמו זו, שמחפשת את כל אנשי האקדמיה עם אזרחות ביותר משתי מדינות בוויקינתונים, לא מציגה את שמות המדינות האלה בעמודה ‎?citizenships: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! כדי להציג את ‎?citizenships, יש לתת ל־‎?personLabel ול־‎?citizenshipLabel שם מפורש בקריאת השירות wikibase:label באופן הבא: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, de Wikidata Query Service, is een krachtig hulpmiddel om inzicht te krijgen in de inhoud van Wikidata. Deze handleiding zal u leren hoe u het moet gebruiken. Zie ook de interactive tutorial gemaakt door Wikimedia Israël.Voordat u uw eigen SPARQL-query schrijft, kijk dan naar {{Item documentation}} of een andere generische SPARQL-query sjabloon en kijk of uw query al is toegevoegd. Contents 1 Voordat we beginnen 2 SPARQL basis 3 Onze eerste query 3.1 Automatisch aanvullen 4 Geavanceerde tripel patronen 5 Instanties en classes 5.1 Eigenschapspaden 6 Kwalificaties 7 ORDER en LIMIT 7.1 Oefening 7.1.1 Arthur Conan Doyle boeken 7.1.2 Chemische elementen 7.1.3 Rivers die in de Mississippi stromen 7.1.4 Rivers die in de Mississippi stromen II 8 OPTIONAL 9 Expressies, FILTER en BIND 9.1 Gegevenstypes 9.2 Operatoren 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Groeperen 10.1 Bevolking van steden 10.2 Schildersmaterialen 10.3 Wapens per fabrikant 10.4 Uitgevers per aantal pagina's 10.4.1 HAVING 10.5 Samenvatting van aggregatie functies 10.6 wikibase:Label en aggregaties 11 VALUES 12 Label in meerdere talen 13 En verder... 14 Zie ook Voordat we beginnen Hoewel deze tutorial misschien heel lang en intimiderend lijkt, laat u daar niet door afschrikken. Alleen het leren van de SPARQL-basis zal u ver op weg helpen - zelfs als u na #Onze eerste query stopt te lezen, zult u al meer begrijpen om veel interessante queries te bouwen. Elk deel van deze tutorial zal u in staat stellen die query nog krachtiger te maken.Als u nog nooit van Wikidata, SPARQL of WDQS hebt gehoord, is hier een korte uitleg van die termen: Wikidata is een kennisdatabase. Het bevat miljoenen verklaringen, zoals \"de hoofdstad van Canada is Ottawa\", of \"de Mona Lisa is in olieverf op populierenhout geschilderd\", of \"goud smelt op 1.064,18 graden Celsius\". SPARQL is een taal voor het formuleren van een query (of meerdere queries) voor kennisdatabases. Met de juiste database kan een SPARQL-navraag vragen beantwoorden als \"wat is de meest populaire toon in muziek?\" of \"welk personage werd door de meeste acteurs afgebeeld?\" of \"wat is de verdeling van bloedgroepen?\" of welke werken van auteurs zijn dit jaar in het publieke domein gekomen? WDQS, de Wikidata Query Service, brengt de twee samen: u voert een SPARQL-query in, het wordt uitgevoerd op de dataset van Wikidata en laat het resultaat zien.  SPARQL basis Een eenvoudige SPARQL-query kan er zo uitzien: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} De SELECT clause geeft de variabele aan die u wilt opvragen (elke variabele begint met een vraagteken), en de WHERE clause bevat de beperkingen, meestal in de vorm van tripels. Alle informatie in Wikidata (en vergelijkbare kennisdatabases) wordt opgeslagen in de vorm van tripels; Wanneer u de query uitvoert, probeert de queryservice de variabelen in te vullen met werkelijke waarden, zodat de resulterende triples worden weergegeven in de kennisdatabase en één resultaat retourneert voor elke combinatie van variabelen die wordt gevonden.Een tripel kan worden gezien als twee hoekpunten (alias 2 knooppunten, 2 bronnen) verbonden door een rand (een boog, een eigenschap) binnen de gerichte (georiënteerde) eigenschapsmultigraaf die Wikidata vormt. Het kan worden gelezen als een zin (daarom eindigt het met een punt), met een onderwerp, een predicaat en een object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Het resultaat van deze query kan bijvoorbeeld \"lemon\" bevatten. In Wikidata zijn de meeste eigenschappen eigenschappen van het soort \"has\", dus de query kan in plaats daarvan luiden: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} wat leest als “?fruit heeft kleur ‘geel’” (niet “?fruit is de kleur van ‘geel’” – denk hieraan voor eigenschapsparen als “parent”/“child”!)Dat is echter geen goed voorbeeld voor WDQS. Smaak is subjectief, dus Wikidata heeft er geen eigenschap voor. Laten we in plaats daarvan eens nadenken over parent/child-relaties, die meestal ondubbelzinnig zijn. Onze eerste query Stel dat we alle kinderen van de barokcomponist Johann Sebastian Bach willen opnemen. Met pseudo-elementen zoals in de vragen hierboven, hoe zou u die query schrijven?Hopelijk heeft u iets als dit: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (NB: alles na een '#' is een commentaar en wordt door WDQS genegeerd. )
} of dit, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} of dit, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} De eerste twee tripels zeggen dat het kind als ouder/vader Bach moet hebben; de derde zegt dat Bach het kind het kind moet hebben. Laten we nu de tweede nemen.Wat moet er dan nog gedaan worden om dit in een goede WDQS-vraag te veranderen? Op Wikidata worden items en eigenschappen niet geïdentificeerd door door menselijk leesbare namen zoals \"vader\" (eigendom) of \"Bach\" (item). (Met goede reden: \"Johann Sebastian Bach\" is ook de naam van een Duitse schilder, en \"Bach\" kan ook verwijzen naar de achternaam, de Franse commune, de Mercuriuskrater, enz. ) In plaats daarvan wordt aan Wikidata-artikelen en eigenschappen een identificatiecode toegewezen. de identificator voor een item we zoeken naar het item en kopiëren het Q-nummer van het resultaat dat klinkt alsof het het item is dat we zoeken (gebaseerd op de beschrijving, bijvoorbeeld). Om de identificatiecode voor een eigenschap te vinden, doen we hetzelfde, maar zoeken we naar \"P:zoekterm\" in plaats van gewoon \"zoekterm\", wat de zoekopdracht beperkt tot eigenschappen. Dit vertelt ons dat de beroemde componist Johann Sebastian Bach Q1339 is, en de eigenschap om de vader van een item te vinden P:P22 is.En last but not least, we moeten voorvoegsels toevoegen. Voor eenvoudige WDQS-tripels moeten de items worden voorafgegaan metwd:, en de eigenschappen met wdt:. (Maar dit geldt alleen voor vaste waarden - variabelen krijgen geen prefix!)Samengevat wordt onze eerste WDQS-query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Klik op de link Probeer het en vervolgens op Uitvoeren op de WDQS-pagina. Wat krijgt u als antwoord? child wd:Q57225 wd:Q76428 … Dat is teleurstellend. U ziet alleen de identificaties. U kunt op ze klikken om hun Wikidata-pagina te zien (inclusief een voor mensen leesbaar label), maar is er geen betere manier om de resultaten te zien?Die is er natuurlijk wel. (Zijn retorische vragen niet geweldig?) Als u de magische tekst toevoegt SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } in de WHERE-clausule wordt er nog een aantal variabelen opgehaald: voor elke variabele ?foo in de query is er nu ook een variabele ?fooLabel, die het label van het item achter ?foo bevat. Als u dit toevoegt aan de SELECT-clausule, krijgt u het item en zijn label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Probeer die query uit te voeren, u zou nu niet alleen de artikelnummers moeten zien, maar ook de namen van de verschillende kinderen. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Automatisch aanvullen Het stukje code SERVICE ziet er moeilijk uit om te onthouden, toch? En de hele tijd door de zoekfunctie gaan terwijl u de zoekopdracht schrijft, is ook vervelend. Gelukkig biedt WDQS hier een prima oplossing voor: autocompletion. In de query-editor query.wikidata.org kunt u op elk gewenst moment in de query op Ctrl+Space (of Alt+Enter of Ctrl+Alt+Enter) drukken en suggesties voor code krijgen die geschikt kunnen zijn. Selecteer de juiste suggestie met de pijltoetsen omhoog /omlaag en druk op Enter om deze te selecteren.Voorbeeld, in plaats van het uitschrijven van SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }, kunt u ook intikken SERV, vervolgens Ctrl+Space doen, en de eerste suggestie zal het automatisch aanvullen van het label zijn, klaar voor gebruik! Accepteer de suggestie met Enter. (De opmaak zal een beetje anders zijn, maar dat maakt niet uit.)Met automatisch aanvullen kunt u ook zoeken. Als u een van de Wikidata-voorvoegsels, zoals wd: of wdt:, tikt en vervolgens gewoon tekst schrijft, zal Ctrl+Space op Wikidata naar die tekst zoeken en suggesties tonen. wd: zoekopdrachten naar items, wdt: zoekopdracht naar eigenschappen. In plaats van bijvoorbeeld naar items voor Johann Sebastian Bach (Q1339) en father (P22) te zoeken, kunt u gewoon wd:Bach en wd:Bach typen en vervolgens gewoon de juiste suggestie selecteren. (Dit werkt zelfs met spaties in de tekst, bijvoorbeeld wd:Johann Sebastian Bach.) Geavanceerde tripel patronen We hebben nu alle kinderen van Johann Sebastian Bach opgezocht. Meer specifiek: alle items met de vader Johann Sebastian Bach. Maar Bach had twee vrouwen, en dus kunnen die personen verschillende moeders hebben: wat als we alleen de kinderen van Johann Sebastian Bach met zijn eerste vrouw willen zien, Maria Barbara Bach (Q57487)? Probeer die query te schrijven.Heeft u dat gedaan? Oké, dan op de oplossing! De eenvoudigste manier om dit te doen is om een tweede tripel toe te voegen met die beperking: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Er staat dan: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. Dat klinkt een beetje ongemakkelijk, nietwaar? In natuurlijke taal, zouden we dit afkorten tot: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In SPARQL is het zelfs mogelijk om dezelfde afkorting uit te drukken: Als u een tripel eindigt met een puntkomma (;) in plaats van een punt, kunt u een ander predikaat-objectpaar toevoegen. Hiermee kunnen we de bovenstaande query verkorten tot: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Dat geeft dezelfde resultaten, maar minder herhaling in de query.Stel dat we alleen maar belangstelling hebben voor kinderen die ook componisten en pianisten waren. De relevante eigenschappen en items zijn: occupation (P106), composer (Q36834) en pianist (Q486748). Probeer de bovenstaande query bij te werken om deze beperkingen toe te voegen!Dit is mijn oplossing: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Hierbij wordt ; twee keer meer gebruikt om de twee vereiste beroepen toe te voegen. Maar zoals u kunt zien, is er nog steeds een beetje herhaling. Het is alsof we zeggen: Kind heeft het beroep componist en het beroep pianist. We zeggen dan meestal: Kind heeft de beroepen componist en pianist. En SPARQL heeft daar ook een syntaxis voor: net als ; laat u toe een predikate-objectpaar aan een tripel toe te voegen (met hergebruik van het onderwerp), een , laat u toe om een ander object aan een tripel aan te voegen (met hergebruik van onderwerp en predikaat). Hiermee kan de query worden: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! NB: inspringing en andere witruimtes doen er eigenlijk niet toe, ze maken het alleen leesbaarder. U kunt dit ook schrijven als: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # beide beroepen op een regel
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! of, wat minder leesbaar: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # zonder inspringen of nieuwe regels wordt het moeilijker leesbaar of er nu een ';' staat of een ','
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Gelukkig springt de WDQS-editor automatisch in, dus u hoeft u hier meestal geen zorgen over te maken.Oké, laten we hier samenvatten. We hebben gezien dat queries zijn gestructureerd als tekst. Elk tripel over een onderwerp wordt afgesloten met een punt. Meerdere predicaten over hetzelfde onderwerp worden gescheiden door middel van puntkomma's, en meerdere objecten voor hetzelfde onderwerp en predicaat kunnen worden vermeld gescheiden door komma's. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Nu wil ik nog een afkorting introduceren die SPARQL biedt. Dus als u een hypothetisch scenario wilt laten maken...Stel dat we niet geïnteresseerd zijn in Bach's kinderen. Maar wij zijn geïnteresseerd in zijn \"kleinkinderen\". Er is hier één complicatie: een kleinkind kan verwant zijn aan Bach via de moeder of de vader. Dat zijn twee verschillende eigenschappen, wat ongemakkelijk is. Laten we de relatie omdraaien: Wikidata heeft ook een \"kind\" eigenschap, P:P40, die van ouder naar kind wijst en geslachtonafhankelijk is. Kunt u met deze informatie een query schrijven om naar Bachs kleinkinderen te zoeken?Dit is mijn oplossing: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natuurlijke taal is dat: Bach has a child ?child. ?child has a child ?grandChild. Opnieuw stel ik voor dat we deze Engelse zin verkorten, en dan wil ik u laten zien hoe SPARQL een vergelijkbare afkorting ondersteunt. Let op dat we eigenlijk niet om het kind geven: we gebruiken de variabele niet, behalve om te praten over het kleinkind. We kunnen de zin verkorten tot: Bach has as child someone who has a child ?grandChild. In plaats van te zeggen wie Bachs kind is, zeggen we gewoon \"iemand\": het maakt ons niet uit wie het is. Maar we kunnen terug naar hen, omdat we hebben gezegd \"iemand \"wie\": dit begint een relatieve clausule, en binnen die relatieve clausule kunnen we dingen zeggen over \"iemand\" (bijvoorbeeld dat ze \"een kind hebben ?grandChild\"). Op een bepaalde manier is \"iemand\" een variabele, maar een speciale die alleen geldig is binnen deze relatieve clausule, en een waar we niet expliciet naar verwijzen (we zeggen \"iemand die dit is en dat doet\", niet \"iemand dat dit is en iemand die dat doet\" - dat zijn twee verschillende \"iemanden\").In SPARQL kan dit worden geschreven als: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! We kunt een paar haakjes ([]) gebruiken in plaats van een variabele, die als een anonieme variabele fungeert. Binnen de koppels kunt u predicaat-objectparen vermelden, net als na een ; na een normale tripel; het impliciete onderwerp is in dit geval de anonieme variabele die de koppels vertegenwoordigen. (NB: ook net als na een ; kunt u meer predicaat-objectparen toevoegen met meer puntkomma's, of meer objecten voor hetzelfde predicaat met komma's.)En dat is het voor drievoudige patronen! Er is meer aan SPARQL, maar omdat we de delen ervan gaan verlaten die sterk vergelijkbaar zijn met natuurlijke taal, wil ik die relatie nog een keer samenvatten: natuurlijke taal voorbeeld SPARQL voorbeeld zin Juliet loves Romeo. punt juliet loves romeo. conjunctie (clause) Romeo loves Juliet and kills himself. puntkomma romeo loves juliet; kills romeo. conjunctie (zelfstandig naamwoord) Romeo kills Tybalt and himself. komma romeo kills tybalt, romeo. relatieve clausule Juliet loves someone who kills Tybalt. haakjes juliet loves [ kills tybalt ].  Instanties en classes Eerder zei ik dat de meeste Wikidata-eigenschappen \"has/heeft\" relaties zijn: \"heeft\" kind, \"heeft\" vader, \"heeft\" baan. Maar soms (in feite, vaak) moet u ook praten over wat iets \"is\". Maar er zijn eigenlijk twee soorten relaties: Gone with the Wind is een film. Een film is een kunstwerk. Gone with the Wind is een bepaalde film. Het heeft een bepaalde regisseur (Victor Fleming), een specifieke duur (238 minuten), een lijst van castleden (Clark Gable, Vivien Leigh,...), enzovoort.Film is een algemeen begrip. Films kunnen regisseurs, (speel)duur en castleden hebben, maar het concept \"film\" als zodanig heeft geen specifieke regisseur, duur of castleden. En hoewel een film een kunstwerk is, en een kunstwerk meestal een schepper heeft, heeft het concept van \"film\" zelf geen schepper - alleen specifieke instancties van dit concept wel.Dit verschil is de reden waarom er in Wikidata twee eigenschappen voor \"is\" zijn: instance of (P31) en subclass of (P279). \"Gone with the Wind\" is een bijzonder voorbeeld van de klasse \"film\"; de klasse \"film\" is een onderklasse (meer specifieke klasse; specialisatie) van de meer algemene klasse \"kunstwerk\".Om u te helpen het verschil te begrijpen, kunt u twee verschillende werkwoorden gebruiken: \"is een\" en \"is een soort van\". Als \"is een soort\" werkt (bijv. een film \"is een type\" kunstwerk), geeft het aan dat u het heeft over een subklasse, een specialisatie van een bredere klasse en moet u subclass of (P279) gebruiken. Als \"is een soort\" niet werkt (bijvoorbeeld de zin \"Gone with the wind \"is een type\" film\" is niet logisch), geeft het aan dat u praat over een bepaalde instantie en moet u instance of (P31) gebruiken.Wat betekent dit voor ons als we SPARQL-queries schrijven? Als we naar \"alle kunstwerken\" willen zoeken, is het niet genoeg om naar alle items te zoeken die direct voorbeelden zijn van \"kunstwerken\": SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instantie van kunstwerk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Terwijl ik dit schrijf (oktober 2016), geeft die query slechts 2.815 resultaten terug - natuurlijk zijn er meer kunstwerken dan dat! Het probleem is dat er hier items zoals \"Gone with the Wind\" missen, wat slechts een voorbeeld is van \"film\", niet van \"kunstwerk\". \"film\" is een onderklasse van \"kunstwerk\", maar we moeten SPARQL vertellen om daar rekening mee te houden bij het zoeken.Een mogelijke oplossing hiervoor is de syntaxis [] waarover we spraken: \"Gone with the Wind\" is een voorbeeld van sommige onderklasse van \"kunstwerk\". (Oefening: probeer die query te schrijven!) Maar dat heeft nog steeds problemen: We nemen niet langer items op die rechtstreeks voorbeelden van kunstwerken zijn. We missen nog steeds items die voorbeelden zijn van een bepaalde subklasse van een \"andere\" subklasse \"kunstwerk\" - bijvoorbeeld, \"Snow White and the Seven Dwarfs\" is een animatiefilm, dat een film is, dat een kunstwerk is. In dit geval moeten we twee \"subklasse van\" verklaringen volgen - maar het kan ook drie, vier, vijf zijn, elk aantal is mogelijk. De oplossing: ?item wdt:P31/wdt:P279* ?class. Dit betekent dat er één \"instantie van\" en dan een aantal \"subclass van\" verklaringen zijn tussen het item en de klasse. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # een instantie van een subklasse kunstwerken
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Ik raad u niet aan om die query te laten draaien. WDQS kan het (maar net aan), maar uw browser kan struikelen als u de resultaten probeert weer te geven omdat er zoveel van hen zijn.)Nu weet u hoe u moet zoeken naar alle kunstwerken, of alle gebouwen, of alle menselijke nederzettingen: de magische bezwering : wdt:P31/wdt:P279*, samen met de juiste klasse. Dit gebruikt wat meer SPARQL-functies die ik nog niet heb uitgelegd, maar eerlijk gezegd is dit bijna het enige relevante gebruik van die functies, dus hoeft u niet te moeten begrijpen hoe het werkt om WDQS effectief te gebruiken. Als u het wilt weten, zal ik het zo uitleggen, maar u kunt ook gewoon het volgende gedeelte overslaan en wdt:P31/wdt:P279* onthouden of kopiëren + plakken vanaf hier wanneer u het nodig hebt. Eigenschapspaden Over het algemeen is het pad dat het bronknooppunt (subject) verbindt met het doelknooppunt (object) door de grafiek niet altijd direct: het kan zijn dat men nul, één of meerdere schakels (segmenten, namelijk padelementen) moet samenvoegen tot een keten; En er kunnen meerdere van dergelijke paden (routes) zijn. Het object van een padelement in de keten wordt het onderwerp van het volgende element. In SPARQL, eigenschapspaden zijn een manier om heel strikt zo'n pad van eigenschappen tussen twee items op te schrijven. Het eenvoudigste pad is slechts een enkele eigenschap, die een gewone tripel vormt: ?item wdt:P31 ?class. U kunt pad-elementen toevoegen met een slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Dit is gelijk aan een van de volgende: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Oefening: schrijf de query \"kleinkinderen van Bach\" met gebruik van deze syntaxis.Een ster (*) na een pad betekent “nul of meer van deze elementen”. ?item wdt:P31/wdt:P279* ?class.
# betekentː
?item wdt:P31 ?class
# of
?item wdt:P31/wdt:P279 ?class
# of
?item wdt:P31/wdt:P279/wdt:P279 ?class
# of
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# of ... In het speciale geval dat er een nul-eigenschap in een pad is (geen specifieke relatieboog: een NULL, \"universele\" eigenschap), dan is de onderwerpknoop direct verbonden met de objectknoop in de grafiek, ongeacht de objectknoop, inclusief zichzelf. Zodat er altijd een match is. Dus, in SPARQL, bijvoorbeeld in het geval \"nul iets\", wordt ?a iets*?b gereduceerd tot ?a ?b, zonder pad ertussen, en ?a neemt direct de waarde van ?b.Een plus (+) is vergelijkbaar met een ster, maar betekent \"één\" of meer van deze elementen. De volgende query vindt alle afstammelingen van Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Als we hier een ster zouden gebruiken in plaats van een plus, zou het resultaat ook Bach zelf bevatten.Een vraagsteken (?) is vergelijkbaar met een ster of een plus, maar betekent \"nul of één\" van dit element.U kunt pad-elementen met een verticale lijn (|) scheiden in plaats van een slash te gebruiken; dit betekent \"of-of\": het pad kan een van deze eigenschappen gebruiken. (Maar niet gecombineerd - een een of ander segment past altijd bij een pad van lengte één.)U kunt ook pad-elementen met haakjes (()) groeperen en al deze syntaxiselementen vrij combineren (/|*+?). Dat betekent dat een andere manier om alle afstammelingen van Bach te vinden is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In plaats van de eigenschap \"child\" te gebruiken om van Bach naar zijn nakomelingen te gaan, gebruiken we de eigenschappen \"father\" en \"mother\" om van de afstammelingen naar Bach te gaan. Het pad kan twee moeders en een vader omvatten, of vier vaders, of vader-moeder-moeder-vader, of een andere combinatie. (Al kan Bach natuurlijk niet de moeder van iemand zijn, dus het laatste element zal altijd vader zijn.) Kwalificaties (Eerst goed nieuws: dit gedeelte introduceert geen extra SPARQL syntaxis. Dit is een toetje.)Tot nu toe hebben we alleen gesproken over eenvoudige verklaringen: onderwerp, eigenschap, object. Maar Wikidata-verklaringen zijn meer dan dat: ze kunnen ook kwalificaties en referenties hebben. De Mona Lisa heeft bijvoorbeeld drie verklaringen made from material (P186): oil paint (Q296955), het hoofdmateriaal; poplar wood (Q291034), met de kwalificatie applies to part (P518)painting support (Q861259) – het materiaal waarop de Mona Lisa is geschilderd; en wood (Q287), met de kwalificaties applies to part (P518)stretcher (Q1737943) en start time (P580) 1951 – het deel dat later aan het schilderij is toegevoegd. Stel dat we alle schilderijen met hun schilderijoppervlak willen vinden, dat wil zeggen, die verklaringen made from material (P186) met een kwalificatie applies to part (P518)painting support (Q861259) . Hoe doen we dat? Dat is meer informatie dan in een enkele tripel kan worden weergegeven.Het antwoord is: meer tripels! (De vuistregel: de oplossing van Wikidata voor bijna alles is \"meer items\", en de overeenkomstige WDQS regel is \"meer tripels\". Referenties, numerieke precisie, waarden met eenheden, coördinaten, ..., die we hier allemaal overslaan, werken ook op deze manier.) Tot nu toe hebben we de prefix wdt: gebruikt voor onze tripels, die rechtstreeks naar het object van de verklaring wijst. Maar er is ook een ander prefix: p:, dat niet naar het object wijst, maar naar een \"verklaring node\". Deze node is dan het onderwerp van andere tripels: de prefix ps: (voor property statement) wijst naar het statement object, de prefix pq: (property qualifier) naar kwalificaties, en prov:wasDerivedFrom wijst naar referentie-nodes (die we voorlopig zullen negeren).Dat was een heleboel abstracte tekst. Hier is een concreet voorbeeld voor de Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: materiaal gebruikt: ?statement1
?statement1 ps:P186 wd:Q296955.  # waarde: olieverf

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: materiaal gebruikt: ?statement2
?statement2 ps:P186 wd:Q291034.  # Waarde: populierenhout
?statement2 pq:P518 wd:Q861259.  # kwalificatie: van toepassing op deel: verfoppervlakte

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: materiaal gebruikt: ?statement3
?statement3 ps:P186 wd:Q287.     # waarde: hout
?statement3 pq:P518 wd:Q1737943. # kwalificatie: van toepassing op onderdeel: balk stretcher
?statement3 pq:P580 1951.        # kwalificatie: starttijd: 1951 (pseudo-syntaxis) We kunnen dit afkorten met de syntaxis [], waarbij de ?statement\"-variabelen worden vervangen: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Kunt u deze kennis gebruiken om een query te schrijven voor alle schilderijen met hun schilderijoppervlak?Dit is mijn oplossing: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Ten eerste beperken we ?painting (de schilderijen) tot alle instanties van painting (Q3305213) of een subklasse daarvan. Vervolgens extraheren we het materiaal uit de p:P186 node, waarbij we de verklaringen beperken tot die met een kwalificatie applies to part (P518)painting support (Q861259) . ORDER en LIMIT We gaan terug naar ons reguliere programma met meer SPARQL-functies.Tot nu toe hebben we alleen queries gedaan waar we geïnteresseerd waren in alle resultaten. Maar het is heel gebruikelijk om alleen maar om een paar resultaten te willen zoeken: die die op een of andere manier het meest extreme zijn - oudste, jongste, vroegste, nieuwste, hoogste bevolking, laagste smeltpunt, de meeste kinderen, de meeste gebruikte materialen, enzovoort. De gemeenschappelijke factor hier is dat de resultaten op een of andere manier \"rangschikt\" zijn, en dan geven we om de eerste resultaten (de resultaten met de beste rang).Dit wordt gecontroleerd door twee clausules, die aan de WHERE {} (na de accolades, niet binnen!) worden gehecht: ORDER BY en LIMIT.De resultaten worden volgens op iets gesorteerd met ORDER BY iets. Het enige soort expressie (iets) dat we nu kennen zijn eenvoudige variabelen, maar we zullen later andere soorten zien. Deze expressie kan ook worden omwikkelt met ASC() of DESC() om de sorteervolgorde (\"'ascending\" of \"desc\"'ending) te specificeren. Als u het niet aangeeft dan is het ascending, dus oplopend.LIMIT count kapt het aantal vondsten in het resultaat af op count resultaten, waar count gewoon een getal is. Voorbeeld: LIMIT 10 zorgt ervoor dat de query maximaal 10 regels teruggeeft. LIMIT 1 geeft dus maar maximaal één regel in het resultaat.(U kunt ook LIMITgebruiken zonder ORDER BY. In dit geval worden de resultaten niet gesorteerd, dus u heeft geen garantie welke resultaten u krijgt. Wat goed is als u weet dat er slechts een bepaald aantal resultaten zijn, of u gewoon geïnteresseerd bent in \"sommige\" resultaten, maar het u niet uitmaakt, welke dat zijn. In beide gevallen kan het toevoegen van de LIMIT de zoekopdracht aanzienlijk versnellen, omdat WDQS het zoeken kan stoppen zodra er genoeg gevonden zijn volgens de limiet.)Tijd om te oefenen! Probeer een query te schrijven die de tien meest bevolkte landen teruggeeft. Een land is een sovereign state (Q3624078), en de eigenschap voor bevolking is P:P1082. U kunt beginnen met het zoeken naar landen met een bevolking en vervolgens de ORDER BY en LIMIT clausules toevoegen.Dit is mijn oplossing: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Merk op dat als we de meest bevolkte landen willen, we moeten descending moeten ordenen op bevolking, zodat de eerste resultaten de landen met de hoogste bevolking zullen zijn. Oefening We hebben al veel zaken besproken, ik denk dat het tijd is voor oefeningen. (U kunt dit gedeelte overslaan als u haast hebt.) Arthur Conan Doyle boeken Schrijf een query die alle boeken van Sir Arthur Conan Doyle ophaalt. Tip De relevante items en eigenschappen zijn Arthur Conan Doyle (Q35610), author (P50). Voorbeeld oplossing SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Chemische elementen Schrijf een query die alle chemische elementen retourneert met hun elementsymbool en atoomnummer, in volgorde van hun atoomnummer. Tip De relevante items en eigenschappen zijn chemical element (Q11344), element symbol (P246), atomic number (P1086). Voorbeeld oplossing SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  Rivers die in de Mississippi stromen Schrijf een query die alle rivieren retourneert die rechtstreeks in de Mississippi uitmonden. (De grootste uitdaging is het vinden van de juiste eigenschap...) Tip De relevante items en eigenschappen zijn Mississippi River (Q1497), mouth of the watercourse (P403). Voorbeeld oplossing SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Rivers die in de Mississippi stromen II Schrijf een query die alle rivieren geeft die direct of indirect in de Mississippi rivier stromen. Tip Deze query is bijna identiek aan de vorige. Het verschil is dat u deze keer een pad nodig hebt in plaats van een tripel. (Als u het gedeelte over paden hebt overgeslagen, sla deze oefening dan ook over.) Voorbeeld oplossing SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In de oefeningen hierboven staat een query voor alle boeken van Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Maar dat is een beetje saai. Er zijn zoveel potentiële gegevens over boeken, en we tonen alleen het label? Laten we proberen een query te maken die ook title (P1476), illustrator (P110), publisher (P123) en publication date (P577) bevat.Een eerste poging zou er zo uit kunnen zien: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Voer de query uit. Terwijl ik dit schrijf, geeft het slechts twee resultaten! Waarom is dat zo? We vonden eerder meer dan honderd boeken!De reden is dat een potentieel resultaat (een boek) om deze vraag te beantwoorden, alle drie de tripels moeten overeenkomen die we hebben vermeld: het moet een titel hebben, een illustrator, een uitgever en een publicatiedatum. Als het een aantal van die eigenschappen heeft, maar niet alle, zal het niet overeenkomen. En dat is niet wat we willen in dit geval: we willen in de eerste plaats een lijst van alle boeken. Als er extra gegevens beschikbaar zijn, willen we die weten, maar we willen niet dat dat onze lijst van resultaten beperkt.De oplossing is om WDQS te vertellen dat die tripels optioneel zijn: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Dit geeft ons de extra variabelen (?title, ?publisher etc.) als de juiste verklaring bestaat, maar als het niet bestaat, wordt het resultaat niet weggegooid - de variabele is gewoon niet ingesteld.NB: het is erg belangrijk om hier afzonderlijke OPTIONAL clausules te gebruiken. Als u alle tripels in één clausule zet, zoals hier - SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! - zult u merken dat de meeste resultaten geen extra informatie bevatten. Dit komt omdat een optionele clausule met meerdere tripels alleen overeenkomt wanneer alle die triples tegelijk voorkomen. Dat wil zeggen: als een boek een titel, een illustrator, een uitgever en een publicatiedatum heeft, dan past de optionele clausule overeen, en worden die waarden toegewezen aan de juiste variabelen. Maar als een boek bijvoorbeeld een titel heeft, maar geen illustrator, dan past de volledige optionele clausule niet overeen, en hoewel het resultaat niet wordt afgewezen, blijven alle vier variabelen leeg. Expressies, FILTER en BIND Deze sectie lijkt misschien iets minder georganiseerd dan de andere, omdat het een vrij breed en divers onderwerp behandelt. Het basisconcept is dat we iets willen doen met de waarden die we tot nu toe gewoon hebben geselecteerd en lukraak hebben teruggegeven. En expressies zijn de manier om deze operaties op waarden uit te drukken. Er zijn veel soorten expressies en veel dingen die u ermee kunt doen, maar laten we eerst beginnen met de basis: gegevenstypen. Gegevenstypes Elke waarde in SPARQL heeft een type, die aangeeft wat voor soort waarde het is en wat u ermee kunt doen. De belangrijkste types zijn: item, zoals wd:Q42 voor Douglas Adams (Q42). boolean, met twee mogelijke waarden true en false. Deze waarden worden niet opgeslagen in verklaringen, maar veel expressies geven een boolean waarde terug, bijv. 2 < 3 (true) of \"a\" = \"b\" (false). string, een tekst. Deze worden tussen dubbele aanhalingstekens geschreven. eentalige tekst, een tekst met een bijbehorende tag voor de taal. In een tekst kunt u deze tag toevoegen na de tekst met het teken @, voorbeeld \"Douglas Adams\"@en. nummers, of integers (1) of met decimalen (1.23). datums. Deze worden geschreven met de ^^xsd:dateTime toegevoegd (hoofdletterafhankelijk – ^^xsd:datetime zal niet werken!) aan een ISO 8601 datumstring: \"2012-10-29\"^^xsd:dateTime.  Operatoren De bekende wiskundige operatoren zijn beschikbaar: +, -, *, / om getallen toe te voegen, af te trekken, te vermenigvuldigen of te delen, <, >, =, <=, >= om ze te vergelijken. De ongelijkheidstest ≠ wordt geschreven als !=. Vergelijkingen wordt ook voor andere soorten gedefinieerd; bijvoorbeeld, \"abc\" < \"abd\" is waar (lexicale vergelijking), zoals \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime enwd:Q4653 != wd:Q283111. En booleaanse voorwaarden kunnen worden gecombineerd met && (logische en: a && b is waar als zowel a en b waar zijn) en || (logisch of: a || b is waar indien een (of beide) van a en b waar is). FILTER Info Voor een soms sneller alternatief voor FILTER, kunt u ook kijken naar MINUS, zie voorbeeld.FILTER(condition). is een clausule die u in een SPARQL query kunt gebruiken om de resultaten te filteren. Binnen de haakjes kunt u elke expressie met een booleaans type plaatsen, alleen die resultaten waar de expressie true is, worden gebruikt.Om bijvoorbeeld een lijst te krijgen van alle mensen die in 2015 zijn geboren, halen we eerst alle mensen met hun geboortedatum op SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} - en vervolgens filteren om alleen de resultaten terug te geven wanneer het jaar van de geboortedatum 2015 is. Er zijn twee manieren om dat te doen: het jaar met de YEAR functie eruit te halen of het testen of het jaar 2015 is FILTER(YEAR(?dob) = 2015). - of controleer of de datum tussen 1 januari 2015 (inclusief) en 1 januari 2016 (exclusief) is: FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Ik zou zeggen dat het eerste eenvoudiger is, maar de tweede is veel sneller, dus laten we die gebruiken: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Een ander mogelijk gebruik van FILTER is in verband met de labels. De service label is zeer nuttig als u alleen het label van een variabele wilt weergeven. Maar u iets met het label wilt doen, bijvoorbeeld: controleren of het begint met \"Mr\", dan blijkt dat dat niet werkt. SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! Deze query vindt alle instanties van fictional human (Q15632617) en test of hun label begint met \"Mr. \" (STRSTARTSSTRSTARTS is afkorting voor \"string begint [met]\"; er zijn ook functies STRENDS en CONTAINS). De reden waarom dit niet werkt is dat de service label zijn variabelen heel laat toevoegt tijdens de evaluatie van de query; op het moment dat we proberen te filteren op 'humanLabel', heeft de service die variabele nog niet gemaakt.Gelukkig is de service label niet de enige manier om het label van een item te krijgen. Labels worden ook opgeslagen als gewone tripels, met behulp van het predicaatrdfs:label. Dit betekent natuurlijk alle labels, niet alleen Engelse; als we alleen Engelse labels willen, moeten we filteren op de taal van het label: FILTER(LANG(?label) = \"en\"). De functie LANG geeft de taal van een eentalige string terug en hier selecteren we alleen de labels die in het Engels zijn. De volledige query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! Wij krijgen het label met de ?human rdfs:label ?label tripel, beperkt tot de Engelse labels, en controleren daarna of dat begint met “Mr. ”.Filter kan ook worden gebruikt met een reguliere expressie. In het volgende voorbeeld SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Als de formaatbeperking voor een ID [A-Za-z][-.0-9A-Za-z]{1,} is: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! Het is mogelijk om specifieke elementen als deze te filteren FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) Het is mogelijk om elementen te filteren die niet zijn gevuld: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Deze drie functies worden vaak in combinatie gebruikt, dus zal ik eerst alle drie uitleggen en u dan een paar voorbeelden laten zien.Een BIND(expression AS ?variable). clausule kan worden gebruikt om het resultaat van een expressie aan een variabele toe te wijzen (meestal een nieuwe variabele, maar u kunt ook een bestaande variabele overschrijven).BOUND(?variable) test of een variabele is gebonden aan een waarde (resultaat is true of false). Het is vooral handig voor variabelen die worden ingevoerd in een clausule OPTIONAL.IF(condition,thenExpression,elseExpression) evalueert naar thenExpression als condition wordt beoordeeld als true, en anders naar elseExpression. Dat wil zeggen, IF(true, \"yes\", \"no\") evalueert naar \"yes\", en IF(false, \"great\", \"terrible\") evalueert naar \"terrible\".BIND kan worden gebruikt om de resultaten van een bepaalde berekening aan een nieuwe variabele te binden. Dit kan een tussentijdse uitkomst zijn van een grotere berekening of gewoon een rechtstreeks resultaat van de query. Bijvoorbeeld om de leeftijd van mensen met de doodstraf te krijgen: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # of, in een expressie:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND kan ook worden gebruikt om gewoon constante waarden aan variabelen te binden om de leesbaarheid te vergroten. Bijvoorbeeld een query die alle vrouwelijke priesters vindt: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! kan als volgt worden geschreven: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Het deel van de query, van ?woman tot ?priest. , is nu waarschijnlijk beter leesbaar. Het blok BIND ervoor is echter nogal afleidend, dus deze techniek moet spaarzaam worden gebruikt. (In de WDQS-gebruikersinterface kunt u ook uw muis over een term zoals wd:Q123 of wdt:P123 gaan en het label en de beschrijving voor de entiteit zien, zodat ?female beter leesbaar is dan wd:Q6581072 als u die functie negeert.)IF expressies worden vaak gebruikt met conditie-expressies gemaakt met BOUND. Stel dat u een query hebt die sommige mensen laat zien, en in plaats van alleen hun label weer te geven, wilt u hun pseudonym (P742) weergeven als ze er een hebben, en het label alleen gebruiken als er geen pseudoniem bestaat. Hiervoor selecteert u het pseudoniem in een clausule OPTIONAL (het moet optioneel zijn - u wilt geen resultaten weggooien die geen pseudoniem hebben) en vervolgens BIND(IF(BOUND(… gebruiken om het pseudoniem of het label te selecteren. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Andere eigenschappen die op deze manier kunnen worden gebruikt, zijn nickname (P1449), posthumous name (P1786) en taxon common name (P1843) - alles waar een soort \"fallback\" zinvol is.U kunt ook BOUND met FILTER combineren om ervoor te zorgen dat aan ten minste één van de verschillende OPTIONAL blokken is voldaan. Laten we bijvoorbeeld alle astronauten die naar de maan zijn geweest en de leden van Apollo 13 (Q182252) (nabij genoeg, toch?). Die beperking kan niet worden uitgedrukt als een enkel eigenschapspad, dus we hebben één clausule OPTIONAL nodig voor \"lid van een maanmissie\" en een andere voor \"lid of Apollo 13\". Maar we willen alleen de resultaten hebben waar aan ten minste één van deze voorwaarden voldaan is. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE De functie COALESCE kan worden gebruikt als een afkorting van het patroon BIND(IF(BOUND(?x), ?x, ?y) AS ?z). voor fallbacks hierboven vermeld: het neemt een aantal expressies en retourneert de eerste die zonder fouten evalueert. Bijvoorbeeld de bovenstaande \"pseudoniem\" fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). kan beknopt worden geschreven als BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). en het is ook gemakkelijk om nog een terugvallabel toe te voegen voor het geval het ?writerLabel ook niet is gedefinieerd: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  Groeperen Tot nu toe waren alle queries die we hebben laten zien queries die alle items aan bepaalde voorwaarden voldoen; in sommige gevallen hebben we ook extra velden bij het item opgenomen (schilderijen met materialen, Arthur Conan Doyle boeken met titel en illustrator).Maar het is heel gebruikelijk dat we geen lange lijst van alle resultaten willen. In plaats daarvan kunnen we queries maken als deze: Hoeveel schilderijen werden op doek / populierenhout / enz. geschilderd? Wat is de hoogste bevolking van de steden van elk land? Wat is het totaal aantal geweren dat door elke fabrikant is geproduceerd? Wie publiceert gemiddeld de dikste boeken?  Bevolking van steden Laten we nu eens kijken naar de tweede query. Het is vrij eenvoudig om een query te schrijven die alle steden vermeldt met hun bevolking en land, op volgorde van het land: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (NB: deze query retourneert veel resultaten, wat problemen voor uw browser kan veroorzaken. Misschien wilt u een LIMIT-clausule toevoegen.)Omdat we de resultaten op een land orderen, vormen alle steden die tot een land behoren één aangrenzend blok in de resultaten. Om de hoogste bevolking binnen dat blok te vinden, willen we het blok beschouwen als een groep en alle individuele populatiegehalten samenvoegen in één waarde: het maximum. Dit wordt gedaan met een clausule GROUP BY onder het blok WHERE en een aggregeer functie (MAX) in de clausule SELECT. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We hebben de ORDER BY vervangen door een GROUP BY. Het effect hiervan is dat alle resultaten met hetzelfde land nu worden gegroepeerd tot één resultaat. Dit betekent dat we ook de clausule SELECT moeten wijzigen. Als we de oude clausule SELECT ?country ?city ?population zouden behouden, welke ?city en ?population zouden dan worden teruggegeven? Vergeet niet dat er veel resultaten zijn in dit ene resultaat; ze hebben allemaal hetzelfde land, dus we kunnen dat selecteren, maar omdat ze allemaal een andere stad en bevolking kunnen hebben, moeten we WDQS vertellen welke van die waarden we moeten selecteren. Dat is de taak van de geaggregeer functie. In dit geval hebben we MAX gebruikt: uit alle ?population waarden selecteren we de maximale voor het groepsresultaat. (Die waarde moeten we met de constructie AS ook een nieuwe naam geven, maar dat is maar een klein detail.)Dit is het algemene patroon voor het schrijven van groepsquery's: schrijf een normale query die de gewenste gegevens retourneert (niet gegroepeerd, met veel resultaten per \"groep\"), voeg vervolgens een GROUP BY clause toe en voeg een geaggregeerde functie toe aan alle niet-gegroepeerde variabelen met een SELECT clause. Schildersmaterialen Laten we het proberen met een andere query: Hoeveel schilderijen zijn op elk materiaal geschilderd? Schrijf eerst een query die alle schilderijen en hun schilderijmateriaal teruggeeft. Let er op dat u alleen die verklaringen met een kwalificatie gebruikt. SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Voeg vervolgens een GROUP BY clause toe aan het ?material en vervolgens een aggregaatfunctie aan de andere geselecteerde variabele (?painting). In dit geval zijn we geïnteresseerd in het aantal schilderijen; de geaggregeerde functie daarvoor is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! Een probleem hiermee is dat we het label niet hebben voor de materialen, dus de resultaten zijn een beetje ongemakkelijk te interpreteren. Als we die variabele toevoegen, krijgen we een fout: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate \"Bad aggregate\" is een foutbericht dat u waarschijnlijk veel zult zien wanneer u met groepsquery's werkt; Het betekent dat een van de geselecteerde variabelen een aggregeer functie nodig heeft, maar er geen heeft, of dat het een aggregeer functie heeft maar er geen zou moeten hebben. In dit geval denkt WDQS dat er meerdere ?materialLabel per ?material kunnen zijn (hoewel we weten dat dat niet kan gebeuren), en dus klaagt het dat u geen aggregeer functie voor die variabele opgeeft.Een oplossing is om verschillende variabelen te groeperen. Als u meerdere variabelen in de GROUP BY clausule opschrijft, is er één resultaat voor elke combinatie van die variabelen, en kunt u al die variabelen selecteren zonder de samengestelde functie. In dit geval zullen we zowel op ?material als ?materialLabel pgroeperen. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We zijn bijna klaar met de query, nog één verbetering: we willen graag eerst de meest gebruikte materialen zien. Gelukkig mogen we de nieuwe, geaggregeerde variabelen uit de SELECT-component (hier, ?count) gebruiken in een ORDER BY clausule, dus dit is heel eenvoudig: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! Als oefening doen we ook de andere queries. Wapens per fabrikant Wat is het totale aantal geweren dat door elke fabrikant wordt geproduceerd? Tip De relevante items en eigenschappen zijn firearm (Q12796), manufacturer (P176), total produced (P1092). Voorbeeld oplossing SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  Uitgevers per aantal pagina's Wat is het gemiddelde (functie: AVG) aantal pagina's van boeken per uitgever? Tip De relevante items en eigenschappen zijn publisher (P123), number of pages (P1104). Voorbeeld oplossing SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING Een kleine toevoeging bij die laatste query, als u naar de resultaten kijkt, merkt u misschien dat het hoogste resultaat een erg hoog gemiddelde heeft, meer dan tien keer dat van de tweede plaats. Een beetje onderzoek leert dat dit komt omdat die uitgever (UTET (Q4002388)) slechts één boek heeft gepubliceerd met een number of pages (P1104) verklaring, Grande dizionario della lingua italiana (Q3775610), wat de resultaten een beetje vertekent. Om dergelijke uitschieters te verwijderen, zouden we kunnen proberen alleen uitgevers te selecteren die ten minste twee boeken met number of pages (P1104) verklaringen op Wikidata hebben gepubliceerd.Hoe doen we dat? Normaal gesproken beperken we resultaten met een FILTER clausule, maar in dit geval willen we het beperken op basis van de groep (het aantal boeken), niet een individueel resultaat. Dit wordt gedaan met een HAVING clausule, die direct na een GROUP BY clausule kan worden geplaatst en een expressie neemt net zoals GROUP BY doet: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  Samenvatting van aggregatie functies Hier is een korte samenvatting van de beschikbare functies om te aggregeren: COUNT: Telt het aantal elementen. U kunt ook COUNT(*) schrijven om alle resultaten eenvoudig te tellen. SUM, AVG: de som of het gemiddelde van alle elementen respectievelijk. Als de elementen geen getallen zijn, krijgt u vreemde resultaten. MIN, MAX: de minimale of maximale waarde van alle elementen respectievelijk. Dit werkt voor alle waardetypen; getallen worden als getal gesorteerd, teksten en andere typen lexicaal. SAMPLE: elk element. Dit is soms nuttig als u weet dat er maar één resultaat is, of als het u niet uitmaakt welke resultaat u krijgt. GROUP_CONCAT: voegt alle elementen samen. Het is bijvoorbeeld handig als u slechts één resultaat voor een item wilt hebben, maar u informatie voor een eigenschap wilt bevatten die verschillende vermeldingen voor dit item kan hebben, zoals de beroepen van een persoon. De verschillende beroepen kunnen worden vergroot en samengevoegd om in de resultaten in plaats van in meerdere regels in slechts één variabele te verschijnen. Als u nieuwsgierig bent, kunt u het zoeken in de SPARQL specificatie. Bovendien kunt u een DISTINCT modifier toevoegen voor elk van deze functies om dubbele resultaten te elimineren. Als er bijvoorbeeld twee resultaten zijn, maar ze hebben allebei dezelfde waarde in ?var, dan retourneert COUNT(?var) 2, maar 2 retourneert alleen 1. U moet vaak DISTINCT gebruiken wanneer uw query hetzelfde item meerdere keren kan retourneren - dit kan bijvoorbeeld gebeuren als u DISTINCT class gebruikt en er meerdere paden zijn van ?item naar ?class : u krijgt een nieuw resultaat voor elk van die paden, ook al zijn alle waarden in het resultaat identiek. (Als u niet groepeert, kunt u deze dubbele resultaten ook verwijderen door de query te starten met SELECT DISTINCT in plaats van alleen SELECT.) wikibase:Label en aggregaties Een query als de volgende, die alle academische personen met meer dan twee landen van burgerschaps verwacht in Wikidata, laat de namen van die landen niet zien in de kolom ?citizenships: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! Om de ?citizenships te tonen, noem de ?personLabel en ?citizenshipLabel uitdrukkelijk in de wikibase:label aanroep als volgt: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Zobŏcz tyż Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Chemical elements Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations bug 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be read like a sentence (which is why it ends with a full stop), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColour yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit colour yellow.
  ?fruit taste sour.
} which reads like “?fruit has colour ‘yellow’” (not “?fruit is the colour of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you've got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it.For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.)And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above.Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a full stop, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query.Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions!Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this.Alright, let’s summarise here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a full stop. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humour me for one more hypothetical scenario…Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren?Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s).In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.)And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarise that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. full stop juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on.Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do.This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialisation) of the more general class “work of art”.To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialisation of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31).So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching.One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (As an exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.)Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorise or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths Property paths are a way to very tersely write down a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax.An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> If there are no other elements in the path, ?a something* ?b means that ?b might also just be ?a directly, with no path elements between them at all. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself.A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”.You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.)You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.) Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?)So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple.The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now).That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface?Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features.So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank).This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT.ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.)LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result.(You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.)Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses.Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Chemical elements Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577).A first attempt might look like this: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meagre! Why is that? We found over a hundred books earlier!The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results.The solution is to tell WDQS that those triples are optional: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set.Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organised than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example.FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used.For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet.Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(Sstdnmjmmnt, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”.One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples.A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones).BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause.IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\".BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.)IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense.You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator).But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.)Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.)This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable.One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata.How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations bug There is currently (February 2020) a problem with the query service when you want to use the $service service with aggregation functions. A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata and is supposed to show the names of those countries in an aggregate string: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! fails to show anything in the ?citizenships column. A workaround is to explicitely name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 维基数据查询服务（WDQS）是洞察维基数据内容的一个强大工具。本指南将教您如何使用它。另可尝试维基媒体以色列提供的交互式教程。自行编写SPARQL查询前，查阅{{Item documentation}}和其他通用SPARQL查询模板，看看所需的查询是否已有人提供。 Contents 1 开始之前 2 SPARQL基础 3 迈向第一个查询 3.1 自动完成 4 高级三元模式 5 实例和类别 5.1 属性路径 6 限定符 7 顺序（ORDER）和限制（LIMIT） 7.1 练习 7.1.1 Conan Doyle写的书 7.1.2 化学元素 7.1.3 流入密西西比河的河流 7.1.4 流入密西西比河的河流（第二课） 8 可选（OPTIONAL） 9 表达式、筛选器和绑定 9.1 数据类型 9.2 运算符 9.3 筛选器 9.4 BIND、BOUND、IF 9.5 组合（COALESCE） 10 分组 10.1 城市人口 10.2 绘画材料 10.3 按制造商划分枪支 10.4 按页数排序出版商 10.4.1 HAVING（必须） 10.5 聚合函数简述 10.6 wikibase:标签和聚合的bug 11 VALUES 12 Label in multiple languages 13 未完待续… 14 参见 开始之前 虽然这本指南看起来非常长且令人生畏，但请壮起胆来。了解SPARQL的基础知识就能让你走得更远——即便你在读完#迈向第一个查询后就停止阅读，你也能了解到许多有趣的查询。本教程的每个章节都能使你有能力写出更多强大的查询。如果你以前从未听说过维基数据、SPARQL或WDQS，下方有关于这些术语的简短解释。 维基数据是一个知识数据库。它包含了数以百万计的陈述，如“加拿大的首都是渥太华”，或“蒙娜丽莎是用油彩画在杨木上的”，或“黄金的熔点是1064.18摄氏度”。 SPARQL是一种为知识数据库制定问题（查询）的语言。有了合适的数据库，SPARQL查询可以回答诸如“音乐中最流行的音调是什么？”或“哪个角色被最多的演员所描绘？”或“血型的分布是什么？”或“今年哪些作家的作品进入了公共领域？”这样的问题。 WDQS，即维基数据查询服务，将这两者结合起来。你输入一个SPARQL查询，它针对维基数据的数据集运行，并向你显示结果。  SPARQL基础 一个简单的SPARQL查询看起来像这样： SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT从句列出您希望返回的变量（变量以问号开头），WHERE从句包含相关限制，主要以三元组的形式。维基数据（以及类似的知识数据库）中的所有信息都是以三元组的形式存储；当你运行查询时，查询服务会尝试将实际的值填入变量，从而呈现知识数据库中的三元组，并在返回的一个结果中呈现找到的每个变量组合。 三元组可以像一个句子一样阅读（这就是为什么它以句号结束），有一个主语、一个谓语和一个宾语。 SELECT ?水果
WHERE
{
  ?水果 它的颜色 黄色.
  ?水果 味道 酸.
} 这个查询的结果可能包括如“柠檬”。在维基数据中，大多数属性都是“具有”类型的属性，因此查询通常为： SELECT ?水果
WHERE
{
  ?水果 颜色 黄色.
  ?水果 味道 酸.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). 但其实这不是WDQS的一个好例子。味道是主观的，所以维基数据没有为它设置属性。现在，让我们考虑一下“父与子”的关系，这种关系通常不存在歧义。 迈向第一个查询 假设我们想列出巴洛克作曲家Johann Sebastian Bach的所有孩子。像上面的查询一样使用“伪元素”，你会怎么写这个查询？你或许会写成这样： SELECT ?孩子
WHERE
{
  #  孩子 \"他的父母\" Bach
  ?孩子 父母 Bach.
  # （注：'#'后面的所有内容都是注释，WDQS会忽略。）
} 或者这样， SELECT ?孩子
WHERE
{
  # 孩子（变量） \"他的父亲\" Bach 
  ?孩子 父亲 Bach. 
} 或者这样， SELECT ?孩子
WHERE
{
  #  Bach \"的孩子\" 孩子（变量）
  Bach 孩子 ?孩子.
} 前两个三元组要求?孩子必须有父母/父亲“巴赫”；第三个要求“巴赫”必须有孩子?child。我们现在先用第二个。那么，如何将其变为一个合适的WDQS查询呢？在维基数据中，项目和属性不是由人类可读的名称来识别的，如“父亲”（属性）或 “巴赫”（项目）。有充分的理由：“约翰·塞巴斯蒂安·巴赫”也是一位德国画家的名字，而“巴赫”也可能指的是姓氏、法国公社、水星坑等等。要找到一个项目的标识符，我们要搜索该项目，并复制结果中像是我们要找的项目的Q号（例如根据描述判断）。找到一个属性的标识符的方法相同，但要搜索“P:关键词”而不是仅仅搜索“关键词”，这样就能搜索范围限制在属性上。如此做能告诉我们，著名作曲家约翰·塞巴斯蒂安·巴赫对应的是Q1339，而指定一个项目的父亲的属性是P:P22。最后，还有一点很重要，我们要加上前缀。对简单的WDQS三元组来说，项的前缀是wd:，属性的前缀是wdt:。以上仅适用于固定的值，变量不需要前缀。综上所述，我们得到了首个正确的WDQS查询： SELECT ?孩子
WHERE
{
# ?孩子 父亲 Bach.
  ?孩子 wdt:P22 wd:Q1339.
}
 Try it! 单击“试一试”链接，然后在WDQS页面上“运行”查询。你得到想要的结果了吗？ 孩子 wd:Q57225 wd:Q76428 … 也许令你失望了？你只能看到标识符，虽然你可以单击来查看其对应的维基数据页面（包含易读的文字标签），有更好的方法显示这些结果吗？别急，我们有，只需包含下列神奇的语句 SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 到WHERE从句，你就能拿到额外的标签。对您的查询中的每个?abc变量来说，你都有一个额外的?abcLabel，其中包含?abc变量所对应的项的文字标签（label）。如果将这个加到SELECT从句，你就能得到所需的项以及项的标签： SELECT ?child ?childLabel
WHERE
{
# ?孩子  父亲   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 运行试试 - 你应该不仅看到项目的编号，还能看到各个项目的名称。 child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  自动完成 SERVICE 这段句子看上去很难记吧？编写查询时不停的搜索翻找也很烦人。还好，WDQS提供了“自动完成”解决方案。在query.wikidata.org查询编辑器中，在查询的任何位置按下Ctrl+Space（空格键）（或Alt+Enter（回车键）或Ctrl+Alt+Enter）可以获取或许合适的代码建议；用方向键上和下选择合适的建议，然后按下Enter（回车键）来选择。例如，相比每次都输入完整的SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }，您只需输入SERV，按Ctrl+Space，首个建议就是完整的这个句子，随取随用！按下Enter确认使用。（格式可能稍有变化，但无关紧要。）自动完成还可帮您搜索。如果输入一个维基数据前缀，例如wd:或wdt:，在后面输入一些内容，按Ctrl+Space将在维基数据上搜索该内容并给出建议的结果。wd:搜索项目（item），wdt:搜索属性。例如，相比找到Johann Sebastian Bach (Q1339)和father (P22)，只需输入wd:Bach和wdt:fath，然后从自动完成中选择正确的结果。这也支持有空格的文本，例如wd:Johann Sebastian Bach。 高级三元模式 现在我们看到了Johann Sebastian Bach的所有孩子，更准确的说——所有“父亲”为Johann Sebastian Bach的项目。但Bach有两任妻子，所以这些项包含不同的生母，如果我们只想看第一任妻子, Maria Barbara Bach（Q57487）所生的孩子呢？尝试基于上方的查询编写这个查询。写出来了吗？让我们来看解决方案。完成此操作的最简单方法是添加第二个三元组作为限制条件： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 它可以被理解为： 孩子（Child） 父亲 Johann Sebastian Bach. 孩子（Child） 母亲 Maria Barbara Bach. 听起来有点尴尬？在自然语言中我们会写为： 孩子的父亲是Johann Sebastian Bach，母亲是Maria Barbara Bach。 而事实上，SPARQL中也可以表达为类似的缩写形式：如果用英文的分号（;）而非句号结尾，就可以添加第二组谓词-对象。如此一来，上述查询可以缩写为： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 如此能得到相同的结果，并减少在查询中的复述。现在假设，我们只对结果中是作曲家且是钢琴家的孩子感兴趣。对应项目是occupation (P106)、composer (Q36834)和pianist (Q486748)。尝试更新上方的查询来添加这些限制。我的方案是这样： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 这里使用;缩写法超过两次，追加了两个必要条件。但正如你所见到的，仍有一些复述的地方，就好像在说： 孩子的职业是作曲家、职业是钢琴家。 而我们通常会说： 孩子的职业是作曲家和钢琴家。 巧的是，SPARQL对此也有语法应对：就像;允许你将谓词-对象追加到三元组（重用主语），英文逗号,则允许你再追加一个“对象”到三元组（重用主语和谓词）。因此，查询可以缩写为： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 注：缩进和其他空格其实不重要，只是为了可读性。因此还可以缩写为： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # 两个职业（匹配）放在同一行
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 或者更低可读性的写法： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # 不留缩进，会不容易区分,和;
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 幸运的是，WDQS编辑器能为您自动缩进，因此通常无需担心。我们总结一下。每行查询的结构类似一句话。每个主题的三元组用一个英文句号终结。同一个主题多个谓词（第二项）用英文分号分隔，同一个主题和谓词的多个对象（第三项）用英文逗号分隔。 SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} 现在我想再介绍一个SPARQL提供的缩写。让我来再假设一个场景。假设我们对Bach的孩子不感兴趣，但想了解他的“孙子”辈。注意，“孙子”可能因父亲或母亲而与Bach有关系，而这是两个不同的属性，这让事情变得复杂。让我们思维逆转，维基数据还有一个孩子（“child”）属性P:P40，是从“父母”项指向“子女”项，并且无关性别。那么，你能写一个返回Bach的孙子孙女的查询吗？我的方案是这样： SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 在自然语言中对应： Bach有一个孩子（?child），这个 孩子（?child）也有一个孩子（?grandChild）。 我们再来试试缩写这个查询。我们实际不关心中间的那个Bach的“孩子”，而只需要获取Bach的孙子/孙女。因此，我们不使用中间变量，可以将查询缩写为： Bach的孩子有一个孩子（?grandChild）。 Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). 在SPARQL中这可以写为： SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 你可以用一对方括号（[]）代替变量，形成匿名变量。在方括号内可以指定“谓词-对象”组（亦即匹配条件），形式类似一般三元组后面的;；这种情况下，隐式的“主语”是括号所表现的匿名变量。另外，与放在;后面一样，你可以添加多组“谓词-对象”，或者用逗号添加同一谓词的多个对象（亦即匹配值）。以上就是三元组模式。SPARQL还有很多内容，但因为我们即将离开与自然语言非常相似的部分，我想再次总结一下这种对应关系： 自然语言 例子 SPARQL 例子 句子 Juliet 爱 Romeo。 句号 juliet 爱 romeo. 连词（从句） Romeo 爱 Juliet 并且 杀死了 他自己。 分号 romeo 爱 juliet; 杀死了 romeo. 连词（名词） Romeo 杀死了 Tybalt 和 他自己。 逗号 romeo 杀死了 tybalt, romeo. 相对从句 Juliet 爱 杀死了 Tybalt 的人。 方括号 juliet 爱 [ 杀死了 tybalt ].  实例和类别 不久前我说，维基数据的大多数属性“有”的关系，“有”孩子、“有”父亲、“有”职业。但有时（且其实是经常），你需要说的是“是”。但这实际涉及到两种关系。 亂世佳人 是 一部电影。 一部电影 是 一件艺术作品。 Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. 这就是为什么维基数据中针对“是”（“is”）有两个属性，instance of (P31)和subclass of (P279)。亂世佳人是“电影”类别中的一个特定实例，而类别“电影”是“艺术作品”中的一个更具体的专门子类。 To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). 所以这对于编写SPARQL意味着什么？当我们想搜索“所有艺术作品”时，搜索所有直接隶属于“艺术作品”的实例项目是不够的。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # “艺术作品”的实例
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 我写这篇教程时（2016年10月），该查询只返回2,815个结果 - 显然，还有更多的艺术作品！这是因为它忽略了“乱世佳人”这种项目，它只是“电影”的一个实例，而不是“艺术作品”的实例。“电影”是“艺术作品”的一个子类，我们需要令SPARQL搜索时考虑这点。一种可能的方案是之前提过的方括号[]语法：乱世佳人是“艺术作品”的某个子类别的实例。（为了试验，尝试这种查询）。但这仍存在问题： 这不再包含直接隶属于“艺术作品”的实例项目。 仍缺少一些项目，它们是“艺术作品”的多级子类下的实例——例如，《白雪公主与七个小矮人》是一部动画电影，这是一部电影，这是一件艺术作品。此时我们需要查询两级“子类”的语句——但也可能是三级、四级或更多。 解决方案：?item wdt:P31/wdt:P279* ?class。这表示“它”符合“隶属于”，并且在项目和类别之间有任意数量的“上级分类”语句。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # 艺术作品的任何子类的实例
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! （我不建议运行该查询。WDQS可能勉强处理它，但您的浏览器可能在尝试显示结果时崩溃，因为结果非常多。）现在你应该知道如何搜索所有艺术品、所有建筑物，或者所有人类定居点：魔咒 wdt:P31/wdt:P279* 以及相应类别。这使用了一些我还没有介绍的SPARQL功能，但这几乎是这些功能的唯一相关用途，因此，您“不需要”了解它的工作原理，也能有效地使用WDQS。如果你仍然想知道，我会在稍后介绍；你也可以跳过下一章节，并只在需要用到时复制粘贴 wdt:P31/wdt:P279*。 属性路径 “属性路径”是一种非常简洁的记述两个项目（item）间的属性的路径的方法。最简单的路径只有一个属性，形成一个普通的三元组： ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. 这等同于下列任一写法： ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. 练习：用此语法重写前面的“巴赫的孙子”查询。路径后面的星号（*）意味着0个或许多个路径元素。 ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  限定符 (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier.  顺序（ORDER）和限制（LIMIT） We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values.  练习 截至目前，我们了解了很多领域，是时候做一些练习了——如果你赶时间，可以跳过此章节。 Conan Doyle写的书 Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  化学元素 Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  流入密西西比河的河流 Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  流入密西西比河的河流（第二课） Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  可选（OPTIONAL） In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty.  表达式、筛选器和绑定 This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types.  数据类型 Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime.  运算符 The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true).  筛选器 信息 For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND、BOUND、IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  组合（COALESCE） The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  分组 So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books?  城市人口 Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause.  绘画材料 Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too.  按制造商划分枪支 What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  按页数排序出版商 What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it!  HAVING（必须） A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  聚合函数简述 Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.)  wikibase:标签和聚合的bug A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS ehk Wikidata päringuteenus on võimas tööriist, mis võimaldab piiluda Wikidata telgitagustesse. See juhend õpetab päringukeskkonda kasutama. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Enne alustamist 2 SPARQL-i alused 3 Meie esimene päring 3.1 Automaatne täitmine 4 Keerulisemad kolmikud 5 Üksikjuht nähtusest ja klassid 5.1 Omaduste rajad 6 Täpsustajad 7 ORDER ja LIMIT 7.1 Harjutus 7.1.1 Arthur Conan Doyle'i raamatud 7.1.2 Keemilised elemendid 7.1.3 Jõed, mis suubuvad Mississippisse 7.1.4 Jõed, mis suubuvad Mississippisse II 8 OPTIONAL 9 Avaldised, FILTER ja BIND 9.1 Andmetüübid 9.2 Tehtemärgid 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Rühmitamine 10.1 Linnade rahvaarvud 10.2 Maalimisel kasutatud materjalid 10.3 Relvad tootja kaupa 10.4 Kirjastused lehekülgede arvu järgi 10.4.1 HAVING 10.5 Kokkuvõte agregeerivatest funktsioonidest 10.6 wikibase:Label ja agregeerimine 11 VALUES 12 Label in multiple languages 13 Ja nii edasi… 14 See also Enne alustamist See juhend võib tunduda pikk ja hirmutav, kuid ära ehmu! SPARQL-i aluste õppimine laob tugeva põhja. Isegi, kui lõpetad lugemise pärast meie esimest päringut, oskad juba piisavalt, et koostada palju põnevaid päringuid. Juhendi iga lõik võimaldab Sul kirjutada aina võimsamaid päringuid.Kui Sa ei ole kunagi kuulnud mõistetest Wikidata, SPARQL või WDQS, siis siin on lühiseletus: Wikidata on koondandmebaas. See sisaldab miljoneid sissekandeid, nagu “Kanada pealinn on Ottawa” või “Mona Lisa on maalitud paplile õlivärviga” või “kulla sulamistemperatuur on 1064,18 kraadi Celsiuse järgi”. SPARQL on keel, mille abil saab sõnastada küsimusi (päringuid) andmebaasidele. Sobivas andmebaas suudab SPARQL-i päring vastata küsimustele nagu “mis on muusikas enim levinud tonaalsus?” või “millist tegelaskuju on mänginud suurim arv näitlejaid?” või “mis on veregruppide jaotus?” või “milliste autorite tööd lisandusid sel aastal avalikku omandisse?”. WDQS (Wikidata Query Service) ehk Wikidata päringuteenus toob need kaks kokku: Sa sisestad SPARQL-i päringu, see käib läbi Wikidata andmete ning kuvab Sulle tulemuse.  SPARQL-i alused Lihtne SPARQL-i päring näeb välja selline: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT lause on nimekiri muutujatest, mida Sa tahad tagastada (muutujad algavad küsimärgiga), ja WHERE lause sisaldab nende muutujate kitsendusi, peamiselt kolmikute kujul. Wikidatas (ja sarnastes andmebaasides) hoitakse kogu infot kolmikutena. Kui Sa käivitad päringu, siis proovib päringuteenus täita muutujad päris väärtustega, et tulemusena tekkinud kolmikud ilmuksid andmebaasis. Seejärel tagastab ta ühe tulemuse iga leitud muutujate kombinatsiooni kohta. Kolmikut võib lugeda kui lauset (mistõttu ta lõppeb ka punktiga), milles on subjekt, predikaat ja objekt: SELECT ?puuvili
WHERE
{
  ?puuvili omabVärvi kollane.
  ?puuvili maitseb hapult.
} Selle päringu tulemused võiksid sisaldada näiteks sidrunit. Wikidatas on enamik omadusi \"omab\" tüüpi, seega päringut võiks lugeda hoopis selliselt: SELECT ?puuvili
WHERE
{
  ?puuvili värv kollane.
  ?puuvili maitse hapu.
} mida võib lugeda “?puuvili omab värvi kollane” (mitte “?puuvili on kollase värv” – pea seda meeles selliste omaduspaaride juures nagu “vanem”/“laps”!).See aga ei ole hea näide WDQSi jaoks. Maitse on subjektiivne, seega Wikidatas ei ole selle jaoks omadust (ingl property). Mõtleme selle asemel vanema/lapse suhetele, mis on enamasti üheti mõistetavad. Meie esimene päring Oletame, et me tahame nimekirja barokkajastu helilooja Johann Sebastian Bachi kõigist lastest. Kasutades pseudoelemente nagu ülaltoodud päringutes, kuidas Sa selle päringu kirja paneksid?Loodetavasti said midagi sellist: SELECT ?laps
WHERE
{
  #  lapsel \"on vanem\" Bach
  ?laps vanem Bach.
  # (pane tähele: kõik, mis järgneb trellidele (‘#’) on kommentaar ning WDQS ignoreerib seda.)
} või siis SELECT ?laps
WHERE
{
  # lapsel \"on vanem\" Bach 
  ?laps vanem Bach. 
} või siis SELECT ?laps
WHERE
{
  #  Bachil \"on laps\" laps
  Bach laps ?laps.
} Esimesed kaks kolmikud ütlevad, et ?laps peab omama vanemat/isa Bach; kolmas ütleb, et Bachil peab olema laps ?laps. Vaatame praegu teist varianti.Mida me peame veel tegema, et sellest korralik WDQS-i päring teha? Wikidatas ei tuvastata üksusi ja omadusi inimloetavate siltide järgi nagu \"isa\" (omadus) või \"Bach\" (üksus). (Seda põhjusega: “Johann Sebastian Bach” on ühtlasi saksa maalikunstniku nimi ja “Bach” võib tähendada hoopis perekonnanimi, Prantsuse kommuuni, Merkuuri kraatrit või muud.) Selle asemel määratakse Wikidatas üksustele ja omadustele identifikaator. Selleks, et leida kindla üksuse identifikaatorit, otsime üksust ja kopeerime Q-numbri sellelt tulemuselt, mis tundub kõige sarnasem selle üksusega, mida me otsime (otsustades näiteks kirjelduse põhjal). Omaduse identifikaatori leidmiseks teeme sama, aga otsime “otsingutermini” asemel “P:otsingutermin”, mis kitsendab tulemused omadustele. See ütleb meile, et kuulus helilooja Johann Sebastian Bach on Q1339 ja üksuse isa kirjeldamiseks kasutatav omadus on P:P22.Viimaseks peame lisama eesliited. Lihtsate WDQS-i kolmikute puhul on üksustel eesliide wd: ja omadustel wdt:. (See käib ainult fikseeritud väärtuste kohta – muutujatele ei panda eesliidet!)Pannes kokku saadud teadmised, jõuame oma esimese WDQS-i päringuni: SELECT ?laps
WHERE
{
# ?laps  isa   Bach
  ?laps wdt:P22 wd:Q1339.
}
 Try it! Kliki nupul \"Proovi järele\", siis vajuta WDQS-i lehel suurt sinist nuppu päringu jooksutamiseks. Mis tulemuse saad? laps wd:Q57225 wd:Q76428 … See on küll pettumus. Sa näed ainult identifikaatoreid. Neile klikkides jõuad vastavale Wikidata lehele (kus on ka inimkeelne silt), aga kas tulemuste kuvamiseks pole paremat viisi?On ikka! (Kas retoorilised küsimused pole mitte toredad?) Kui Sa lisad maagilise teksti SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } kuhugi WHERE lausesse, saad muutujaid juurde: Iga muutuja ?foo kohta Su päringus on nüüd ka muutuja ?fooLabel, mis sisaldab üksuse ?foo silti. Kui Sa lisad uue muutuja ka SELECT lausesse, saad tulemuseks nii üksuse kui selle sildi: SELECT ?laps ?lapsLabel
WHERE
{
# ?laps  isa   Bach
  ?laps wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Proovi seda päringut jooksutada – peaksid nägema mitte ainult üksuste numbreid, vaid ka laste nimesid. laps lapsLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Automaatne täitmine Seda SERVICE jupp tundub raske meelde jätta, eks? Ja päringut kirjutades iga kord õige identifikaatori otsimine on samuti tüütu. Õnneks pakub WDQS sellele hea lahenduse: automaatne täitmine. query.wikidata.org päringutoimetis saad vajutada Ctrl+Tühik (või Alt+Enter või Ctrl+Alt+Enter) mistahes hetkel päringut kirjutades. Seejärel ilmub ekraanile soovitus, mis koodijupp sinna võiks sobida; vali õige soovitus üles/alla nooltega ja vajuta Enter, et see kinnitada.Näiteks selle asemel, et iga kord välja kirjutada SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }, võid lihtsalt trükkida SERV, vajutada Ctrl+Tühik ning esimene soovitus ongi täielik service loits! Lihtsalt vajuta Enter, et valik kinnitada. (Lause formaat tuleb veidi teistsugune, kuid sellest pole vahet.)Automaatne täitmine võib ka Sinu eest otsida. Kui trükid mõne Wikidata eesliidetest, nagu wd: või wdt: ja seejärel lihtsalt kirjutad teksti, siis Ctrl+Tühik otsib seda teksti Wikidatast ja soovitab leitud tulemusi. wd: otsib üksusi, wdt: omadusi. Näiteks, selle asemel et üles otsida Johann Sebastian Bach (Q1339) ja father (P22) üksused, võid lihtsalt trükkida wd:Bach ja wdt:isa ja seejärel lihtsalt valida automaatsoovituste seast õige. (See töötab isegi siis, kui su tekstis on tühikud, näiteks wd:Johann Sebastian Bach.) Keerulisemad kolmikud Nüüd oleme näinud Johann Sebastian Bachi kõiki lapsi, täpsemalt kõiki üksusi, mille isa on Johann Sebastian Bach. Aga Bachi oli kaks naist, seega nendel üksustel on erinevad emad: mis siis, kui me tahame näha ainult Johann Sebastian Bachi lapsi esimese naise, Maria Barbara Bachiga (Q57487)? Proovi vastav päring koostada, toetudes ülaltehtule.Valmis? Vaatame lahendust! Lihtsaim viis seda teha on lisada teine kolmik vastava piiranguga: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339.
  ?laps wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Eesti keeles saaks seda lugeda nii: Lapsel on isa Johann Sebastian Bach. Lapsel on ema Maria Barbara Bach. Kõlab natuke veidralt, kas pole? Loomulikus keeles me lühendaksime lauset: Lapsel on isa Johann Sebastian Bach ja ema Maria Barbara Bach. Tegelikkuses on võimalik sama lühivormi ka SPARQL-is kasutada: kui kirjutad kolmiku lõppu punkti asemel semikooloni (;), saad lisada veel ühe predikaadi-objekti paari. See lubab meil päringut lühendada nii: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! millel on samad tulemused, kuid vähem kordusi päringus.Nüüd oletame, et saadud tulemustest oleme huvitatud ainult neist, kus lapsed olid samuti heliloojad ja pianistid. Vastavad omadused ja üksused on occupation (P106), composer (Q36834) ja pianist (Q486748). Proovi uuendada ülaltoodud päringut, lisades need kitsendused!Siin on minu lahendus: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! See kasutab ; lühivormi veel kaks korda, et lisada vajalikud ametid. Ometi võid endiselt märgata kordusi. Praegune päring on sama, nagu me oleksime öelnud: Lapsel on amet helilooja ja amet pianist. mida me tavaliselt lühendaksime nii: Lapsel on amet helilooja ja pianist. Ja SPARQL-il on selle jaoks samuti süntaks olemas: kui ; lubab Sul kolmikule predikaadi-objekti paari lisada (taaskasutades subjekti), siis , lubab Sul kolmikule lisada veel ühe objekti (taaskasutades nii subjekti kui ka predikaati). Selle abil saab päringut lühendada nii: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Pane tähele: taanded ja muud tühikud ei ole tegelikult olulised – need teevad päringu lihtaslt loetavamaks. Sa võid kirjutada ka nii: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # mõlemad ametid ühel real
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! või vähem loetavalt: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # ilma taaneteta on raske eristada ; ja ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Õnneks loob päringukeskkond taanded automaatselt Sinu eest, seega Sa ei pea tavaliselt nende pärast muretsema.Teeme siin väikese kokkuvõtte. Me nägime, et päringuid ehitatakse üles nagu teksti. Iga kolmik mingi subjekti kohta lõpeb punktiga. Mitut predikaati sama subjekti kohta eraldab semikoolon ning mitut objekti sama subjekti ja predikaadi kohta võib eraldada komaga. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Nüüd tahan ma tutvustada veel üht lühendit, mida SPARQL pakub. Seega, kui lubate mul kirjeldada veel üht hüpoteetilist stsenaariumit...Oletame, et me ei ole tegelikult Bachi lastest huvitatud. (Kes teab, äkki see on Sinu puhul päriselt tõsi!) Aga meid huvitavad Bachi lapselapsed. Siin on üks probleem: lapselaps võib Bachiga seotud olla kas isa või ema kaudu. Need on kaks eri omadust, mis on ebamugav. Pöörame küsimuse ümber: Wikidatas on ka omadus “laps”, P:P40, mis osutab lapselt vanemale ja on soospetsiifiline. Kas Sa suudad selle info põhjal kirjutada päringu, mis tagastab Bachi lapselapsed?Siin on minu lahendus: SELECT ?lapselaps ?lapselapsLabel
WHERE
{
  wd:Q1339 wdt:P40 ?laps.
  ?laps wdt:P40 ?lapselaps.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Loomulikus keeles ütleksime seda nii: Bachil on laps ?laps. ?laps omab last ?lapselaps. Pakun jälle, et võiksime seda eestikeelset lauset lühendada, ja seejärel tahan Sulle näidata, kuidas SPARQL sarnast lühivormi lubab. Jälgi, kuidas me ei hooli tegelikult lapsest: me kasutame seda muutujat ainult selleks, et rääkida lapselapsest. Seetõttu saaksime lauset lühendada selliselt: Bachil on keegi selline laps, kellel on laps ?lapselaps. Selle asemel, et öelda, kes Bachi laps on, ütleme lihtsalt keegi: meil pole vahet, kes ta on. Aga me saame tagantjärele talle viidata, sest me kirjutasime \"keegi selline, kellel\": see alustab relatiivlauset ja me saame selles relatiivlauses öelda asju “kellegi” kohta (näiteks et tal “on laps ?lapselaps”). Mingis mõttes on \"keegi\" eriline muutuja, mis kehtib ainult selles relatiivlauses ning millele me otseselt ei viita (me ütleme \"keegi, kes on see ja teeb seda\", mitte \"keegi, kes on see, ja keegi, kes teeb seda\" – need on kaks erinevat \"keegit\").SPARQL-is võiks selle kirja panna nii: SELECT ?lapselaps ?lapselapsLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?lapselaps ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Sa võid kasutada muutuja asemel kandilisi sulge ([]), mis käituvad nagu nimetu muutuja. Sulgude sees saad täpsustada predikaadi-objekti paare, just nagu ; järel tavalise kolmiku puhul; seekord on kaudne subjekt nimetu muutuja, mida esindavad kandilised sulud. (Märkus: täpselt nagu pärast ;, võid ka siin lisada semikoolonitega veel predikaadi-objekti paare, või samale predikaadile komade abil rohkem objekte.)Ja see on kolmikute kohta kõik! SPARQL-is on palju muud, aga kuna me hakkame lahkuma nendest osadest, mis on loomuliku keelega tugevalt analoogsed, tahaksin selle suhte veel korra kokku võtta: loomulik keel näide SPARQL näide lause Julia armastab Romeot. punkt julia armastab romeot. konjunktsioon (lause) Romeo armastab Juliat ja tapab end. semikoolon romeo armastab juliat; tapab romeo. konjunktsioon (nimisõna) Romeo tapab Tybalti ja enda. koma romeo tapab tybalti, romeo. relatiivlause Jula armastab kedagi, kes tapab Tybalti. kandilised sulud julia armastab [ tapab tybalti ].  Üksikjuht nähtusest ja klassid Mainisin varem, et enamik Wikidata omadusi on \"omama\" suhted: omab last, omab isa, omab ametit. Aga vahel (tegelikult isegi tihti) on vaja rääkida, mis miski on. Siin saab aga eristada kaht erinevat suhet: Tuulest viidud on film. Film on kunstiteos. \"Tuulest viidud\" on üks kindel film. Sellel on kindel režissöör (Victor Fleming), kestus (238 minutit), nimekiri näitlejatest (Clark Gable, Vivien Leigh, …) ja nii edasi.Film on üldine mõiste. Filmidel võivad olla režissöörid, kestused ja näitlejad, kuid mõistel \"film\" kui sellisel ei ole ühtki kindlat režissööri, kestust ega näitlejat. Ja kuigi film on kunstiteos ja kunstiteosel on tavaliselt autor, siis mõistel “film” ei ole autorit — ainult üksikjuhtudel sellest mõistest on.Selle erinevuse tõttu on Wikidatas kaks eri omadust \"on\" väljendamiseks: instance of (P31) ja subclass of (P279). Tuulest viidud on üksikjuht klassist \"film\"; klass \"film\" on alamklass (ehk täpsem klass) üldisemast klassist \"kunstiteos\".Et Sul oleks kergem vahest aru saada, võid proovida kasutada kaht erinevat tegusõna: \"on üks kindel\" ja \"on mingit tüüpi\". Kui \"on mingit tüüpi\" sobib (nt Film \"on mingit tüüpi\" kunstiteos), osutab see sellele, et Sa räägid alamklassist ning peaksid kasutama subclass of (P279). Kui \"on mingit tüüpi\" ei sobi (nt lause \"Tuulest viidud\" \"on mingit tüüpi\" film ei ole loogiline), osutab see sellele, et Sa räägid kindlast näitest ning peaksid kasutama instance of (P31).Mida see meie jaoks tähendab, kui me kirjutame SPARQL-i päringuid? Kui me tahame otsida \"kõiki kunstiteoseid\", siis ei piisa, kui me otsime üksusi, mis on üksikjuhud \"kunstiteosest\". SELECT ?töö ?tööLabel
WHERE
{
  ?töö wdt:P31 wd:Q838948. # üksikjuht kunstiteosest
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Juhendi kirjutamise hetkel annab päring ainult 17937 kunstiteost – ilmselgelt on maailmas sellest rohkem kunstiteoseid! Probleem on selles, et siin on puudu üksused nagu \"Tuulest viidud\", mis on üksikjuht \"filmist\", aga mitte \"kunstiteosest\". \"Film\" on alamklass \"kunstiteosest\", aga me peame seda SPARQL-ile teada andma. Üks võimalik lahendus oleks [] süntaks, millest rääkisime: \"Tuulest viidud\" on üksikjuht mingist “kunstiteose” alamklassist. (Koosta see päring harjutamise mõttes!) Kuid sellega on endiselt probleeme: Otsing ei sisalda enam üksusi, mis on otseselt üksikjuhud kunstiteosest. Meil on endiselt puudu üksused, mis on üksikjuhud mingist alamklassist, mis on omakorda mingi muu alamklass “kunstiteosest” – näiteks Lumivalgeke ja seitse pöialpoissi on animeeritud film, mis on film, mis on omakorda kunstiteos. Sel juhul peaksime minema kahe sammu sügavusele – aga tasemeid võib olla ka kolm, neli, viis või tegelikult mistahes arv. Lahendus: ?üksus wdt:P31/wdt:P279* ?klass. See tähendab, et on ainult üks \"üksikjuht nähtusest\" ja seejärel mistahes arv \"alamklass\" avaldusi üksusi ja klassi vahel. SELECT ?töö ?tööLabel
WHERE
{
  ?töö wdt:P31/wdt:P279* wd:Q838948. # üksikjuht kunstiteose mistahes alamklassist
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Ma ei soovita seda päringut jooksutada. WDQS ei pruugi sellega hakkama saada, sest tulemusi on nii palju.)Nüüd Sa tead, kuidas otsida kõiki kunstiteoseid või kõiki hooneid või kõiki inimasulaid: kasutades maagilist loitsu wdt:P31/wdt:P279* koos vastava klassiga. See kasutab SPARQL-i funktsioone, mida ma veel seletanud ei ole, aga ausalt-öeldes on see nende funktsioonide ainus vajalik kasutus, seega Sul ei ole vaja mõista, kuidas see töötab, et WDQS-i efektiivselt kasutada. Kui Sind huvitab, siis ma varsti seletan, aga võid ka järgmise sektsiooni vahele jätta ning meelde jätta või siit wdt:P31/wdt:P279* kopeerida-kleepida, kui seda vaja läheb. Omaduste rajad Omaduste rajad on viis lühidalt kirja panna kahe üksuse vahel olevat teekonda. Lühim teekond on üksainus omadus, mis loob tavalise kolmiku: ?item wdt:P31 ?class. Raja elemente saad lisada kaldkriipsuga (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. See on võrdväärne mõlema järgmise näitega: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Harjutus: kirjuta ümber \"Bachi lapselaste\" päring varasemast, kasutades seda süntaksit.Tärn (*) raja elemendi järel tähendab “null või enam seda elementi”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> Kui rohkem elemente rajas ei ole, siis ?miski* ?b tähendab, et ?b võib ka otseselt olla ?a, ilma, et nende vahel oleks ühtki rajaelementi. Pluss (+) on sarnane tärniga, aga tähendab “üks või enam seda elementi”. Järgnev päring leiab Bachi kõik järeltulijad: SELECT ?järeltulija ?järeltulijaLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?järeltulija.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Kui me kasutaksime siin plussi asemel tärni, näitaksid päringutulemused ka Bachi ennast.Küsimärk (?) on sarnane tärni ja plussiga, aga tähendab “null võik üks seda elementi”.Raja elemente saab kaldkriipsu asemel eraldada püstkriipsuga (|); see tähendab \"üks või teine\": rada võib kasutada kumbagi neist omadustest. (Aga mitte kombineeritult – \"üks või teine\" rada klapib alati rajaga, mille pikkus on üks.)Sa võid raja elemente grupeerida ka sulgudega (()) ja vabalt kombineerida kõiki süntaksi elemente (/|*+?). See tähendab, et veel üks viis Bachi järeltulijaid leida on: SELECT ?järeltulija ?järeltulijaLabel
WHERE
{
  ?järeltulija (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Selle asemel, et kasutada \"lapse\" omadust, et jõuda Bachist tema järeltulijateni, kasutame \"isa\" ja \"ema\" omadusi, et minna järeltulijatest Bachini. See rada võib sisaldada kahte ema ja ühte isa, või nelja isa, või isa-ema-ema-isa, või mõnd muud kombinatsiooni. (Kuigi, kuna Bach ei saa olla kellegi ema, on viimane element alati isa.) Täpsustajad (Esmalt head uudised: selles lõigus ei lisandu uut SPARQL-i süntaksit – jee! Võta kerge hingetõmme ja lõõgastu, see peaks olema käkitegu. Eks ole?)Seni oleme rääkinud ainult lihtsatest avaldustest: subjekt, omadus, objekt. Aga Wikidata avaldused on sellest võimsamad: nad saavad sisaldada ka täpsustajaid ja viiteid. Näiteks Mona Lisal (Q12418) on kolm made from material (P186) avaldust: oil paint (Q296955), põhimaterjal; poplar wood (Q291034), täpsustajaga applies to part (P518)painting support (Q861259) – see on materjal, mille peale Mona Lisa maaliti; ja wood (Q287), täpsustajatega applies to part (P518)stretcher (Q1737943) ja start time (P580) 1951 – see osa lisati maalile hiljem. Oletame, et me tahame leida kõik maalid nende pealispinnaga, see tähendab made from material (P186) avaldused koos täpsustajaga applies to part (P518)painting support (Q861259) . Kuidas me seda teeme? See on järjekordne info, mida saab esitada üheainsa kolmikuna.Vastus on: veel kolmikuid! (Rusikareegel: Wikidata lahendust peaaegu kõigele on \"rohkem üksusi\" ja vastav WDQS-i reegel on \"rohkem kolmikuid\". Viited, numbriline täpsus, väärtusted koos ühikutega, koordinaadid jpm, millest me siin ei räägi, töötavad samamoodi.) Seni oleme kasutanud oma avalduste kolmikute jaoks eesliidet wdt:, mis osutab otse avalduse objektile. Aga siis on on ka teine eesliide: p:, mis ei osuta mitte objektile, vaid \"avalduse sõlmele\". See sõlm on omakorda teiste kolmikute subjekt: eesliide ps: (\"p\" nagu property ja \"s\" nagu statement) osutab avalduse objektile, eesliide pq: (property qualifier) täpsustajatele ja prov:wasDerivedFrom osutab viite sõlmedele (mida me praegu ei vaata).See oli pikk abstraktne tekst. Siin on konkreetne näide Mona Lisast: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Me saame seda korralikult lühendada [] süntaksi abil, asendades ?avaldus muutujad: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Kas Sa suudad nende teadmiste põhjal kirjutada päringu kõigi maalide ja nende pealispindade kohta?Siin on minu lahendus: SELECT ?maal ?maalLabel ?materjal ?materjalLabel
WHERE
{
  ?maal wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materjal; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Esiteks, me piirame muutuja ?maal painting (Q3305213) või tema alamklassi üksikjuhtudeks. Seejärel eraldame materjali p:P186 avalduse sõlmest, piirates avaldusi nendega, millel on täpsustaja applies to part (P518)painting support (Q861259) . ORDER ja LIMIT Tuleme tagasi oma tavaprogrammi juurde: veel SPARQL-i funktsioone.Seni oleme vaadanud päringuid, kus oleme huvitatud kõigist tulemustest. Kuid on üsna tavapärane hoolida ainult mõnest tulemusest: nendest, mis on mingil viisil kõige ekstreemsemad – vanimad, noorimad, varaseimad, hiliseimad, suurima rahvaarvuga, madalaima sulamistemperatuuriga, enimate lastega, suurima arvu kasutatud materjalidega ja nii edasi. Siin on ühine tegur, et tulemused on kuidagi järjestatud ja me hoolime ainult mõnest esimesest tulemusest (mis on järjekorras esimesed).Seda kontrollivad kaks lauset, mis lisatakse WHERE {} blokile (pärast loogelisi sulge, mitte enne!): ORDER BY ja LIMIT.ORDER BY something järjestab tulemused millegi järgi. See miski võib olla mistahes avaldis – praegu on ainus avaldis, mida me teame, lihtne muutuja (?miski), aga vaatame hiljem ka avaldiste teisi tüüpe. Sellele avaldisele võib lisada ASC() või DESC(), et täpsustada järjekorda (ascending ehk kasvav või descending ehk kahanev). (Kui sa kumbagi ei täpsusta, siis vaikimisi kasutatakse kasvavat järjestust, seega ASC(miski) on võrdväärne kirjapildiga miski.)LIMIT arv lõikab tulemused ära pärast arv tulemust, kust arv on mistahes naturaalarv. Näiteks LIMIT 10 piirab päringut esimese kümne tulemuseni. LIMIT 1 tagastab üheainsa tulemuse.(Sa võid kasutada LIMIT ka ilma lauseta ORDER BY. Sel juhul ei järjestata tulmeusi, seega Sa ei tea, millised tulemused saad. See on täiesti okei, kui sa tead, et tulemusi on ainult teatud arv, või kui Sind huvitab lihtsalt mingi tulemus, mitte kindel tulemus. Mõlemal juhul, LIMIT lisamine võib päringut märgatavalt kiirendada, sest WDQS saab lõpetada otsimise, kui on leidnud piisavalt, et piir täita.)Harjutamise aeg! Proovi kirjutada päring, mis tagastab kümme kõike rahvarohkemat riiki. (Riik on sovereign state (Q3624078) ja rahvaarvu omadus on P:P1082.) Võid alustada sellega, et otsid riike nende rahvaarvu järgi, ja seejärel lisada ORDER BY ja LIMIT laused.Siin on minu lahendus: SELECT ?riik ?riikLabel ?rahvaarv
WHERE
{
  ?riik wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?rahvaarv.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Pane tähele, et kui me tahame suurima rahvaarvuga riike, peame järjestama kahanevas järjekorras, et esimesed tulemused oleksid suurima väärtusega. Harjutus Me oleme siiani palju õppinud – on aeg mõneks harjutuseks. (Kui Sul on kiire, võid selle sektsiooni vahele jätta.) Arthur Conan Doyle'i raamatud Kirjuta päring, mis tagastab Arthur Conan Doyle'i kõik raamatud. Vihje Asjakohased üksused ja omadused on: Arthur Conan Doyle (Q35610), author (P50). Näidislahendus SELECT ?raamat ?raamatLabel
WHERE
{
  ?raamat wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Keemilised elemendid Kirjuta päring, mis tagastab kõik keemilised elemendid koos keemiliste sümbolite ja aatomnumbritega, järjestatud aatomnumbrite järgi. Vihje Asjakohased üksused ja omadused on: chemical element (Q11344), element symbol (P246), atomic number (P1086). Näidislahendus SELECT ?element ?elementLabel ?sümbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?sümbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  Jõed, mis suubuvad Mississippisse Kirjuta päring, mis tagastab kõik jõed, mis suubuvad otse Mississipi jõkke. (Suurim väljakutse on õige omaduse leidmine...) Vihje Asjakohased üksused ja omadused on: Mississippi River (Q1497), mouth of the watercourse (P403). Näidislahendus SELECT ?jõgi ?jõgiLabel
WHERE
{
  ?jõgi wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Jõed, mis suubuvad Mississippisse II Kirjuta päring, mis tagastab kõik jõed, mis suubuvad otse või kaudselt Mississipi jõkke. Vihje See päring on peaaegu identne eelmisega. Erinevus on selles, et seekord on kolmiku asemel vaja rada. (Kui Sa jätsid lõigu radade kohta vahele, siis jäta ka see harjutus vahele.) Näidislahendus SELECT ?jõgi ?jõgiLabel
WHERE
{
  ?jõgi wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL Eelnevates harjutustes oli meil päring Arthur Conan Doyle'i kõigi raamatute kohta. SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Aga see on veidi igav. Raamatute kohta on nii palju andmeid, ometi me näitame ainult silte? Proovime kokku panna päringu, mis sisaldaks ka title (P1476), illustrator (P110), publisher (P123) ja publication date (P577).Esimene katse võib välja näha midagi sellist: SELECT ?raamat ?pealkiri ?illustreerijaLabel ?kirjastajaLabel ?avaldatud
WHERE
{
  ?raamat wdt:P50 wd:Q35610;
        wdt:P1476 ?pealkiri;
        wdt:P110 ?illustreerija;
        wdt:P123 ?kirjastus;
        wdt:P577 ?avaldatud.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Jooksuta see päring. Kirjutamise hetkel tagastab see ainult üheksa tulemust – natuke napp! Miks see nii on? Me leidsime enne üle saja raamatu!Põhjus on selles, et päringuga sobimiseks peab potentsiaalne tulemus (raamat) klappime kõigi toodud kolmikutega: sellel peab olema pealkiri, illustreerija, kirjastus ja avaldamise aeg. Kui raamatul on osa neist omadustest, kuid mitte kõik, siis see ei klapi. Praegu me aga sellist tulemust ei taha: me tahame peamiselt nimekirja raamatutest – kui leidub lisaandmeid, tahaksime neid ka näha, aga me ei taha piirata oma tulemusi nende (puudumise) tõttu.Lahendus on öelda WDQS-ile, et need kolmikud on optional ehk valikulised. SELECT ?raamat ?pealkiri ?illustreerijaLabel ?kirjastusLabel ?avaldatud
WHERE
{
  ?raamat wdt:P50 wd:Q35610.
  OPTIONAL { ?raamat wdt:P1476 ?pealkiri. }
  OPTIONAL { ?raamat wdt:P110  ?illustreerija. }
  OPTIONAL { ?raamat wdt:P123  ?kirjastus. }
  OPTIONAL { ?raamat wdt:P577  ?avaldatud. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! See annab meile muutujaid juurde (?pealkiri, ?kirjastus jne), kui vastav avaldus eksisteerib, aga kui avaldust ei ole olemas, siis tulemust ei visata minema – vastavat muutujat lihtsalt ei määrata.Märkus: siin on väga oluline kasutada eraldi OPTIONAL lauseid. Kui Sa paned kõik kolmikud ühte lausesse, nagu siin – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – paned tähele, et enamik tulemusi ei sisalda üldse lisainfot. Põhjus on selles, et optional mitme kolmikuga lause klapib ainult siis, kui iga kolmiku tingimus on rahuldatud. Teisisõnu: kui raamatul on pealkiri, illustreerija, kirjastus ja avaldamise aeg, siis optional lause klapib ja need väärtused määratakse vastavatele muutujatele. Aga kui raamatul on näiteks pealkiri, kuid ei ole illustreerijat, siis ei klapi terve optional lause ja kuigi tulemust ei visata minema, jäävad kõik kolm muutujat tühjaks. Avaldised, FILTER ja BIND See lõik võib tunduda vähem organiseeritud kui eelnevad, sest see katab üsna laia ja mitmekülgset teemat. Põhimõte on selles, et me tahaksime midagi edasi teha nende väärtustega, mida me oleme siiani lihtsalt valinud ja tagastanud. Ja avaldised on viis väljendada neid toiminguid väärtustega. Erinevaid avaldisi on palju ja nendega saab teha nii mõndagi, kuid alustame põhitõega: andmetüübid. Andmetüübid SPARQL-is on igal väärtusel mingi tüüp, mis ütleb sulle, mis liiki väärtusega on tegemist ja mida sellega pihta saab hakata. Kõige olulisemad tüübid on: üksus, näiteks Douglas Adams (Q42) üksus on wd:Q42. tõeväärtus, millel on kaks võimalikku väärtust tõene ja väär. Tõeväärtusi ei hoita avaldustes, kuid paljud avaldised tagastavad tõeväärtuse, nt 2 < 3 (tõene) või \"a\" = \"b\" (väär). sõne, tükk teksti. Sõned ümbritsetakse jutumärkidega. ühekeelne tekst, sõne koos keeletähisega. Keeletähise saab lisada sõne järele märgiga @, nt \"Douglas Adams\"@et. arvud, täisarvud (1) või kümnendarvud (1.23). kuupäevad. Kuupäevi saab kirjutada, lisades ^^xsd:dateTime (tõstutundlik – ^^xsd:datetime ei toimi!) mingile ISO 8601 kuupäevasõnele: \"2012-10-29\"^^xsd:dateTime.  Tehtemärgid On olemas tuttavad tehtemärgid: +, -, *, / liitmiseks, lahutamiseks, korrutamiseks või jagamiseks, <, >, =, <=, >= nende võrdlemiseks. Mittevõrdust ≠ saab kirjutada !=. Võrrelda saab ka teisi andmetüüpe; näiteks \"abc\" < \"abd\" on tõene (sõnavaraline võrdlus), samuti on tõene \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. Tõeväärtuste tingimusi saab ka kombineerida, kasutades && (konjunktsioon ehk \"ning\": a && b on tõene, kui nii a kui ka b on tõesed) ja || (disjunktsioon ehk \"või\": a || b on tõene, kui vähemalt üks kahest a või b on tõene). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(tingimus). on lause, mida võid sisestada oma SPARQL-i päringusse, et filtreerida tulemusi. Sulgude sisse võid panna mistahes loogilise avaldise (mis tagastab kas \"tõene\" või \"väär\"). Kasutatakse ainult neid tulemusi, kus avaldis tagastab tõene. Näiteks, et saada nimekirja kõigist 2015. aastal sündinud inimestest, võtame kõigepealt kõik inimesed koos sünniajaga – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – ja seejärel kasutame filtrit, et tagastada ainult tulemused, kus sünniaasta on 2015. Selleks on kaks viisi: YEAR funktsiooniga sünniaasta välja võtta ja testida, et see on 2015 – FILTER(YEAR(?dob) = 2015). – või kontrollida, et kuupäev on Jan. 1st (k.a), 2015 ja Jan. 1st, 2016 (v.a) vahel: FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Minu arust on esimene variant selgem, aga tuleb välja, et teine on tunduvalt kiirem, seega kasutame teist: SELECT ?inimene ?inimeneLabel ?aasta
WHERE
{
  ?inimene wdt:P31 wd:Q5;
          wdt:P569 ?sünd.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?sünd < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Veel üks FILTER võimalik kasutus on seotud siltidega. Silditeenus on väga kasulik, kui Sa tahad lihtsalt kuvada muutuja sildi. Aga kui Sa tahad sildiga midagi teha – näiteks kontrollida, kas see algab \"Mr. \" – siis see ei tööta: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! See päring leiab kõik üksikjuhud nähtusest fictional human (Q15632617) ja kontrollib, kas nende silt algab \"Mr. \" (STRSTARTS on pikemalt string starts [with] ehk \"sõne algab [millega]\"; veel on olemas STRENDS ehk \"sõne lõpeb [millega]\" ja CONTAINS ehk \"sisaldab\"). Põhjus, miks see ei tööta, on järgnev: silditeenus lisab oma muutujad päringuhindamise hilises faasis; sel hetkel, kui me proovime kasutada filtrit ?inimeneLabel peal, ei ole veel sellist muutujat loodud.Õnneks ei ole silditeenus ainus võimalus üksuse silti kätte saada. Silte hoitakse ka tavaliste kolmikutena, kasutades predikaati rdfs:label. See tähendab muidugi kõiki silte, mitte ainult ingliskeelseid; kui me tahame ainult ingliskeelseid silte, peame filtrit kasutama koos sildi keelega: FILTER(LANG(?label) = \"en\"). Funktsioon LANG tagastab ühekeelse sõne keele, ja siin me oleme valinud ainult ingliskeelsed sildid. Täielik päring on: SELECT ?inimene ?silt
WHERE
{
  ?inimene wdt:P31 wd:Q15632617;
         rdfs:label ?silt.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! Me saame sildi koos ?human rdfs:label ?label kolmikuga, kitsendame seda ingliskeelsete siltide peale ja siis kontrollime, kas see algab tiitliga \"Mr. \".FILTER lauset võib kasutada ka regulaaravaldisega. Järgnevas näites SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Kui formaadi kitsendus ID jaoks on [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! On võimalik välja filtreerida kindlaid elemente niimoodi FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Neid kolme funktsiooni kasutatakse tihti üheskoos, seega seletan esmalt kõik kolm ära ja seejärel näitan mõningaid näiteid.A BIND(avaldis AS ?muutuja). lauset saab kasutada, et avaldise tulemust määrata muutujale (tavaliselt uus muutuja, aga võid ka olemasolevaid muutujaid üle kirjutada).BOUND(?variable) kontrollib, et väärtusele on määratud mingi muutuja (tagastab tõene või väär). See on peamiselt kasulik muutujate puhul, mida kirjeldatakse OPTIONAL lauses.IF(tingimus,ifAvaldis,elseAvaldis) saab väärtuseks thenAvaldis kui tingimus saab väärtuseks tõene, ja elseAvaldis kui tingimus saab väärtuseks väär. See tähendab, et IF(true, \"jah\", \"ei\") saab väärtuseks \"jah\", ja IF(false, \"suurepärane\", \"kohutav\") saab väärtuseks \"kohutav\".BIND saab kasutada, et siduda mingi arvutuse tulemused uude muutujasse. See võib olla suurema arvutuse vahetulemus, kuid ka päringu otsene tulemus. Näiteks selleks, et saada surmanuhtluse ohvrite iga: SELECT ?inimene ?inimeneLabel ?vanus
WHERE
{
  ?inimene wdt:P31 wd:Q5;
          wdt:P569 ?sündis;
          wdt:P570 ?suri;
          wdt:P1196 wd:Q8454.
  BIND(?suri - ?sündis AS ?vanusPäevades).
  BIND(?vanusPäevades/365.2425 AS ?vanusAastates).
  BIND(FLOOR(?vanusAastates) AS ?vanus).
  # ?vanus
  #BIND(FLOOR((?suri - ?sündis)/365.2425) AS ?vanus).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND saab kasutada ka selleks, et loetavuse huvides siduda konstante muutujatesse. Näiteks, päring mis leiab kõik naissoost preestrid: SELECT ?naine ?naineLabel
WHERE
{
  ?naine wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! võib kirjutada ümber nii: SELECT ?naine ?naineLabel
WHERE
{
  BIND(wdt:P31 AS ?üksikjuhtNähtusest).
  BIND(wd:Q5 AS ?inimene).
  BIND(wdt:P21 AS ?sugu).
  BIND(wd:Q6581072 AS ?naine).
  BIND(wdt:P106 AS ?amet).
  BIND(wd:Q42603 AS ?preester).
  ?naine ?üksikjuhtNähtusest ?inimene;
         ?sugu ?naine;
         ?amet ?preester.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Tähendusrikas osa päringust, alates ?naine kuni ?preester. on nüüd ilmselt paremini loetav. Samas, suur BIND jupp selle ees on üsna häiriv, seega seda tehnikat tehnikat tuleks mõõdukalt kasutada. (WDQS kasutajaliideses saad hiirega liikuda mõistete peal nagu wd:Q123 või wdt:P123 ja näha nende silti ja kirjeldust, seega ?naine on ainult loetavam kui wd:Q6581072, kui seda funktsionaalsust ignoreerida.)IF avaldisi kasutatakse tihti koos BOUND tingimuslausetega. Näiteks, oletame et Sa tahad teha päringu, mis näitab inimesi, ja selle asemel et näidata lihtsalt nende silti, Sa tahaksid, et kuvataks inimese pseudonym (P742) juhul kui neil see olemas on, ja vastasel juhul näidataks silti. Selle jaoks saad valida varjunime OPTIONAL lauses (see peab olema valiklause – Sa ei taha visata välja tulemusi, kus varjunimi puudub) ja seejärel kasutada BIND(IF(BOUND(…, et valida kas varjunimi või silt. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Veel omadusi, mida sel viisil saab kasutada, on nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – kõik, kus mingisugune vaikimisi väärtus on loogiline.Sa võid ka kombineerida BOUND ja FILTER, et veenduda, et vähemalt üks mitmest OPTIONAL jupist on täidetud. Võtame näiteks kõik astronaudid, kes on käinud Kuul, lisaks Apollo 13 (Q182252) liikmed (peaaegu sama asi, eks ole?). Seda kitsendust ei saa väljendada üheainsa omadusteena, seega me vajame üht OPTIONAL lauset väljendamaks \"mingi kosmoselennu liige\" ja teist, et väljendada \"Apollo 13 liige\". Aga me tahame välja valida need tulemused, kus vähemalt üks neist kahest tingimusest on tõene. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?kosmoselend.
    ?kosmoselend wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?kosmoselend).
  }
  FILTER(BOUND(?kosmoselend)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE COALESCE funktsiooni saab kasutada lühendina BIND(IF(BOUND(?x), ?x, ?y) AS ?z). vaikimisi väärtustega mustrile nagu ülalpool mainitud: see võtab endasse mingi arvu avaldisi ja tagastab esimese, mis jookseb ilma tõrgeteta. Näiteks, ülaltoodud \"varjunime\" vaikimisi väärtustega päringu BIND(IF(BOUND(?varjunimi),?varjunimi,?kirjanikLabel) AS ?silt). saab kirjutada lühemalt nõnda BIND(COALESCE(?varjunimi, ?kirjanikLabel) AS ?silt). ja on kerge lisada veel üht vaikimise väärtusega silti, juhuks kui ?kirjanikLabel ei ole samuti defineeritud: BIND(COALESCE(?varjunimi, ?kirjanikLabel, \"<no label>\") AS ?silt).  Rühmitamine Seni vaadatud päringud on kõik leidnud üksusi, mis rahuldavad mingeid tingimusi; mõnel korral lisasime üksusele veel avaldusi (maalid materjalidega, Arthur Conan Doyle'i raamatud pealkirja ja illustreerijaga).Aga on väga tavaline, et me ei taha pikka nimekirja tulemustega. Selle asemel võime küsida küsimusi nagu: Kui palju maale on maalitud lõuendil / paplil / jne? Mis on suurim rahvaarv iga riigi linnade hulgast? Mis on koguarv relvi iga tootja poolt? Kes avaldab keskmiselt kõige pikemaid raamatuid?  Linnade rahvaarvud Vaatame praegu teist küsimust. On üsna lihtne kirjutada päring, mis tagastab nimekirja kõigist linnadest koos rahvaarvu ja riigiga, järjestatud riigi järgi: SELECT ?riik ?linn ?rahvaarv
WHERE
{
  ?linn wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?riik;
        wdt:P1082 ?rahvaarv.
}
ORDER BY ?riik
 Try it! (Märkus: see päring tagastab väga palju tulemusi, mis võib Su veebilehitsejale probleeme tekitada. Võib-olla peaksid lisama LIMIT lause.)Kuna me järjestame tulemusi riigi kaupa, siis ühe riigi kõik linnad moodustavad tulemustes ühe järjestikuse jupi. Et leida kõige suurem rahvaarv selles jupis, võiksime mõelda sellest kui ühest rühmast ja kokku lüüa kõik üksikud rahvaarvud ühte väärtusse: maksimumi. Seda tehakse GROUP BY lausega (WHERE bloki sees) ja kokku löömiseks kasutatakse funktsiooni (MAX) SELECT lauses. SELECT ?riik (MAX(?rahvaarv) AS ?maxRahvaarv)
WHERE
{
  ?linn wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?riik;
        wdt:P1082 ?rahvaarv.
}
GROUP BY ?riik
 Try it! Me asendasime ORDER BY lausega GROUP BY. Selle tõttu on nüüd kõik tulemused, millel on sama ?riik, rühmitatud ühteainsasse tulemisse. See tähendab, et me peame muutma ka SELECT lauset. Kui me jätaksime alles vana lause SELECT ?riik ?linn ?rahvaarv, siis millised ?linn ja ?rahvaarv meile tagastataks? Pea meeles, et iga tulemuse seas on omakorda palju tulemeid; neil kõigil on sama ?riik, seega me võime selle välja valida, aga kuna neil kõigil on erinev ?linn ja ?rahvaarv, peame ütlema WDQS-ile, milline nendest väärtustest valida. See on agregeeriva funktsiooni ülesanne. Praegusel juhul kasutame MAX: kõigist muutuja ?rahvaarv väärtustest valime seda rühma esindama maksimaalse. (Me peame sellele uuele väärtusele ka nime andma, kasutades AS vormi, aga see on pisidetail.)Üldine muster rühmapäringute kirjutamiseks on selline: kirjuta tavaline päring, mis tagastab need andmed, mida Sa tahad (rühmitamata, palju tulemusi ühe \"rühma\" kohta). Seejärel lisa GROUP BY lause ja lisa agregeeriv funktsioon kõigile rühmitamata väärtustele SELECT lauses. Maalimisel kasutatud materjalid Proovime sedasama teise küsimusega: Kui palju maale on maalitud iga materjali peale? Esmalt kirjuta päring, mis lihtsalt tagastab kõik maalid koos nende jaoks kasutatud materjaliga. (Pea meeles kasutada ainult made from material (P186) avaldusi koos applies to part (P518)painting support (Q861259) täpsustajaga.) SELECT ?materjal ?maal
WHERE
{
  ?maal wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materjal; pq:P518 wd:Q861259 ].
}
 Try it! Järgmiseks lisa ?materjal külge GROUP BY lause ja seejärel agregeeriv funktsioon teisele valitud muutujale (?painting). Praegu oleme huvitatud maalide arvust; vastav agregeeriv funktsioon on COUNT. SELECT ?materjal (COUNT(?maal) AS ?arv)
WHERE
{
  ?maal wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materjal; pq:P518 wd:Q861259 ].
}
GROUP BY ?materjal
 Try it! Sellega on üks probleem. Kuna meil ei ole materjaldie silte, siis on tulemusi veidi ebamugav tõlgendada. Kui me lihtsalt lisame sildi jaoks muutuja, tuleb viga: SELECT ?materjal ?materjalLabel (COUNT(?maal) AS ?arv)
WHERE
{
  ?maal wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materjal; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materjal
 Try it! Bad aggregate \"Bad aggregate\" on veateade, mida kohtad rühmapäringute tegemisel palju. See tähendab, et üks valitud muutujatest vajab agregeerivat funktsiooni, aga tal ei ole seda, või vastupidi: tal on agregeeriv funktsioon, kuigi ei peaks olema. Praegu arvab WDQS, et ühe ?materjali kohta võib olla mitu silti ?materialLabel (kuigi meie teame, et see ei ole võimalik), seega ta kurdab, et Sa ei täpsusta selle muutuja jaoks agregeerivat funktsiooni.Üks lahendus on rühmitada üle mitme muutuja. Kui panna GROUP BY lausesse mitu muutujat, on üks tulemus nende muutujate iga kombinatsiooni kohta ja Sa saad valida välja kõik muutujad ilma agregeeriva funktsioonita. Praegusel juhul rühmitame üle ?materjal ja ?materialLabel. SELECT ?materjal ?materjalLabel (COUNT(?maal) AS ?arv)
WHERE
{
  ?maal wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materjal; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materjal ?materjalLabel
 Try it! Oleme päringu peaaegu valmis saanud, kõigest üks täiustus: me tahaksime näha enim kasutatud materjale esimesena. Õnneks saame kasutada uusi, agregeeritud muutujaid SELECT lausest (siin, ?arv) ORDER BY lauses, seega see on väga lihtne: SELECT ?materjal ?materjalLabel (COUNT(?maal) AS ?arv)
WHERE
{
  ?maal wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materjal; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materjal ?materjalLabel
ORDER BY DESC(?arv)
 Try it! Harjutamise mõttes teeme teised päringud ka. Relvad tootja kaupa Mis on koguarv toodetud relvi iga tootja poolt? Vihje Asjakohased üksused ja omadused on: firearm (Q12796), manufacturer (P176), total produced (P1092). Näidislahendus SELECT ?tootja ?tootjaLabel (SUM(?toodetud) AS ?kokkuToodetud)
WHERE
{
  ?mudel wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?tootja;
         wdt:P1092 ?toodetud.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?tootja ?tootjaLabel
ORDER BY DESC(?toodetud)
 Try it!  Kirjastused lehekülgede arvu järgi Mis on keskmine (funktsioon: AVG) arv raamatulehekülgi kirjastuse kohta? Vihje Asjakohased üksused ja omadused on: publisher (P123), number of pages (P1104). Näidislahendus SELECT ?kirjastus ?kirjastusLabel (AVG(?lehti) AS ?keskLehti)
WHERE
{
  ?raamat wdt:P123 ?kirjastus;
        wdt:P1104 ?lehti.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?kirjastus ?kirjastusLabel
ORDER BY DESC(?keskLehti)
 Try it! HAVING Väike lisandus eelmisele päringule – tulemusi vaadates võid märgata, et kõige esimesel tulemusel on jaburalt suur keskmine, üle kümne korra suurem, kui teisel kohal. Natuke uurimistööd paljastab põhjuse: kirjastus (UTET (Q4002388)) on avaldanud ühe raamatu avaldusega number of pages (P1104), Grande dizionario della lingua italiana (Q3775610), mis kallutab natuke tulemusi. Et sellised äärmused eemaldada, võime valida ainult kirjastused, millel on Wikidatas vähemalt kaks raamatut number of pages (P1104) avaldustega.Kuidas me seda teeme? Tavaliselt kitsendame tulemusi FILTER lausega, aga praegu tahame kitsendada rühma põhjal (raamatute arv), mitte ühtki konkreetset tulemust. Seda saab teha HAVING lausega, mis kirjutatakse kohe pärast GROUP BY lauset ja mis võtab sisse samasuguse avaldise nagu FILTER: SELECT ?kirjastus ?kirjastusLabel (AVG(?lehti) AS ?keskLehti)
WHERE
{
  ?raamat wdt:P123 ?kirjastus;
        wdt:P1104 ?lehti.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?kirjastus ?kirjastusLabel
HAVING(COUNT(?raamat) > 1)
ORDER BY DESC(?keskLehti)
 Try it!  Kokkuvõte agregeerivatest funktsioonidest Siin on lühike kokkuvõte olemasolevatest agregeerivatest funktsioonidest: COUNT: elementide arv. Võid kirjutada ka COUNT(*), et lihtsalt kõik tulemused kokku lugeda. SUM, AVG: kõigi elementide summa või keskmine. Kui elemendid ei ole arvud, saad veidraid tulemusi. MIN, MAX: kõigi elementide miinimum või maksimum. See töötab kõigi andmetüüpidega; arvud sorteeritakse numbriliselt, sõned ja teised tüübid sõnavaraliselt (leksikaalselt). SAMPLE: mistahes element. See on kasulik siis, kui Sa tead, et on ainult üks tulemus, või Sul ei ole vahet, milline tulemus tagastatakse. GROUP_CONCAT: aheldab kõik elemendid. Kasulik näiteks siis, kui tahad ainult ühte tulemust üksuse kohta, aga tahad sisaldada infot omaduse kohta, millel võib olla selle üksuse juures palju avaldusi, näiteks inimese ametid. Erinevad ametid saab uuesti rühmitada ja aheldada nii, et nad ilmuksid ühesainsas muutujas mitmel tulemusrea asemel. Kui oled uudishimulik, võid vaadata SPARQL spetsifikatsiooni. Võid ka lisada DISTINCT teisendaja ükskõik millisele neist funktsioonidest, et elimineerida korduvaid tulemusi. Näiteks, kui on kaks tulemust, millel on sama ?var väärtus, siis COUNT(?var) tagastab 2, aga COUNT(DISTINCT ?var) tagastab ainult 1. DISTINCT teisendajat tuleb tihti kasutada siis, kui Su päring võib ühte üksust mitu korda tagastada – see olukord võib tekkida näiteks siis, kui kasutad ?üksus wdt:P31/wdt:P279* ?klass, ja on olemas mitu erinevat rada ?üksuselt ?klassini: Sa saad iga erineva raja kohta uue tulemuse, kuigi nende tulemuste väärtused on identsed. (Kui Sa ei rühmita, võid korduvad tulemused elimineerida ka nii, et alustad päringut SELECT DISTINCT, selmet kirjutada SELECT.) wikibase:Label ja agregeerimine Päringuteenusel on praegu üks puudus, mis ilmneb, kui tahad kasutada $service teenust koos agregeerivate funktsioonidega. Järgnev päring otsib kõiki topeltkodakondusega akadeemilisi isikuid Wikidatas ja peaks tagastama nende riikide nimed agregeeritud sõnena: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! Kuid see ei näita mitte midagi ?citizenships veerus. Üks lahendus on nimetada ?personLabel ja ?citizenshipLabel wikibase:label teenuse väljakutses niimoodi: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Վարժություն 7.1.1 Արթուր Կոնան Դոյլի գրքեր 7.1.2 Քիմիական տարրեր 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Ներկարարական նյութեր 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Տես նաև Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} կամ սա, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language օրինակ SPARQL example sentence Juliet loves Romeo. ժամանակահատված juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. ստորակետ romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. չակերտներ juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values.  Վարժություն We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.)  Արթուր Կոնան Դոյլի գրքեր Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Քիմիական տարրեր Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause.  Ներկարարական նյութեր Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Vikiveri Sorgu Servisi, Vikiveri'nin içeriği hakkında fikir sahibi olmak için güçlü bir araçtır. Bu rehber size nasıl kullanılacağını öğretecektir. Ayrıca Wikimedia İsrail tarafından oluşturulmuş etkileşimli öğreticiye bakabilirsiniz.Kendi SPARQL sorgunuzu yazmadan önce, sorgunuzun zaten daha önce {{Item documentation}} ya da diğer genel SPARQL sorgu şablonlarına dâhil edilip edilmediğine bakın. Contents 1 Başlamadan önce 2 SPARQL temelleri 3 İlk sorgumuz 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Başlamadan önce Bu rehber çok uzun ve korkutucu görünmekle birlikte lütfen bunun sizi korkutmasına izin vermeyin! Sadece SPARQL temellerini öğrenmek bile uzun vadede işinize yarayacaktır. İlk sorgumuzdan sonra okumayı bıraksanız bile birçok ilginç sorgu oluşturacak kadar konuyu zaten anlayacaksınız. Bu eğitimin her bölümü daha güçlü sorgular yazmanızı sağlayacaktır.Daha önce Vikiveri, SPARQL veya WDQS'i hiç duymadıysanız bu terimlerin kısa bir açıklaması karşınızda: Vikiveri, bir bilgi veritabanıdır. \"Kanada'nın başkenti Ottawa'dır\" ya da \"Mona Lisa kavak ağacı üzerine yağlı boyayla boyanmıştır\" veya \"altın 1.064.18 santigrat derece erime noktasına sahiptir\" gibi milyonlarca cümle içerir. SPARQL, bilgi veritabanları için sorular (sorgular) formüle etmek için kullanılan bir dildir. Doğru veritabanıyla bir SPARQL sorgusu \"müzikte en popüler tonalite nedir?\", en çok hangi oyuncu hangi karakteri canlandırdı?, \"kan gruplarının dağılımı nedir?\" veya \"hangi yazarın eserleri bu yıl yayımlandı?\" gibi sorulara cevap verebilir. WDQS, Vikiveri Sorgu Hizmeti, şu ikisini bir araya getirir: Bir SPARQL sorgusu girince bunu Vikiveri veri kümesine karşı çalıştırır ve sonucu gösterir.  SPARQL temelleri Basit bir SPARQL sorgusu şöyle görünür: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT yan tümcesi, döndürülmesini istediğiniz değişkenleri listeler (değişkenler bir soru işareti ile başlar) ve WHERE yan tümcesi, çoğunlukla üçlü formda olan kısıtlamaları içerir. Vikiveri'deki tüm bilgiler (ve benzer bilgi veritabanları) üçlü şeklinde saklanır; sorguyu çalıştırdığınızda sorgu hizmeti değişkenleri gerçek değerlerle doldurmaya çalışır, böylece elde edilen üçlüler bilgi veritabanında görünür ve bulduğu değişkenlerin her birleşimi için bir sonuca çevirir. Üçlü, bir cümle gibi (bu nedenle bir nokta ile biter) bir özne, bir yüklem ve bir nesne ile okunabilir: SELECT ?meyve
WHERE
{
  ?meyve rengi sarı.
 ?meyve tadı ekşi.
} Bu sorgu için sonuçlar arasında örneğin “limon” yer alabilir. Vikiveri'de çoğu özellik sahiplik anlamı içerir, bu nedenle sorguyu bu şekilde okuyabiliriz: SELECT ?meyve
WHERE
{
  ?meyve rengi sarı.
 ?meyve tadı ekşi.
} yüklemlerin sahiplik özelliğini bu örnekte gözlemleyebiliriz. “‘sarı’ renge sahip ?meyve ” (“sarı renkte ki ?meyve ” değil – sahiplik özelliğine hiyerarşik yapıda ki Üçlü'ler arasında dikkat edin!)Bu örnek WDQS için iyi bir örnek değildir. Tat subjektif bir yüklem olduğu için Vikiveri tat yüklemini kullanmaz. Bunun yerine hiyerarşik bir düzene sahip kaynak/alt-öğe ilişkileri tercih edilir. İlk sorgumuz Barok dönem bestekarlarından Johann Sebastian Bach'ın bütün çocuklarını listeleyelim. Yukarıda gördüğümüz Üçlü elementleriyle nasıl sorgu oluşturabilirsiniz?Umarız aşağıdakine benzer bir sorgu oluşturdunuz: SELECT ?çocuk
WHERE
{
  #  çocuk \"ebeveyne sahip\" Bach
  ?çocuk ebeveyn Bach.
  # (not: '#' karakterinden sonra yazılanlar yorum olarak algılanır ve WDQS sorgusu için kullanılmaz.)
} ya da bu, SELECT ?çocuk
WHERE
{
  # çocuk \"babasına sahip\" Bach 
  ?çocuk baba Bach. 
} ya da bu, SELECT ?çocuk
WHERE
{
  #  Bach \"çocuğa sahip\" çocuk
  Bach çocuk ?çocuk.
} ilk iki Üçlü Bach isminde ebeveyni/babası olan ?çocuk aratırken, üçüncü Üçlü ?çocuk sahibi Bach aratmaktadır. İkinci örneği kullanarak devam edelim.Peki bunları düzgün bir WDQS sorgusuna çevirmek için ne yapmalıyız? Vikiveri'de özneler ve özellikler, ”baba” (özellik) ya da ”Bach” (özne) gibi insanlar tarafından okunabilir isimler tarafından tanımlanmazlar. (Bunun iyi bir nedeni var; ”Johann Sebastian Bach” Alman ressam'a, veya ”Bach” soyadı'na, Fransız komünü'ne, Merkür krateri'ne, vb) ait olabilir. Bu yüzden Vikiveri özne ve özelliklere bir tanımlama numarası atamaktadır. Bu tanımlama numaralarını bulmak için, ara'dan özneyi bulup, (detaylarını okuyup) doğru olduğunu düşündüğünüz sonucun Q-numarasını kopyalayın. Bir özelliğin tanımlama numarasını bulmak için aynı şeyi yapabiliriz, lakin bu sefer arama kriterini ”arama kriteri” yerine “P:arama kriteri” şeklinde düzenlemeniz gerekmektedir. Bu arama sonucu bize ünlü bestekar Johann Sebastian Bach'ın tanımlama numarasının Q1339 olduğunu, ve babasını tanımlayan özelliğin tanımlama numarasının P:P22 olduğunu gösterir. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Chemical elements Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, adalah perkakas hebat yang dapat memberikan wawasan konten yang ada di Wikidata. Panduan ini akan mengajarkanmu cara menggunakannya. Lihat pula tutorial interaktif oleh Wikimedia Israel.Sebelum menulis kueri SPARQL Anda sendiri, periksa {{Item documentation}} atau templat kueri SPARQL generik lainnya dan lihat apakah kueri Anda sudah ada. Contents 1 Sebelum kita mulai 2 Dasar-dasar SPARQL 3 Kueri pertama kita 3.1 Pelengkap otomatis 4 Pola tripel lanjut 5 Instans and kelas 5.1 Jejak atribut 6 Penjelas 7 ORDER dan LIMIT 7.1 Latihan 7.1.1 Buku-buku Arthur Conan Doyle 7.1.2 Unsur-unsur Kimia 7.1.3 Sungai-sungai yang mengalir ke Mississippi 7.1.4 Sungai yang mengalir ke Mississippi II 8 OPTIONAL 9 Ekspresi, FILTER dan BIND 9.1 Tipe-tipe data 9.2 Operator-operator 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Pengelompokkan 10.1 Populasi kota 10.2 Material lukisan 10.3 Senjata berdasarkan pembuat 10.4 Penerbit berdasarkan banyaknya halaman 10.4.1 HAVING 10.5 Rangkuman fungsi agregat 10.6 Kutu wikibase:Label dan agregasi 11 VALUES 12 Label in multiple languages 13 Dan seterusnya... 14 Lihat pula Sebelum kita mulai Meskipun panduan ini tampak panjang dan menakutkan, tolong jangan terusir! Pelajari saja dasar-dasar SPARQL sembari jalan – bahkan jika kamu berhenti membaca setelah kueri pertama kita, kamu akan sudah cukup paham bagaimana merakit kueri-kueri yang menarik. Setiap bab dari tutorial ini akan memberdayakanmu untuk menulis kueri yang lebih canggih.Kalau kamu belum pernah mendengar Wikidata, SPARQL atau WDQS sebelumnya, berikut ini penjelasan singkat istilah-istilah tersebut: Wikidata adalah basisdata pengetahuan. Ia mengandung jutaan pernyataan, seperti “Ibukota Kanada adalah Ottawa”, atau “Mona Lisa dilukis dengan cat minyak pada kayu poplar”, atau “emas memiliki titik lebur 1,064.18 derajat Celsius”. SPARQL adalah bahasa untuk memformulasi pertanyaan (kueri) pada basisdata pengetahuan. Pada basisdata yang tepat, kueri SPARQL dapat menjawab pertanyaan-pertanyaan seperti “apakah tonalitas di musik yang paling populer?” atau “karakter apa yang paling banyak diperankan oleh para aktor?” atau “bagaimana distribusi golongan darah?” atau “karya penulis apa saja yang jadi domain publik tahun ini?”. WDQS, Wikidata Query Service, menyambung kedua hal tersebut: Kamu memasukkan kueri SPARQL, WDQS menjalankannya terhadap dataset Wikidata dan memberikan hasilnya kepadamu.  Dasar-dasar SPARQL Kueri SPARQL sederhana tampak seperti ini: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Klausa SELECT mendaftarkan variabel yang kamu mau dapatkan (variabel diawali tanda tanya), dan klausa WHERE mengandung batasan-batasannya, umumnya dalam bentuk kumpulan tripel. Semua informasi di Wikidata (dan basisdata pengetahuan sejenisnya) disimpan dalam bentuk kumpulan tripel; tiap kali kamu menjalankan kueri, layanan kueri mencoba mengisikan variabel-variabel dengan nilai yang sesuai dengan tripel-tripel yang ada di basisdata pengetahuan, dan mengembalikan satu hasil untuk setiap kombinasi variabel-variabel yang ditemukan. Sebuah tripel dapat dibaca seperti layaknya kalimat (itulah sebabnya diakhiri tanda titik) yang terdiri dari \"subjek\", \"predikat\", dan \"objek\". SELECT ?buah
WHERE
{
  ?buah berwarna kuning.
  ?buah berasa asam.
} Hasil dari kueri ini dapat mencakup, misalnya \"jeruk nipis\". Di Wikidata, kebanyakan atribut adalah atribut \"ber-\" sehingga kueri juga dapat dibaca: SELECT ?buah
WHERE
{
  ?buah warna kuning.
  ?buah warna asam.
} yang dibaca sebagai “?buah ber warna ‘kuning’” (bukan “?buah adalah warna ‘kuning’” – ingatlah bahwa pasangan atribut seperti “orangtua”/“anak”!).Bagaimanapun, itu bukan contoh yang baik untuk WDQS. Rasa adalah hal yang subjektif sehingga Wikidata tidak memiliki atribut seperti itu. Lebih baik kita bayangkan tentang relasi orangtua/anak yang umumnya tidak rancu. Kueri pertama kita Andaikan kita ingin mendaftarkan semua anak dari komponis baroque Johann Sebastian Bach. Dengan menggunakan pseudo-elemen seperti kueri-kueri di atas, bagaimana kamu akan menuliskan kueri?Semoga kamu mendapatkan yang seperti berikut: SELECT ?anak
WHERE
{
  #  anak \"punya orang tua\" Bach
  ?anak orangtua Bach.
  # (cat: semua yang muncul setelah tanda '#' adalah komentar yang diabaikan oleh WDQS.)
} atau ini, SELECT ?anak
WHERE
{
  # anak \"punya bapak\" Bach 
  ?anak bapak Bach. 
} atau ini, SELECT ?anak
WHERE
{
  #  Bach \"punya anak\" anak
  Bach anak ?anak.
} Kedua tripel pertama mengatakan bahwa ?anak harus memiliki orangtua/bapak Bach; yang ketiga mengatakan bahwa Bach harus memiliki anak ?anak. Mari kita pakai yang kedua untuk saat ini.Sekarang tinggal bagaimana mengubah hal-hal tersebut menjadi kueri WDQS yang layak. di Wikidata, butir dan atribut tidak diidentifikasi dengan nama yang mudah dibaca seperti \"bapak\" (atribut) atau \"Bach\" (butir). (\"Johann Sebastian Bach\" juga adalah nama untuk Pelukis Jerman, dan \"Bach\" mungkin juga merujuk ke nama marga, komune di Perancis, kawah di Merkurius, dst.) sebagai gantinya, butir dan atribut Wikidata diberi penanda unik. Untuk mencari penanda suatu butir, kita cari butir tersebut dan salin Q-angka dari hasil yang paling pas dengan yang kita cari (misalnya, berdasarkan pemerian). Untuk mencari penanda atribut, kita lakukan yang sama. hanya saja pencariannya menggunakan \"P:istilah pencarian\" dan bukan sekadar \"istilah pencarian\" sehingga pencariannya dibatasi hanya pada atribut saja. Dari sini kita tahu bahwa komponis terkenal Johann Sebastian Bach adalah Q1339, dan atribut yang menentukan bapak dari butir adalah P:P22.Akhirnya, kita perlu menambahkan prefiks. untuk tripel-tripel WDQS sederhana, butir-butirnya perlu diawali wd: dan wdt: untuk atribut. (ini hanya berlaku untuk nilai yang sudah tetap – variabel tidak membutuhkan prefix!)Menggabungkan itu semua, sampailah kita pada kueri WDQS kita pertama yang layak: SELECT ?anak
WHERE
{
# ?anak bapak Bach.
  ?anak wdt:P22 wd:Q1339.
}
 Try it! klik tautan \"Cobalah\" dan \"Jalankan\" kueri di halaman WDQS. Apa yang kamu dapatkan? ?anak wd:Q57225 wd:Q76428 … Tampak tidak menarik. Kamu hanya melihat penanda-penanda. Kamu bisa klik pada penanda tersebut untuk melihat halaman Wikidatanya (termasuk label yang berterbaca manusia), tapi bukankah ada cara yang lebih baik untuk melihat hasilnya?Ternyata ada! (pertanyaan retoris itu keren, kan?) kalau kamu tambahkan teks ajaib berikut SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } di beberapa tempat dalam klausa WHERE, kamu bisa menemukan variabel tambahan: untuk setiap variabel ?anu di kuerimu, kamu juga bisa menggunakan variabel ?anuLabel yang mengandung label dari butir dibalik ?anu. Kalau kamu tambahkan ini ke klausa SELECT, kamu akan mendapatkan tidak hanya butir tetapi juga labelnya: SELECT ?anak ?anakLabel
WHERE
{
# ?anak bapak Bach.
  ?anak wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Coba jalankan kueri tersebut – kamu semestinya dapat melihat tidak hanya nomor butir, tetapi juga nama dari anak-anak. anak anakLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Pelengkap otomatis potongan SERVICE tampak sulit diingat? menggunakan fungsi pencarian tiap kali menulis kueri juga agak membosankan. Untungnya, WDQS menawarkan solusi untuk ini: \"Pelengkap otomatis\". di penyunting kueri query.wikidata.org, kamu bisa menekan kombinasi tombol Ctrl+Spasi dimanapun pada kueri dan kode yang pas akan disarankan; pilih saran yang paling pas dengan tombol panah atas/bawah, dan tekan Enter untuk memilihnya.Sebagai contoh, alih-alih selalu menulis SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }, kamu cukup mengetik SERV, tekan Ctrl+Spasi, dan saran pertama adalah rapalan layanan yang lengkap dan siap digunakan! Cukup tekan Enter untuk memakainya. (pemformatannya mungkin berbeda tapi itu lain soal.)Pelengkap otomatis juga bisa mencarikan untukmu. Jika kamu ketikkan salah satu prefiks Wikidata seperti wd: atau wdt: dan tulis teks setelahnya, Ctrl+Spasi akan mencari teks tersebut pada Wikidata dan menyarankan hasilnya. wd: mencari butir sedangkan wdt: untuk atribut. Sebagai contoh, alih-alih mencari butir untuk Johann Sebastian Bach (Q1339) dan father (P22), kamu cukup mengetikkan wd:Bach dan wdt:bapak kemudian pilih saran yang paling pas dari pelengkap. (Hal ini juga berlaku pada teks yang mengandung spasi seperti wd:Johann Sebastian Bach.) Pola tripel lanjut Jadi kita sudah lihat semua anak-anak dari Johann Sebastian Bach – lebih tepatnya: semua butir yang memiliki bapak Johann Sebastian Bach. tetapi Bach punya dua istri, dan butir-butir tersebut punya dua ibu yang berbeda: Bagaimana jika kita hanya ingin melihat anak-anak Johan Sebastian Bach dari istri pertama, Maria Barbara Bach (Q57487)? Coba tulis kueri tersebut berdasarkan kueri sebelumnya di atas.Sudah? Oke, sekarang langsung ke solusi! solusi paling sederhana adalah dengan menambahkan tripel kedua dengan pembatas tersebut: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339.
  ?anak wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! dalam Bahasa Indonesia, ini dibaca: Anak memiliki bapak Johann Sebastian Bach. Anak memiliki ibu Maria Barbara Bach. terdengar aneh? dalam bahasa sehari-hari kita bisa menyingkat ini menjadi: Anak memiliki bapak Johann Sebastian bach dan ibu Maria Barbara Bach. Bahkan, penyingkatan ini juga mungkin diekspresikan dalam SPARQL juga: jikan kamu menakhiri suatu tripel dengan titik koma (;) dan bukannya tanda titik, kamu bisa menambahkan pasangan predikat-objek. Dengan demikian kueri kita bisa juga disingkat menjadi: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! yang mengembalikan hasil yang sama tetapi dengan lebih sedikit pengulangan pada kueri.Sekarang coba bayangkan, dari hasil-hasil tersebut, kita hanya tertarik pada anak-anak yang juga merupakan komponis dan pianis. Atribut dan butir yang relevan untuk hal ini adalah occupation (P106), composer (Q36834) dan pianist (Q486748). Coba perbarui kueri di atas dengan menambahkan pembatasan tersebut!Berikut ini solusi saya: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Tanda ; digunakan dua kali lebih banyak untuk menambahkan kedua pekerjaan yang diperlukan. Seperti yang mungkin kamu perhatikan, masih ada beberapa pengulangan seperti jika kita mengatakan: Anak memiliki pekerjaan komponis dan pekerjaan pianis. yang mungkin kita bisa singkat sebagai: Anak memiliki pekerjaan komponis dan pianis. dan SPARQL memiliki sintaks untuk itu juga: sama seperti ; bisa digunakan untuk menambahkan pasangan atribut-objek pada suatu tripel (menggunakan subjek yang sama), tanda , bisa digunakan untuk menambahkan objek pada tripel (mengulang penggunaan kedua subjek dan predikat). Dengan demikian, kuerinya dapat disingkat menjadi: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Catatan: indentasi dan spasi tidak berpengaruh – Saya hanya mengindentasi kueri supaya lebih mudah dibaca. Kamu juga bisa menulis ini sebagai: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # kedua pekerjaan dalam satu baris
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! atau, agak tidak terlalu mudah dibaca: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # tanpa adanya indentasi, membedakan antara ; dan , menjadi lebih sulit
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Untungnya, penyunting WDQS mengindentasi tiap baris secara otomatis sehingga kamu tidak perlu khawatir tentang hal ini.Baiklah, mari kita coba rangkum sampai di sini. Kita telah melihat kueri yang terstruktur seperti teks. Setiap tripel tentang suatu subjek diakhiri oleh titik. Beberapa predikat tentang subjek yang sama dipisahkan titik koma, dan beberapa objek pada subjek dan predikat yang sama dapat didaftarkan dengan dipisah oleh koma. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Sekarang Saya mau memperkenalkan satu lagi singkatan yang ditawarkan SPARQL. Jadi kalau kamu mau mendengarkan skenario khayalan satu lagi...Misalkan kita tidak tertarik dengan anak-anaknya Bach (Siapa tahu, mungkin kamu sebetulnya berpikir demikian) tetapi kita tertarik pada cucu-cucunya (misalkan). Ada satu permasalahan di sini: cucu dari Bach yang lewat jalur ibu atau bapak? keduanya atribut yang berbeda sehingga jadi agak menjengkelkan. Sebagai gantinya, mari kita putar saja relasinya: Wikidata juga punya atribut \"anak\" P:P40 yang menunjuk dari orangtua ke anak dan juga bebas gender. Dengan informasi ini, bisakah kamu menulis kueri yang mengembalikan cucu-cucu dari Bach?Berikut ini solusi saya: SELECT ?cucu ?cucuLabel
WHERE
{
  wd:Q1339 wdt:P40 ?anak.
  ?anak wdt:P40 ?cucu.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! dalam bahasa manusia, ini dibaca: Bach memiliki anak ?anak. ?anak memiliki anak ?cucu. Sekali lagi, Saya sarankan agar kita menyingkan kalimat ini. Kemudian Saya akan perlihatkan bagaimana SPARQL mendukung penyingkatan serupa. Perhatikan bagaimana kita sebetulnya tidak terlalu peduli tentang anaknya: kita tidak perlu menggunakan variabel kecuali untuk membahas tentang cucu sehingga kita dapat menyingkat kalimatnya menjadi: Bach memiliki anak seseorang yang memiliki anak ?cucu. Alih-alih mengatakan siapa anaknya Bach, kita cukup sebut dengan \"seseorang\": kita tidak peduli siapa dia tapi kita bisa menrujuk balik ke mereka karena kita mengatakan \"seseorang yang\": bagian ini memulai klausa relatif dan dalam klausa relatif kita bisa mengatakan hal-hal tentang \"seseorang\" (mis. apakah dia \"memiliki anak ?cucu\"). Dengan kata lain, \"seseorang\" adalah variabel khusus yang hanya valid dalam klausa relatif ini dan kita tidak perlu secara eksplisit merujuk padanya (kita katakan \"seseorang yang begini dan melakukan itu\" dan bukan \"seseorang yang begini dan seseorang yang melakukan itu\", itu bisa jadi dua \"seseorang\" yang berbeda).dalam SPARQL, hal ini dapat dituliskan sebagai: SELECT ?cucu ?cucuLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?cucu ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Kamu bisa menggunakan pasangan kurung siku ([]) sebagai variabel yang berperan sebagai variabel anonim. Di dalam kurung, kamu bisa menambahkan pasangan predikat-objek, sama seperti ketika setelah tanda ; setelah suatu tripel biasa; subjek implisit dalam hal ini adalah variabel anonim yang direpresentasikan oleh kurung. (Catatan: seperti juga setelah tanda ;, kamu dapat menambahkan lebih banyak pasangan predikat-objek dengan titik koma, atau objek-objek lainnya untuk predikat yang sama dengan koma.)Begitulah pola tripel! tentunya masih ada hal lainnya tentang SPARQL. tetapi sambil kita kesampingkan dulu hal tersebut, saya mau membuat rangkuman sekali lagi: bahasa manusia contoh SPARQL contoh kalimat Juliet mencintai Romeo. titik juliet mencintai romeo. konjungsi (klausa) Romeo mencintai Juliet dan membunuh dirinya. titik-koma romeo mencintai juliet; membunuh romeo. konjungsi (nomina) Romeo membunuh Tybalt dan dirinya. koma romeo membunuh tybalt, romeo. klausa relatif Juliet mencintai seseorang yang membunuh Tybalt. tanda kurung juliet mencintai [ membunuh tybalt ].  Instans and kelas Sebelumnya, Saya sebutkan bahwa kebanyakan atribut Wikidata adalah relasi \"ber-\" atau \"punya\": \"punya\" anak, \"punya\" bapak, \"punya\" pekerjaan. Kadang kala (bahkan mungkin sering) kamu juga perlu mengatakan bahwa sesuatu \"adalah\" namun kenyataannya ada dua jenis relasi untuk hal tersebut: Gone with the Wind adalah film. Film adalah karya seni. Gone with the Wind adalah suatu film. Ia memiliki suatu sutradara (Victor Fleming), memiliki durasi tertentu (238 menit), daftar pemeran (Clark Gable, Vivien Leigh, …), dan seterusnya.\"Film\" adalah konsep yang umum. Film bisa punya sutradara, durasi, dan daftar pemeran, namun konsep \"film\" tidak mesti punya sutradara, durasi, atau daftar pemeran tertentu. Walaupun suatu film \"adalah\" karya seni dan karya seni biasanya punya pencipta, konsep \"film\" itu sendiri tidak punya pencipta – hanya \"instans\" dari konsep ini yang punya.Perbedaan inilah kenapa ada dua atribut untuk \"adalah\" di Wikidata instance of (P31) dan subclass of (P279). \"Gone with the Wind\" adalah instans tertentu dari suatu kelas \"film\"; kelas \"film\" adalah subkelas (kelas yang lebih spesifik; spesialisasi) dari kelas yang lebih umum yaitu \"karya seni\".Untuk membantumu memahami bedanya, kamu bisa coba menggunakan dua predikat yang berbeda: \"adalah suatu\" dan \"adalah jenis dari\". Jika sesuatu \"adalah jenis dari\" karya (mis. film \"adalah jenis dari\" karya seni), itu menunjukkan bahwa kamu sedang membahas subkelas, spesialisasi atau pengkhususan dari kelas yang lebih luas dan kamu seharusnya menggunakan subclass of (P279). Jika sesuatu bukan \"adalah jenis dari\" karya (mis. kalimat \"Gone with the wind \"adalah jenis dari\" film\" kurang masuk akal), itu menunnjukkan bahwa kamu sedang membahas instans tertentu dan kamu semestinya menggunakan instance of (P31).jadi apa artinya ini buat kita ketika kita sedang menulis kueri SPARQL? Ketika kita mau mencari \"semua karya seni\", tidak cukup hanya mencari semua butir yang merupakan instans langsung dari \"karya seni\": SELECT ?karya ?karyaLabel
WHERE
{
  ?karya wdt:P31 wd:Q838948. # instans dari karya seni
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Ketika tulisan ini ditulis (Oktober 2016), kueri tersebut hanya mengembalikan 2815 hasil – padahal, ada jauh lebih banyak karya seni daripada itu! Persoalannya adalah kueri ini melewatkan butir-butir seperti \"Gone with the Wind\", yang hanya merupakan instans dari \"film\", bukan \"karya seni\". \"film\" adalah subkelas dari \"karya seni\" namun kita perlu memberitahukan kepada SPARQL tentang hal ini ketika melakukan pencarian.Salah satu solusi yang mungkin untuk hal ini adalah menggunakan sintaks [] yang sudah kita bahas sebelumya: \"Gone with the Wind\" adalah instans dari \"suatu\" subkelas dari \"karya seni\". (Sebagai latihan, coba tuliskan kueri tersebut!) Namun masih ada beberapa masalah: Kita tidak lagi mencantumkan butir-butir yang merupakan instans langsung dari karya seni. Kita masih melewatkan butir-butir yang merupakan instans dari beberapa subkelas dari subkelas karya seni yang lain – sebagai contoh, \"Snow White and the Seven Dwarfs\" adalah film animasi, yang juga adalah film, yang juga adalah karya seni. Dalam hal ini, kita perlu menelusuri dua pernyataan \"subkelas dari\" – bisa juga tiga, empat, lima, berapapun. Solusinya: ?butir wdt:P31/wdt:P279* ?kelas. Ini artinya ada sesuatu yang \"adalah\" dan ada berapapun pernyataan \"subkelas dari\" di antara butir dan kelas tersebut. SELECT ?karya ?karyaLabel
WHERE
{
  ?karya wdt:P31/wdt:P279* wd:Q838948. # instans dari subkelas karya seni manapun
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Saya tidak menyarankan menjalankan kueri tersebut. WDQS mungkin saja (hampir) bisa menanganinya tetapi perambanmu mungkin akan membeku ketika mencoba menampilkan seluruh hasil saking banyaknya.)Sekarang kamu tahu caranya mencari semua karya seni, atau semua bangunan, atau semua permukiman manusia: mantra ajaibnya wdt:P31/wdt:P279* diikuti kelas yang sesuai. Hal ini menggunakan beberapa fitur SPARQL yang belum saya jelaskan tetapi sejujurnya ini merupakan hampir satu-satunya penggunaan fitur-fitur tersebut yang relevan. jadi, kamu tidak \"perlu\" memahami cara kerjanya sekarang untuk menggunakan WDQS secara efektif. Jika kamu ingin tahu, Saya akan jelaskan sedikit, tapi kamu juga bisa melewatkan bab berikut dan mengingat atau salin+tempel wdt:P31/wdt:P279* dari sini ketika kamu membutuhkannya. Jejak atribut Jejak atribut adalah cara singkat untuk menulis jejak atribut antara dua butir. Jejak paling sederhana adalah satu atribut yang membentuk tripel biasa: ?item wdt:P31 ?class. Kamu bisa menambahkan elemen jejak dengan tanda garis miring (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Ini ekuivalen dengan salah satu diantara: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Latihan: tulis ulang kueri \"cucu Bach\" sebelumnya menggunakan sintaks ini.Tanda bintang (*) setelah elemen jejak berarti “nol or lebih elemen ini”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> Jika tidak ada elemen lagi di dalam jejak, ?a sesuatu* ?b berarti ?b mungkin saja merupakan ?a tanpa ada elemen jejak diantaranya sama sekali. Tanda tambah (+) mirip dengan tanda bintang namun berarti “satu atau lebih elemen ini”. Kueri berikut menemukan semua keturunan Bach: SELECT ?keturunan ?keturunanLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?keturunan.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Jika kita gunakan tanda bintang sebagai pengganti tanda tambah di sini, hasil kueri juga akan mencantumkan Bach.Tanda tanya (?) juga mirip dengan tanda bintang atau tanda tambah, tetapi artinya adalah “nol atau satu dari elemen ini”.Kamu bisa memisahkan elemen-elemen jejak dengan tanda vertikal (|) alih-alih menggunakan garis miring; ini artinya \"salah-satu\": jejaknya bisa jadi adalah salah satu dari atribut tersebut. (Tapi bukan keduanya – segmen jejak salah-satu selalu mencocokkan jejak berpanjang satu.)Kamu juga bisa mengelompokkan elemen jejak dengan menggunakan tanda kurung (()) dan bebas mengombinasikan elemen-elemen sintaks (code>/|*+?). Ini artinya ada cara lain untuk menemukan semua keturunan Bach, yaitu: SELECT ?keturunan ?keturunanLabel
WHERE
{
  ?keturunan (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Alih-alih menggunakan atribut anak untuk menelusuri dari Bach ke keturunannya, kita menggunakan atribut bapak dan ibu untuk menelusuri dari para keturunan ke Bach. Jejaknya mungkin memasukkan dua ibu dan satu bapak, atau empat bapat, atau bapak-ibu-ibu-bapak, atau kombinasi lainnya. (Walaupun tentunya Bach tidak mungkin adalah ibu dari seseorang sehingga elemen terakhir pasti adalah Bapak.) Penjelas (Kabar baik dulu: bab ini tidak memperkenalkan sintaks tambahan untuk SPARQL – yey! Tarik nafas dalam-dalam dan santailah, mestinya ini mudah, kan?)Sejauh ini, kita hanya membahas pernyataan-pernyataan sederhana: subjek, atribut, objek. Namun pernyataan Wikidata sebetulnya lebih daripada itu: penjelas dan rujukan juga termasuk di dalamnya. Sebagai contoh, Mona Lisa (Q12418) punya tiga pernyataan made from material (P186): oil paint (Q296955), material utama; poplar wood (Q291034), dengan penjelas applies to part (P518)painting support (Q861259) – ini adalah material Mona Lisa yang dilukiskan pada mulanya; dan wood (Q287), dengan penjelas applies to part (P518)stretcher (Q1737943) dan start time (P580) 1951 – ini adalah bagian yang ditambahkan pada lukisan kemudian. Anggap kita mau mencari semua lukisan dengan permukaan lukisannya, yakni, pernyataan made from material (P186) dengan penjelas applies to part (P518)painting support (Q861259) . Bagaimana kita melakukannya? Ada lebih banyak informasi yang bisa direpresentasikan dalam satu tripel.Jawabannya adalah: lebih banyak tripel! (solusi Wikidata untuk hampir semuanya adalah \"lebih banyak butir\" dan kaidah WDQS yang bersesuaian adalah \"lebih banyak tripel\". Rujukan, keakuratan numerik, angka dengan satuan, koordinat geografis, dll. semua yang kita lewatkan di sini juga dimodelkan dengan cara ini). Sejauh ini, kita telah menggunakan prefiks wdt: untuk tripel pernyataan yang menunjuk langsung ke objek peryataan tersebut. Namun ada juga prefiks p: yang menunjuk tidak ke objek tapi ke simpul pernyataan. Simpul ini kemudian adalah subjek dari tripel-tripel lainnya: prefiks ps: (dalam bahasa inggris, singkatan ps merujuk ke property statement atau pernyataan atribut) menunjuk ke objek pernyataan, prefiks pq: (dalam bahasa inggris, pq merujuk ke property qualifier atau penjelas atribut) ke penjelas, dan prov:wasDerivedFrom menunjuk ke simpul rujukan (yang akan kita abaikan untuk saat ini).Ada banyak sekali teks abstrak. Berikut contoh konkret untuk Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Kita bisa menyingkat banyak dari ini dengan sintaks [] menggantikan variabel ?statement: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Bisakah kamu menggunakan pengetahuan ini untuk menulis kueri semua lukisan dengan permukaan lukisannya?Berikut ini solusi saya: SELECT ?lukisan ?lukisanLabel ?material ?materialLabel
WHERE
{
  ?lukisan wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Pertama, kita batasi ?lukisan ke semua instans dari painting (Q3305213) atau subkelasnya. kemudian, kita ekstrak material dari simpul pernyataan p:P186 sehingga membatasi ke pernyataan yang mempunyai penjelas applies to part (P518)painting support (Q861259) . ORDER dan LIMIT Kita kembali ke agenda program reguler fitur-fitur SPARQL lainnya.Sejauh ini, kita telah temukan kueri-kueri yang kita tertarik untuk semua hasilnya. Namun tidak jarang juga kita hanya ingin tahu beberapa hasilnya saja; hal-hal yang sifatnya superlatif – tertua, termuda, termula, terbaru, populasi terbanyak, titik lebur terendah, anak terbanyak, material yang paling sering digunakan, dst. Faktor yang menyatukan itu semua adalah hasilnya diurutkan dan kita hanya perlu beberapa hasil terawal (urutan-urutan awal).Hal ini dikendalikan dengan dua klausa yang ditambahkan setelah blok WHERE {} (setelah kurung kurawal, bukan di dalamnya!): ORDER BY dan LIMIT.ORDER BY sesuatu mengurutkan hasil berdasarkan sesuatu. sesuatu dapat berupa ekspresi apapun – untuk saat ini, satu-satunya ekspresi yang kita tahu adalah satu variabel sederhana (?sesuatu), tapi kita akan lihat jenis lainnya nanti. Ekspresi ini juga dapat dikemas dalam ASC() atau DESC() untuk menspesifikasi jenis urutan (asc untuk urut menaik atau desc untuk urut menurun). (Jika kamu tidak menspesifikasikannya maka yang akan digunakan adalah urut menaik sehingga ASC(sesuatu) ekuivalen dengan sesuatu.)LIMIT sekian memotong daftar hasil menjadi hanya sekian hasil dengan sekian adalah bilangan asli. Sebagai contoh, LIMIT 10 membatasi hasil kueri menjadi hanya maksimal sepuluh butir. LIMIT 1 hanya mengembalikan satu hasil (bila ada).(Kamu juga bisa menggunakan LIMIT tanpa ORDER BY. Pada kasus ini, hasilnya menjadi tidak diurutkan jadi kamu tidak punya jaminan hasil mana yang akan kamu dapatkan. Hal ini bisa jadi tidak masalah jika kamu tahu bahwa hanya ada sejumlah hasil atau kamu hanya tertarik dengan beberapa hasil saja tanpa peduli dengan hasil yang mana. Apapun kasusnya, menambahkan LIMIT dapat mempercepat kueri karena WDQS dapat berhenti mencari sesegera mungkin jika hasil yang didapat sudah memenuhi batas.)Waktunya latihan! Coba tuliskan kueri yang mengembalikan sepuluh negara dengan populasi terbanyak. (Negara adalah sovereign state (Q3624078), dan atribut untuk populasi adalah P:P1082.) Kamu bisa memulai dengan mencari negara dan populasinya lalu menambahkan klausa ORDER BY dan LIMIT.Berikut ini solusi saya: SELECT ?negara ?negaraLabel ?populasi
WHERE
{
  ?negara wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?populasi.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Perhatikan bahwa jika kita ingin negara dengan populasi \"terbanyak\", kita perlu mengurutkan berdasarkan populasi yang \"mengecil\" sehingga hasil teratas akan berisi nilai yang paling besar. Latihan Kita telah meliputi cukup banyak dasar sejauh ini – Saya pikir ini waktunya untuk latihan lagi. (Kamu bisa melewati bab ini jika kamu sedang terburu-buru.) Buku-buku Arthur Conan Doyle Tuliskan kueri yang mengembalikan semua buku oleh Sir Arthur Conan Doyle. Petunjuk Butir dan atribut yang relevan adalah: Arthur Conan Doyle (Q35610), author (P50). Contoh solusi SELECT ?buku ?bukuLabel
WHERE
{
  ?buku wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Unsur-unsur Kimia Tulislah kueri yang mengembalikan semua unsur-unsur kimia dengan simbol dan nomor atomnya berurut berdasrkan nomor atom. Petunjuk Butir dan atribut yang relevan adalah: chemical element (Q11344), element symbol (P246), atomic number (P1086). Contoh solusi SELECT ?unsur ?unsurLabel ?simbol ?nomor
WHERE
{
  ?unsur wdt:P31 wd:Q11344;
           wdt:P246 ?simbol;
           wdt:P1086 ?nomor.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?nomor
 Try it!  Sungai-sungai yang mengalir ke Mississippi Tulislah kueri yang mengembalikan semua sungai-sungai yang mengalir langsung ke sungai Mississippi. (tantangan utamanya adalah menemukan atribut yang tepat...) Petunjuk Butir dan atribut yang relevan adalah: Mississippi River (Q1497), mouth of the watercourse (P403). Contoh solusi SELECT ?sungai ?sungaiLabel
WHERE
{
  ?sungai wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Sungai yang mengalir ke Mississippi II Tulislah kueri yang mengembalikan semua sungai-sungai yang mengalir ke sungai Mississippi, langsung atau tidak langsung. Petunjuk kueri ini hampir sama dengan sebelumnya. Perbedaannya adalah sekarang kamu perlu jejak sebagai pengganti tripel. (kalau kamu melewatkan bab tentang jejak, lewati latihan ini juga.) Contoh solusi SELECT ?sungai ?sungaiLabel
WHERE
{
  ?sungai wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL Pada latihan-latihan di atas, kita sudah memiliki kueri untuk semua buku oleh Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Tapi itu agak membosankan. Ada banyak data potensial tentang buku dan kita hanya menampilkan labelnya? Mari kita coba buat kueri yang juga menggunakan title (P1476), illustrator (P110), publisher (P123) dan publication date (P577).Percobaan pertama mungkin tampak seperti ini: SELECT ?buku ?judul ?ilustratorLabel ?penerbitLabel ?diterbitkan
WHERE
{
  ?buku wdt:P50 wd:Q35610;
        wdt:P1476 ?judul;
        wdt:P110 ?ilustrator;
        wdt:P123 ?penerbit;
        wdt:P577 ?diterbitkan.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Jalankan kueri tersebut. Ketika saya menulis ini, kueri itu hanya mengembalikan dua hasil – tampak terlalu sedikit! Mengapa begitu? Tadi kita temukan lebih dari ratusan buku!Hal ini disebabkan bahwa untuk mencocokkan kueri tersebut, suatu butir hasil (buku) harus sesuai dengan semua tripel yang kita jabarkan: harus punya judul, ilustrator, penerbit, dan tanggal publikasi. Jika suatu buku hanya punya beberapa atribut tetapi tidak semuanya maka buk tersebut tidak akan dianggap cocok dan tidak akan dimasukkan ke dalam hasil. Hal itu bukan seperti yang kita inginkan dalam kasus ini: kita utamanya hanya ingin daftar semua buku – kalau ada informasi tambahan maka sebaiknya dimasukkan tetapi kita tidak ingin hal ini membatasi hasil kueri.Solusinya adalah memberitahu WDQS bahwa tripel-tripel tersebut adalah \"opsional\": SELECT ?buku ?judul ?ilustratorLabel ?penerbitLabel ?diterbitkan
WHERE
{
  ?buku wdt:P50 wd:Q35610.
  OPTIONAL { ?buku wdt:P1476 ?judul. }
  OPTIONAL { ?buku wdt:P110  ?ilustrator. }
  OPTIONAL { ?buku wdt:P123  ?penerbit. }
  OPTIONAL { ?buku wdt:P577  ?diterbitkan. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Hal ini memberikan kita variabel-variabel tambahan (?judul, ?penerbit, dst.) jika pernyataan yang sesuai memang ada. Bila pernyataan yang sesuai tidak ada maka variabel-variabel tersebut hanya akan dikosongkan.Catatan: Sangat penting menggunakan klausa OPTIONAL terpisah di sini. Jika kamu menempatkan semua tripel dalam satu klausa seperti ini – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – kamu akan melihat bahwa kebanyakan hasilnya tidak mengandung informasi tambahan apapaun. Hal ini disebabkan klausa opsional dengan beberapa tripel hanya dianggap cocok bila semua tripelnya terpenuhi. yaitu, jika suatu buku punya judul, ilustrator, penerbit, dan tanggal terbit maka klausa opsional terpenuhi dan nilai-nilai tersebut akan diisikan ke variabel yang bersesuaian. Namun jika suatu buku punya, sebagai contoh, judul tapi tidak ada ilustrator, maka keseluruhan klausa optional dianggap tidak terpenuhi dan walaupun hasilnya tidak disingkirkan, semua variabel akan tetap kosong. Ekspresi, FILTER dan BIND Bab ini mungkin agak kurang teratur dibanding bab lainnya karena mencakup topik yang cukup luas. Konsep dasarnya adalah kita sekarang mau melakukan sesuatu dengan nila yang sejauh ini cukup dipilih dan akan dikembalikan tanpa kecuali. \"Ekspresi\" adalah cara untuk mengekspresikan operasi-operasi terhadap nilai. Ada berbagai macam ekspresi dan banyak hal yang bisa dilakukan dengannya – tapi sebelumya, mari kita mulai dari dasar: tipe data. Tipe-tipe data Setiap nilai di SPARQL punya tipe yang menyatakan bahwa nilai seperti apa isinya dan apa yang bisa dilakukan terhadapnya. Tipe-tipe data yang paling penting diantaranya: butir, seperti wd:Q12507668 untuk Raditya Dika (Q12507668). boolean, untuk dua nilai yang mungkin benar (true) atau salah (false). Nilai Boolean tidak disimpan secara eksplisit dalam pernyataan tapi banyak ekspresi mengembalikan nilai boolean, mis. 2 < 3 (true) atau \"a\" = \"b\" (false). string, sepotong teks. Literal string dituliskan dalam apitan kutip ganda. teks monolingual, suatu string yang ditambahkan tag bahasa. Pada suatu literal, kamu dapat menambahkan tag bahasa setelah string tersebut dengan tanda @, mis. \"Raditya Dika\"@id. bilangan, baik bilangan bulat (1) atau desimal (1.23). tanggal. Literal tanggal dapat dituliskan dengan menambahkan tanda ^^xsd:dateTime (sensitif kapital – ^^xsd:datetime tidak akan dianggap!) terhadap string tanggal ISO 8601: \"2012-10-29\"^^xsd:dateTime. (Wikidata belum mendukung stempelmasa dengan jam, menit, detik, dst.)  Operator-operator Operator-operator matematika yang biasa kita kenal yang tersedia antara lain:+, -, *, / untuk penjumlahan, pengurangan, perkalian atau pembagian bilangan, <, >, =, <=, >= untuk perbandingan. Uji ketidaksamaan ≠ ditulis sebagai !=. Perbandingan juga didefinisikan untuk tipe data lainnya; sebagai contoh, \"abc\" < \"abd\" bernilai benar (perbandingan leksikal), begitu juga \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime dan wd:Q4653 != wd:Q283111. Kondisi boolean dapat dikombinasikan dengan && (operator logika DAN: a && b bernilai benar jika kedua suku a dan b sama-sama bernilai benar) dan || (operator logika ATAU: a || b bernilai benar jika salah satu (atau keduanya) dari a dan b bernilai benar). FILTER Info Untuk alternatif pengganti FILTER yang terkadang lebih cepat, Anda bisa juga melihat MINUS, lihat contoh.FILTER(kondisi) adalah klausa yang bisa kamu selipkan ke dalam kueri SPARQL untuk menyaring hasil eksekusi. Di dalam tanda kurung, kamu bisa menempatkan ekspresi bertipe boolean dan hanya hasil yang sesuai dengan ekspresi tersebut (evaluasi ekspresi menghasilkan true) yang dikembalikan.Sebagai contoh, untuk mendapatkan daftar semua orang yang lahir di tahun 2015, pertama-tama kita cari dulu semuau manusia dan tanggal lahirnya – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – kemudian saring supaya hanya mengembalikan hasil yang memiliki tahun lahir 2015. Ada dua cara untuk melakukan ini: ekstrak tahun dari tanggal menggunakan fungsi YEAR, lalu ujikan apakah nilainya 2015 – FILTER(YEAR(?dob) = 2015). – atau periksa apakah tanggalnya ada di antara 1 Januari 2015 (inklusif) dan 1 Januari 2016 (eksklusif): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Kalau menurut saya opsi pertama lebih sederhana tetapi ternyata opsi kedua jauh lebih cepat. Kalau begitu mari gunakan yang kedua: SELECT ?orang ?orangLabel ?ttl
WHERE
{
  ?orang wdt:P31 wd:Q5;
          wdt:P569 ?ttl.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?ttl < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Kemungkinan lain penggunaan FILTER terkait pada label. Layanan label sangat berguna jika kamu hanya ingin menampilkan label dari suatu variabel tetapi jika kamu ingin melakukan sesuatu terhadap label– misalnya: cek jika label diawali dengan “Mr. ” – kamu akan dapatkan bahwa itu tidak bisa: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! kueri ini menemukan semua instans dari fictional human (Q15632617) dan menguji jika labelnya diawali dengan \"Mr. \" (STRSTARTS merupakan singkatan dari “string starts [with]” atau string diawali [dengan]; ada juga STRENDS untuk string yang diakhiri dan CONTAINS untuk string yang mengandung). Hal ini tidak dapat dilakukan karena layanan label menambahkan variabel label di akhir proses evaluasi kueri; layanan label belum membuat variabel ?manusiaLabel bahkan ketika kita mencoba melakukan FILTER terhadap variabel tsb.Sayangnya, layanan label bukan satu-satunya cara untuk mendapatkan label dari suatu butir. Label juga disimpan sebagai tripel biasa menggunakan predikat rdfs:label. Tentunya ini berarti semua label bukan sekadar label bahasa Inggris; tapi jika kita hanya ingin label bahasa Inggris, maka kita harus memfilter terhadap bahasa dari label tersebut: FILTER(LANG(?label) = \"en\"). Fungsi LANG mengembalikan bahasa dari string monolingual, dan di sini kita hanya memilih label dalam bahasa Inggris. Kueri keseluruhannya adalah: SELECT ?manusia ?label
WHERE
{
  ?manusia wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! Kita dapatkan label dengan tripel ?manusia rdfs:label ?label lalu membatasi hanya untuk label berbahasa Inggris, kemudian menguji apakah label tersebut diawali “Mr. ”.FILTER juga bisa digunakan dengan ekspresi reguler. Pada contoh berikut SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Jika pewatas format suatu ID adalah [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! Elemen spesifik dapat disaring dengan cara seperti ini FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) Bisa juga menyaring dan mengambil elemen yang tidak diisi: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Ketiga fitur ini sering digunakan bersamaan satu sama lain, jadi Saya akan menjelaskan ketiganya dan menunjukkan beberapa contoh.Klausa BIND(ekspresi AS ?variabel). dapat digunakan untuk mengisi hasil suatu ekspresi ke dalam suatu variabel (biasanya variabel baru namun juga bisa digunakan untuk mengisi variabel yang sudah ada sebelumnya).BOUND(?variable) menguji apakan suatu variabel sudah diikat ke nilai tertentu (bernilai true atau false). Hal ini biasanya berguna pada variabel yang ditambahkan oleh klausa OPTIONAL.IF(kondisi,ekspresiKalauYa,ekspresiKalauTidak) dievaluasi sebagai ekspresiKalauYa jika kondisi bernilai true, dan ekspresiKalauTidak jika kondisi bernilai false. Jadi, IF(true, \"ya\", \"tidak\") akan dievaluasi sebagai \"ya\", dan IF(false, \"bagus\", \"jelek\") akan dievaluasi sebagai \"jelek\".BIND dapat digunakan untuk mengikat beberapa perhitungan ke dalam variabel baru. Hal ini bisa berupa hasil antara dari perhitungan yang lebih besar atau berupa hasil dari suatu kueri. Sebagai contoh, untuk mendapatkan usia dari korban hukuman mati: SELECT ?orang ?orangLabel ?usia
WHERE
{
  ?orang wdt:P31 wd:Q5;
          wdt:P569 ?lahir;
          wdt:P570 ?wafat;
          wdt:P1196 wd:Q8454.
  BIND(?wafat - ?lahir AS ?usiaHari).
  BIND(?usiaHari/365.2425 AS ?usiaTahun).
  BIND(FLOOR(?usiaTahun) AS ?usia).
  # atau, sebagai satu ekspresi:
  #BIND(FLOOR((?wafat - ?lahir)/365.2425) AS ?usia).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND juga dapat digunakan untuk mengikat nilai konstan ke variabel untuk mempermudah keterbacaan. Sebagai contoh, kueri untuk menemukan semua pendeta wanita: SELECT ?perempuan ?perempuanLabel
WHERE
{
  ?perempuan wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! juga dapat dituliskan sebagai: SELECT ?wanita ?wanitaLabel
WHERE
{
  BIND(wdt:P31 AS ?adalah).
  BIND(wd:Q5 AS ?manusia).
  BIND(wdt:P21 AS ?jenisKelamin).
  BIND(wd:Q6581072 AS ?wanita).
  BIND(wdt:P106 AS ?pekerjaan).
  BIND(wd:Q42603 AS ?pendeta).
  ?perempuan ?adalah ?manusia;
         ?jenisKelamin ?wanita;
         ?pekerjaan ?pendeta.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Bagian yang mengandung makna dari kueri, dari ?wanita ke ?pendeta kini jadi lebih mudah dibaca. Namun, sebagian besar blok BIND di bagian depan kueri cukup mengganggu sehingga penggunaannya perlu dipertimbangkan ulang. (di antarmuka WDQS, kamu bisa melewatkan tetikus di atas sembarang istilah seperti wd:Q123 atau wdt:P123 dan melihat label dan deskripsi entitas tersebut, jadi ?wanita hanya akan lebih mudah dibaca jika fitur ini diabaikan.)Ekspresi IF seringkali digunakan bersama BOUND sebagai ekspresinya. Sebagai contoh, anggap kamu punya kueri yang menampilkan beberapa orang dan alih-alih hanya menampilkan labelnya, kamu berniat menampilkan pseudonym (P742) jika tersedia dan hanya menggunakan label jika pseudonim tidak tersedia. Untuk itu, kamu pilih pseudonim dalam klausa OPTIONAL (harus optional – kamu tidak ingin membuang hasil yang tidak punya pseudonim), kemudian gunakan BIND(IF(BOUND(… untuk memilih antara pseudonim atau label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! atribut-atribut lain yang dapat digunakan dalam hal ini melingkupi nickname (P1449), posthumous name (P1786), dan taxon common name (P1843) – apapun yang bisa jadi semacam \"cadangan\" yang masuk akal.Kamu juga bisa menggabungkan BOUND dengan FILTER untuk menjamin bahwa paling tidak ada satu atau beberapa blok OPTIONAL telah terpenuhi. Sebagai contoh, mari dapatkan semua astronot yang pernah ke Bulan sekalian dengan anggota Apollo 13 (Q182252) (cukup mendekati, bukan?). Pengetatan itu tidak dapat diekspresikan dalam satu jejak atribut sehingga kita perlu satu klausa OPTIONAL untuk \"anggota dari beberapa misi ke Bulan\" dan satu lagi untuk \"anggota Apollo 13\". Tapi kita hanya ingin memilih hasil yang paling tidak salah satu kondisi ini terpenuhi. SELECT ?astronot ?astronotLabel
WHERE
{
  ?astronot wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronot wdt:P450 ?misi.
    ?misi wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronot wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?misi).
  }
  FILTER(BOUND(?misi)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE Fungsi COALESCE dapat digunakan sebagai singkatan dari pola BIND(IF(BOUND(?x), ?x, ?y) AS ?z). sebagai cadangan yang disebut di atas: fungsi tersebut menerima sejumlah ekspresi dan mengembalikan ekspresi pertama yang dievaluasi tanpa kesalahan. Sebagai contohm cadangan \"pseudonim\" di atas BIND(IF(BOUND(?pseudonim),?pseudonim,?penulisLabel) AS ?label). dapat dituliskan secara lebih singkat sebagai BIND(COALESCE(?pseudonim, ?penulisLabel) AS ?label). menambahkan label cadangan satu lagi dalam kasus ?penulisLabel tidak terdefinisi pun juga mudah: BIND(COALESCE(?pseudonim, ?penulisLabel, \"<no label>\") AS ?label).  Pengelompokkan Sejauh ini, semua kueri yang telah kita lihat adalah kueri-kueri yang menemukan semua butir yang memenuhi beberapa kondisi; pada beberapa kasus, kita juga menambahkan pernyataan tambahan pada butir (lukisan dengan material, buku Arthur Conan Doyle dengan judul dan ilustrator).Tetapi adalah hal yang cukup wajar kalau kita tidak mau daftar yang terlalu panjang untuk semua hasilnya. Mungkin kita ingin menjawab pertanyaan seperti ini: Berapa banyak lukisan yang dilukis di kanvas / kayu poplar / dll.? Berapa populasi kota terbanyak dari setiap negara? Berapa total jumlah senjata yang dibuat oleh tiap pembuat? Siapa yang mempublikasikan buku terpanjang secara rata-rata?  Populasi kota Mari kita lihat pertanyaan kedua dulu. Cukup sederhana sebetulnya menulis kueri yang menghasilkan daftar kota sekalian dengan populasi dan negaranya diurut berdasarkan negara: SELECT ?negara ?kota ?populasi
WHERE
{
  ?kota wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?negara;
        wdt:P1082 ?populasi.
}
ORDER BY ?negara
 Try it! (Catatan: kueri tersebut mengembalikan banyak hasil yang mungkin menyebabkan perambanmu bermasalah. Kamu mungkin ingin menambahkan klausa LIMIT.)Karena kita hanya mengurutkan hasil berdasarkan negara, semua kota yang berada pada satu negara membentuk blok pada hasil. Untuk mencari populasi terbanyak dalam blok tersebut, kita perlu mempertimbangkan blok tersebut sebagai satu kelompok (group) dan mengagregasikan (aggregate) semua nilai populasi ke dalam satu nilai yaitu: maksimum. Hal ini dilakukan dengan menggunakan klausa GROUP BY di bawah blok WHERE, dan fungsi agregat (MAX) pada klausa SELECT. SELECT ?negara (MAX(?populasi) AS ?populasiMaks)
WHERE
{
  ?kota wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?negara;
        wdt:P1082 ?populasi.
}
GROUP BY ?negara
 Try it! Kita telah mengganti ORDER BY dengan GROUP BY. Dampaknya adalah semua hasil yang nilai ?negara-nya sama sekarang dikelompokkan jadi satu hasil. Hal ini berarti kita harus mengganti klausa SELECT-nya: Jika kita membiarkan klausa SELECT ?negara ?kota ?populasi yang lama, ?kota dan ?populasi yang mana yang akan dikembalikan? Ingatlah bahwa ada banyak kombinasi nilai pada hasil ini, semuanya memiliki nilai ?negara yang sama jadi kita bisa pilih itu namun karena semuanya punya nilai ?kota dan ?populasi yang berbeda, kita harus memberitahukan WDQS nilai mana yang harus dipilih. Itulah peranan dari fungsi agregat. Pada kasus ini kita telah menggunakan MAX: Dari semua nilai ?populasi yang ada, kita pilih yang paling besar pada tiap kelompok hasil. (Kita juga telah memberikan nilai tersebut dengan nama baru menggunakan pola AS tetapi itu hanya rincian teknis.)Ini adalah pola umum untuk membuat kueri kelompok: tulis kueri biasa yang mengembalikan data yang kamu inginkan (belum dikelompokkan; dengan ada banyak hasil per kelompok) kemudian tambahkan klausa GROUP BY dan tambahkan fungsi agregat pada semua variabel yang tidak dikelompokkan pada klausa SELECT. Material lukisan Mari kita coba untuk pertanyaan lain: Berapa banyak lukisan yang dilukis untuk tiap material? Pertama coba tuliskan kueri yang mengembalikan semua lukisan bersama dengan materialnya. (berhati-hatilah supaya hanya menggunakan pernyataan made from material (P186) dengan penjelas applies to part (P518)painting support (Q861259) .) SELECT ?material ?lukisan
WHERE
{
  ?lukisan wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Berikutnya, tambahkan klausa GROUP BY pada ?material kemudian fungsi agregat pada variabel terpilih (?lukisan). Pada kasus ini, kita tertarik pada banyaknya lukisan; fungsi agregat untuk itu adalah COUNT. SELECT ?material (COUNT(?lukisan) AS ?banyaknya)
WHERE
{
  ?lukisan wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! Satu masalah dengan ini adalah kita tidak punya label untuk material sehingga hasilnya agak kurang nyaman untuk diinterpretasi. Jika kita tambahkan variabel label maka kita akan dapatkan kesalahan: SELECT ?material ?materialLabel (COUNT(?lukisan) AS ?banyaknya)
WHERE
{
  ?lukisan wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” adalah pesan kesalahan yang mungkin akan kamu sering temukan ketika berurusan dengan kueri kelompok; ini artinya salah satu variabel terpilih perlu fungsi agregat tetapi dalam hal ini fungsi agregat tidak dipakai atau fungsi agregat dipakai walaupun tidak semestinya. Pada kasus ini, WDQS menganggap bahwa bisa jadi ada beberapa ?materialLabel tiap ?material (walaupun kita tahu bahwa itu tidak akan terjadi) dan akhirnya memberikan protes bahwa kamu tidak menspesifikasikan fungsi agregat untuk variabel tersebut.Salah satu solusinya adalah membuat kelompok dari beberapa variabel sekaligus. Jika kamu menuliskan beberapa variabel di klausa GROUP BY, ada beberapa hasil untuk setiap kombinasi dari nilai-nilai tersebut dan kamu bisa memilih semuanya tanpa fungsi agregat. Dalam hal ini kita mengelompokkan ?material dan ?materialLabel. SELECT ?material ?materialLabel (COUNT(?lukisan) AS ?banyaknya)
WHERE
{
  ?lukisan wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! Kita hampir selesai dengan kueri ini – hanya satu lagi perbaikan: kita ingin melihat lebih dulu material mana yang paling sering digunakan. Untungnya kita diperbolehkan untuk menggunakan variabel agregat yang baru di klausa SELECT (dalam hal ini, ?sekian) dari klausa ORDER BY sehingga hal ini jadi sangat sederhana: SELECT ?material ?materialLabel (COUNT(?lukisan) AS ?banyaknya)
WHERE
{
  ?lukisan wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?banyaknya)
 Try it! Sebagai latihan, coba kueri-kueri lainnya juga. Senjata berdasarkan pembuat Berapa banyak senjata yang dibuat oleh tiap pembuat? Petunjuk Butir dan atribut yang relevan adalah: firearm (Q12796), manufacturer (P176), total produced (P1092). Contoh solusi SELECT ?pembuat ?pembuatLabel (SUM(?diproduksi) AS ?totalYangDiproduksi)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?pembuat;
         wdt:P1092 ?diproduksi.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?pembuat ?pembuatLabel
ORDER BY DESC(?diproduksi)
 Try it!  Penerbit berdasarkan banyaknya halaman Berapa rata-rata (fungsi: AVG) banyaknya halaman buku dari tiap penerbit? Petunjuk Butir dan atribut yang relevan adalah: publisher (P123), number of pages (P1104). Contoh solusi SELECT ?penerbit ?penerbitLabel (AVG(?halaman) AS ?halamanRerata)
WHERE
{
  ?buku wdt:P123 ?penerbit;
        wdt:P1104 ?halaman.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?penerbit ?penerbitLabel
ORDER BY DESC(?halamanRerata)
 Try it! HAVING Tambahan kecil pada kueri terakhir – jika kamu perhatikan hasilnya, kamu akan melihat bahwa hasil teratas adalah nilai yang sangat besar, lebih dari sepuluh kali lipat dari urutan kedua. Penyelidikan lebih lanjut mengungkap bahwa hal ini terjadi karena penerbit tersebut (UTET (Q4002388)) hanya menerbitkan satu buku dengan pernyataan number of pages (P1104) sehingga mencondongkan hasilnya sedikit. Untuk menyingkirkan pencilan seperti itu, kita bisa coba memilih hanya penerbit yang pernah menerbitkan paling tidak dua buku dengan pernyataan number of pages (P1104) di Wikidata.Bagaimana kita melakukan itu? Biasanya, kita membatasi hasil dengan klausa FILTER tetapi kali ini kita mau membatasi berdasarkan kelompok (banyaknya buku) dan bukan hasil satu-per-satu. Hal ini dilakukan dengan klausa HAVING yang bisa ditempatkan setelah klausa GROUP BY dan menerima ekspresi sama seperti klausa FILTER: SELECT ?penerbit ?penerbitLabel (AVG(?halaman) AS ?halamanRerata)
WHERE
{
  ?buku wdt:P123 ?penerbit;
        wdt:P1104 ?halaman.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?penerbit ?penerbitLabel
HAVING(COUNT(?buku) > 1)
ORDER BY DESC(?halamanRerata)
 Try it!  Rangkuman fungsi agregat Berikut ini rangkuman fungsi-fungsi agregat yang tersedia: COUNT: menghitung banyaknya elemen. Kamu juga bisa menuliskan sebagai COUNT(*) untuk menghitung terhadap semua variabel yang ada pada hasil. SUM, AVG: jumlah atau rata-rata dari semua elemen. Jika elemennya bukan bilangan maka kamu akan mendapatkan hasil yang aneh. MIN, MAX: Nilai minimum atau maksimum dari semua elemen. Hal ini berlaku untuk semua tipe: bilangan diurut secara numerik, string dan tipe lain diurut secara leksikal. SAMPLE: salah satu elemen. Hal ini biasanya berguna ketika kamu tahu bahwa hanya ada satu hasil atau ada beberapa hasil tapi kamu tidak peduli hasil yang mana yang perlu dikembalikan. GROUP_CONCAT: menyambung semua elemen. Kurang terlalu berguna, tapi kalau kamu penasaran, kamu bisa baca lebih jauh di spesifikasi SPARQL. Sebagai tambahan, kamu bisa menambahkan pengubah DISTINCT untuk setiap fungsi tersebut untuk menyingkirkan duplikasi hasil. Sebagai contoh, jika ada dua hasil tapi keduanya memiliki nilai yang sama di variabel ?var, maka COUNT(?var) akan mengembalikan nilai 2 tetapi COUNT(DISTINCT ?var) hanya akan mengembalikan 1. Seringkali kamu harus menggunakan DISTINCT ketika kuerimu mengembalikan beberapa butir yang sama – ini dapat terjadi jika, sebagai contoh, kamu menggunakan ?butir wdt:P31/wdt:P279* ?kelas dan ada beberapa jejak dari ?butir ke ?kelas: kamu akan mendapatkan satu hasil untuk setiap jejak ini walaupun semua nilainya sama persis. (Kalau kamu tidak mengelompokkan, kamu dapat menyingkirkan duplikasi hasil dengan memulai kueri dengan SELECT DISTINCT daripada sekadar SELECT.) Kutu wikibase:Label dan agregasi Pada saat ini (Februari 2020) terdapat masalah dengan layanan kueri ketika Anda ingin menggunakan layanan $service dengan fungsi agregasi. Kueri seperti yang berikut ini, yang mencari semua tokoh akademik denga nlebih dari dua kewarganegaraan di Wikidata dan seharusnya menampilkan nama negara-negara tersebut di dalam string agregat: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! gagal menampilkan apa-apa di kolom ?citizenships. Cara mengitarinya adalah dengan memberikan nama ?personLabel dan ?citizenshipLabel secara tersirat di panggilan layanan wikibase:label seperti ini: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Før vi går igang 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Tilfælde og klasser 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Kemiske elementer 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Datatyper 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Gruppering 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VÆRDIER 12 Label in multiple languages 13 And beyond… 14 Se også Før vi går igang While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} eller dette, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} eller dette, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! På engelsk vil det stå som: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Her er min løsning: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: naturligt sprog eksempel SPARQL eksempel sætning Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. komma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ].  Tilfælde og klasser Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # tilfælde af kunstværk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Her er min løsning: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Her er min løsning: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Kemiske elementer Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types.  Datatyper Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Hr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # eller, som et udtryk:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! kan blive omskrevet til: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  Gruppering So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS: خدمة استعلام ويكي بيانات: هي أداة قوية لتوفير نظرة ثاقبة لمحتوى ويكي بيانات. سوف يعلمك هذا الدليل كيفية استخدامه. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents ١ قبل أن نبدأ ٢ أساسيات سباركل ٣ استعلامنا الأول ٣.١ إكما تلقائي ٤ أنماط ثلاثية متقدمة ٥ مثيلات وفئات ٥.١ مسارات الخاصية ٦ التصفيات ٧ ORDER وLIMIT ٧.١ تمرين ٧.١.١ كتب آرثر كونان دويل ٧.١.٢ العناصر الكيميائية ٧.١.٣ الأنهار التي تتدفق إلى المسيسيبي ٧.١.٤ الأنهار التي تتدفق إلى الميسيسيبي 2 ٨ OPTIONAL ٩ تعبيران: FILTER وBIND ٩.١ أنواع البيانات ٩.٢ المشغلون ٩.٣ FILTER ٩.٤ BIND، BOUND، IF ٩.٥ COALESCE ١٠ التجمع ١٠.١ سكان المدينة ١٠.٢ مواد الطلاء ١٠.٣ البنادق حسب الشركة المصنعة ١٠.٤ الناشرون حسب عدد الصفحات ١٠.٤.١ HAVING ١٠.٥ ملخص الدالات التجميعية ١٠.٦ wikibase:Label and aggregations ١١ VALUES ١٢ Label in multiple languages ١٣ وما وراء... ١٤ See also قبل أن نبدأ في حين أن هذا الدليل قد يبدو طويلا ومرهقا، فلا تدع هذا يخيفك! إن مجرد تعلم أساسيات سباركل سيوفر لك طريقا طويلا - حتى إذا توقفت عن القراءة بعد #استعلامنا الأول ، سوف تفهم بالفعل ما يكفي لبناء العديد من الاستعلامات المثيرة للاهتمام، سيقوم كل قسم من هذا البرنامج التعليمي بتمكينك من كتابة استعلامات أكثر فعالية.أيضا، إذا لم تكن قد سمعت من قبل عن ويكي بيانات أو سباركل أو خدمة استعلام ويكي بيانات من قبل، فإليك شرح موجز لتلك المصطلحات: ويكي بيانات هي قاعدة بيانات المعرفة، تحتوي على ملايين البيانات، مثل \"عاصمة كندا أوتاوا\"، أو \"الموناليزا مطلية بطلاء زيت على خشب الحور\"، أو \"الذهب له نقطة انصهار 1064.18 درجة مئوية\". 'SPARQL' هي لغة لصياغة أسئلة (استعلامات) لقواعد بيانات المعرفة، باستخدام قاعدة البيانات الصحيحة، يمكن أن يجيب استعلام سباركل على أسئلة مثل \"ما هي النغمة الأكثر شيوعا في الموسيقى؟\" أو \"أية شخصية تم تصويرها بواسطة أكثر الممثلين؟\" أو \"ما هو توزيع أنواع الدم؟ \"أو\" ما أعمال المؤلفين التي دخلت الملكية العامة هذا العام؟\". WDQS:خدمة استعلام ويكي بيانات تجمع الاثنين معا: يمكنك إدخال استعلام سباركل، فإنها تشغله تجاه مجموعة بيانات ويكي بيانات ويظهر لك النتيجة.  أساسيات سباركل يبدو استعلام سباركل بسيط مثل هذا: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} تسرد جملة SELECT المتغيرات التي تريد إرجاعها (تبدأ المتغيرات بعلامة استفهام)، وتحتوي جملة WHERE على قيود عليها، معظمها في صورة ثلاثيات، يتم تخزين جميع المعلومات في ويكي بيانات (وقواعد بيانات المعرفة المماثلة) في شكل ثلاثيات، عندما تقوم بتشغيل الاستعلام، تحاول خدمة الاستعلام ملء المتغيرات بالقيم الفعلية بحيث تظهر الثلاثيات الناتجة في قاعدة بيانات المعرفة، وترجع نتيجة واحدة لكل مجموعة من المتغيرات التي تعثر عليها. يمكن قراءة الثلاثي كجملة (وهذا هو السبب في أنه ينتهي بنقطة)، مع موضوع، ومسند، وكائن: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} قد تتضمن نتائج هذا الاستعلام، على سبيل المثال، \"ليمون\"، في ويكي بيانات، معظم الخصائص هي خصائص \"لديه\"-نوع ; لذا قد يقرأ الاستعلام بدلا من ذلك: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} الذي يقرأ مثل \"?fruit له لون \"أصفر\" (ليس \"?fruit is لون \"الأصفر\"، ضع هذا في الاعتبار لأزواج الخواص مثل \"الأم\"/\"الطفل\"!).ومع ذلك، هذا ليس مثالا جيدًا لـخدمة استعلام ويكي بيانات، الذوق شخصي; لذلك ليس لدى ويكي بيانات خاصية خاصة به، بدلا من ذلك، دعونا نفكر في العلاقات بين الوالد/الطفل، والتي لا لبس فيها في الغالب. استعلامنا الأول لنفترض أننا نريد سرد جميع أطفال الملحن الباروكي يوهان سيباستيان باخ، باستخدام عناصر زائفة كما في الاستعلامات أعلاه، كيف تكتب هذا الاستعلام؟نأمل أن يكون لديك شيء من هذا القبيل: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (ملاحظة: كل شيء بعد '#' هو تعليق ويتم تجاهله بواسطة خدمة استعلام ويكي بيانات.)
} أو هذا، SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} أو هذا، SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} تقول أول ثلاثيتين أن ?child يجب أن يكون له الوالد/الأب باخ، تقول الثالثة أن باخ يجب أن يكون الطفل ?child، لنذهب مع الثاني في الوقت الحالي.ما الذي يجب عمله حتى يتم تحويله إلى استعلام خدمة استعلام ويكي بيانات ملائم؟ في ويكي بيانات، لا يتم تحديد العناصر والخصائص بواسطة أسماء يمكن قراءتها بواسطة الإنسان مثل \"الأب\" (خاصية) أو \"باخ\" (عنصر). (لسبب وجيه: \"يوهان سيباستيان باخ\" هو أيضا اسم رسام ألماني، وقد يشير \"باخ\" أيضا إلى لقب، البلدية الفرنسية ، الحفرة الزئبقية، إلخ.) بدلا من ذلك، يتم تعيين معرف لعناصر وخصائص ويكي بيانات، للعثور على المعرف لعنصر; نحن نبحث عن العنصر وننسخ الرقم Q للنتيجة التي يبدو أنها العنصر الذي نبحث عنه (على أساس الوصف، على سبيل المثال)، للعثور على معرف خاصية; نفعل نفس الشيء، ولكن ابحث عن \"P:مصطلح البحث\" بدلا من \"مصطلح البحث\"، والذي يحدد البحث إلى الخصائص، هذا يخبرنا أن الملحن الشهير يوهان سيباستيان باخ هو Q1339، والخاصية التي تحدد اسم الأب هي P:P22وأخيرا وليس آخرا، نحتاج إلى تضمين البادئات، بالنسبة لمضاعفات خدمة استعلام ويكي بيانات البسيطة، يجب أن تبدأ العناصر بـwd:، وخصائص تحتوي على wdt:. (لكن هذا ينطبق فقط على القيم الثابتة، لا تحصل المتغيرات على بادئة!)بوضع هذا الأمر معا، نصل إلى أول طلب بحث في أول استعلام خدمة استعلام ويكي بيانات صحيح: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! انقر فوق ذلك الرابط \"جربه\"، ثم \"تشغيل\" الاستعلام على صفحة خدمة استعلام ويكي بيانات، على ماذا تحصل؟ طفل wd:Q57225 wd:Q76428 … حسنا هذا مخيب للآمال، أنت فقط ترى المعرفات، يمكنك النقر عليها لرؤية صفحة ويكي بيانات الخاصة بها (بما في ذلك تسمية يمكن قراءتها بواسطة البشر)، ولكن أليست هناك طريقة أفضل لرؤية النتائج؟حسنا، كما يحدث، هناك! (أليست الأسئلة الخطابية رائعة؟) إذا قمت بتضمين النص السحري SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } في مكان ما داخل عبارة WHERE ، تحصل على متغيرات إضافية: لكل متغير ?foo في استعلامك، لديك الآن أيضا متغير ?fooLabel، الذي يحتوي على تسمية العنصر خلف ?foo، إذا أضفت هذا إلى جملة SELECT، فستحصل على العنصر بالإضافة إلى تسميته: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! حاول تشغيل هذا الاستعلام - يجب ألا تشاهد فقط أرقام العناصر، بل أيضا أسماء مختلف الأطفال. طفل تسمية الطفل wd:Q57225 يوهان كريستوف فريدريك باخ wd:Q76428 كارل فيليب إيمانويل باخ …  إكما تلقائي يبدو أن مقتطف SERVICE صعب التذكر رغم ذلك، أليس كذلك؟ والقيام بوظيفة البحث طوال الوقت أثناء كتابة الاستعلام أمر ممل، لحسن الحظ، تقدم خدمة استعلام ويكي بيانات حلا رائعا لهذا: الإكمال التلقائي، في محرر استعلام query.wikidata.org، يمكنك الضغط على Ctrl+Space في أية نقطة في الاستعلام والحصول على اقتراحات للأكواد التي قد تكون مناسبة، حدد الاقتراح الصحيح باستخدام مفاتيح الأسهم up/down، ثم اضغط على Enter لتحديده.على سبيل المثال، بدلا من كتابة SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } في كل مرة، يمكنك فقط كتابة SERV، والضغط على Ctrl+Space، وسيكون أول اقتراح أن تعويذة خدمة التسمية الكاملة، جاهزة للاستخدام! ما عليك سوى الضغط على Enter لقبولها. (سيكون التنسيق مختلفا بعض الشيء، ولكن لا يهم ذلك).ويمكن للإكمال التلقائي أيضا البحث عنك، إذا كتبت إحدى بادئات ويكي بيانات، مثل wd: أو wdt:، ثم اكتب النص بعد ذلك، Ctrl+Space سيبحث عن هذا النص على ويكي بيانات ويقترح النتائج. wd: يبحث عن العناصر، wdt: عن الخصائص على سبيل المثال، بدلا من البحث عن العناصر الخاصة بـJohann Sebastian Bach (Q1339) وfather (P22)، يمكنك فقط كتابة wd:Bach وwdt:fath ثم حدد الإدخال الصحيح من الإكمال التلقائي، (هذا يعمل حتى مع المساحات في النص، مثل wd:Johann Sebastian Bach.) أنماط ثلاثية متقدمة حتى الآن رأينا جميع أطفال يوهان سيباستيان باخ - بشكل أكثر تحديدا: كل العناصر مع الأب يوهان سيباستيان باخ، لكن باخ كان عنده زوجتان; ولهذا فإن هاذين الأمرين لديهما أمان مختلفتان: ماذا لو كنا نريد فقط رؤية أطفال يوهان سيباستيان باخ مع زوجته الأولى ماريا باربرا باخ (Q57487)؟ حاول كتابة هذا الاستعلام، بناءً على الموجود أعلاه.فعلت ذلك؟ حسنا، ثم على الحل! أبسط طريقة للقيام بهذا هي إضافة ثلاثية ثانية مع هذا القيد: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! بالإنجليزية، هذا يقرأ: الطفل لديه الأب يوهان سيباستيان باخ. الطفل لديه الأم ماريا باربرا باخ. هذا يبدو محرجا بعض الشيء، أليس كذلك؟ باللغة الطبيعية، سنقوم باختصار هذا: الطفل لديه الأب يوهان سيباستيان باخ والأم ماريا باربرا باخ. في الواقع، من الممكن التعبير عن الاختصار نفسه بسباركل أيضا: إذا قمت بإنهاء ثلاثية بفاصلة منقوطة (;) بدلا من نقطة، يمكنك إضافة زوج آخر من كائن الأصل، هذا يسمح لنا باختصار الاستعلام أعلاه إلى: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! الذي له نفس النتائج، ولكن أقل تكرارا في الاستعلام.لنفترض الآن أنه من بين هذه النتائج، نحن مهتمون فقط بالأولاد الذين كانوا مؤلفين وملحنين وعازفي بيانو الخصائص والعناصر ذات الصلة هي occupation (P106) وcomposer (Q36834) وpianist (Q486748)، حاول تحديث الاستعلام أعلاه لإضافة هذه القيود!ها هو الحل الخاص بي: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! يستخدم هذا الاختصار ; مرتين إضافتين لإضافة المهنتين المطلوبتين، ولكن كما قد تلاحظ، لا يزال هناك بعض التكرار، هذا كما لو قلنا: الطفل لديه مهنة الملحن ومهنة عازف البيانو. والتي عادة ما نختصرها كما يلي: الطفل لديه مهنة الملحن وعازف البيانو. ولدى سباركل بعض البنية كذلك: تماما مثل ; تسمح لك بإلحاق زوج كائن أصلي إلى ثلاثي (إعادة استخدام الموضوع)، , تسمح لك بإلحاق كائن آخر إلى ثلاثية (إعادة استخدام كل الموضوع والمسند)، مع هذا، يمكن اختصار الاستعلام إلى: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ملاحظة: لا تهم المسافة البادئة والمسافة البيضاء الأخرى - لقد حددت مسافة الاستعلام فقط لجعلها أكثر قابلية للقراءة، يمكنك أيضا كتابته على النحو التالي: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # كل المهن في سطر واحد
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! أو، أقل سهولة في القراءة: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # عدم وجود مسافة بادئة يجعل من الصعب التمييز بين , و;
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! لحسن الحظ; يحرر محرر خدمة استعلام ويكي بيانات الخطوط لك تلقائيا،; لذلك لا داعٍ للقلق بشأن هذا الأمر.حسنا، دعونا نلخص هنا، لقد رأينا أن الاستعلامات منظمة مثل النص، يتم إنهاء كل ثلاثية حول موضوع من قبل فترة، ويتم فصل المسندات متعددة حول نفس الموضوع بواسطة فواصل منقوطة، ويمكن إدراج كائنات متعددة لنفس الموضوع والمسند مفصولة بفواصل. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} الآن أريد أن أقدم اختصارا آخر تقدمه سباركل، لذا; إذا كنت ستمتعني بسكريبت افتراضي آخر... Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? ها هو حلي: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! باللغة الطبيعية، هذا يقرأ: باخ لديه طفل ?child، ?child لديه طفل ?grandChild. مرة أخرى، أقترح أن نختصر هذه الجملة الإنجليزية، ثم أريد أن أريك كيف تدعم سباركل اختصارا مشابها، لاحظ كيف لا نهتم بالطفل: لا نستخدم المتغير إلا للحديث عن الحفيد، يمكننا بالتالي اختصار الجملة إلى: باخ لديه طفل لديه طفل ?grandChild. بدلا من قول من هو طفل باخ، نحن فقط نقول \"من شخص ما\": لا يهمنا من هو، ولكن يمكننا الرجوع إليهم لأننا قلنا \"شخص ما\" من \"\": هذا يبدأ بعلامة نسبية، وضمن تلك الفقرة النسبية يمكننا قول أشياء عن \"شخص ما\" (على سبيل المثال،?grandChild”))، بطريقة ما، يُعَد \"شخص ما\" متغيرا، ولكنه متغير خاص صالح فقط ضمن هذه الفقرة النسبية، وهو مصطلح لا نشير إليه صراحة (نحن نقول \"شخص ما يفعل هذا ويفعل ذلك\"، وليس \"شخص هل هذا هو وشخص ما يفعل ذلك\"، هذان \"شخصان\" مختلفان.بسباركل، يمكن كتابة هذا على النحو التالي: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! يمكنك استخدام زوج من الأقواس ([]) بدلا من متغير، والذي يعمل كمتغير مجهول، داخل الأقواس، يمكنك تحديد أزواج الأجسام الأصلية، مثلما يحدث بعد ; بعد ثلاثية عادية، الموضوع الضمني هو في هذه الحالة المتغير المجهول الذي تمثله الأقواس. (ملاحظة: كما هو الحال أيضا بعد ;، يمكنك إضافة المزيد من أزواج كائن البحث مع المزيد من الفواصل المنقوطة، أو المزيد من الكائنات لنفس المسند باستخدام الفواصل.)هذا كل شيء من أجل الأنماط الثلاثية! هناك أكثر من سباركل، ولكن عندما نوشك على ترك أجزاء منها تشبه إلى حد كبير اللغة الطبيعية، أود أن ألخص هذه العلاقة مرة أخرى: لغة طبيعية مثال سباركل مثال جملة جولييت تحب روميو. فترة جولييت تحب روميو. اقتران (شرط) روميو يحب جولييت و يقتل نفسه. فاصلة منقوطة روميو يحب جولييت; يقتل روميو. اقتران (اسم) روميو يقتل تيبالت و نفسه. فاصلة روميو يقتل تيبالت, روميو. جملة نسبية جولييت تحب الشخص الذي قتل تيبالت. أقواس جولييت تحب [ تقتل تيبالت ].  مثيلات وفئات في وقت سابق، قلت أن معظم خصائص ويكي بيانات هي علاقات \"لديه\": لديه طفل، لديه أب، لديه، لكن في بعض الأحيان (في الواقع، في كثير من الأحيان)، تحتاج أيضا إلى التحدث عن ما هو الشيء، لكن في الحقيقة هناك نوعان من العلاقات هناك: ذهب مع الريح هو فيلم. فيلم هو عمل فني. ذهب مع الريح هو فيلم خاص واحد، ولديه مخرج خاص (فيكتور فليمنج)، ومدة محددة (238 دقيقة)، وقائمة بأسماء الأعضاء (كلارك غيبل، فيفيان لي، ...)، وهكذا.فيلم هو مفهوم عام، يمكن أن يكون للأفلام مخرجون، ومدد، وأعضاء، ولكن المفهوم \"فيلم\" على هذا النحو لا يملك أي مخرج أو مدة معينة أو أعضاء معينين، وعلى الرغم من أن الفيلم هو عمل فني، وعادة ما يكون للعمل الفني منشئ، فإن مفهوم \"الفيلم\" نفسه لا يحتوي على منشئ، \"حالات\" خاصة فقط من هذا المفهوم.هذا الاختلاف هو سبب وجود خاصيتين لـ\"هو\" في ويكي بيانات: instance of (P31) وsubclass of (P279)، \"ذهب مع الريح\" هو مثال خاص للفئة \"فيلم\"، الفئة \"فيلم\" هي فئة فرعية (فئة أكثر تحديدا، تخصص) للفئة الأكثر عمومية \"أعمال فنية\". To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). إذن ماذا يعني هذا بالنسبة لنا عندما نكتب استعلامات سباركل؟ عندما نريد البحث عن \"كل الأعمال الفنية\"، لا يكفي البحث عن كل العناصر التي تكون حالات \"عمل فني\": SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # مثال على العمل الفني
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! كما أكتب هذا، هذا الاستعلام فقط يرجع 2815 نتيجة - من الواضح أن هناك أعمال فنية أكثر من ذلك! تكمن المشكلة في أن هذا يخطئ بعض العناصر مثل ذهب مع الريح، التي هي مجرد مثال \"فيلم\"، وليس \"عمل فني\"، \"الفيلم\" هي فئة فرعية من \"العمل الفني\"، ولكننا نحتاج إلى إخبار سباركل بأخذ ذلك في الاعتبار عند البحث.أحد الحلول الممكنة لهذا هو بناء الجملة [] الذي تحدثنا عنه: ذهب مع الريح مثال على الفئة الفرعية لبعض \"العمل الفني\". (للتمرين; حاول كتابة هذا الاستعلام!) ولكن ما زالت هناك مشكلات: لم نعد نضمِّن العناصر التي تمثل مثيلات مباشرة للعمل الفني. مازلنا نفتقد العناصر التي هي أمثلة لبعض الفئات الفرعية لبعض الفئات الفرعية الأخرى من العمل الفني - على سبيل المثال، سنو وايت والأقزام السبعة هو فيلم متحرك، وهو فيلم ، وهو عمل فني، في هذه الحالة، نحتاج إلى بياني \"فئة فرعية من\" - ولكن قد يكون أيضا ثلاثة أو أربعة أو خمسة أو أي رقم. الحل: ?item wdt:P31/wdt:P279* ?class: هذا يعني أن هناك \"مثال\" واحد ثم أي عدد من بيانات \"الفئة الفرعية\" بين العنصر والفئة. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # مثال على أية فئة فرعية من الأعمال الفنية
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (لا أوصي بتشغيل هذا الاستعلام، يمكن لخدمة استعلام ويكي بيانات التعامل معه (بالكاد فقط)، ولكن قد يتعطل متصفحك عند محاولة عرض النتائج لأن هناك الكثير منها.)الآن أنت تعرف كيفية البحث عن جميع الأعمال الفنية، أو جميع المباني، أو جميع المستوطنات البشرية: التعويذة السحرية wdt:P31/wdt:P279*، إلى جانب الفئة المناسبة، يستخدم هذا بعض ميزات سباركل التي لم أفسرها بعد، ولكن بصراحة تامة، هذا هو الاستخدام الوحيد الملائم لتلك الميزات; لذا لن تحتاج إلى فهم كيفية عملها من أجل استخدام خدمة استعلام ويكي بيانات بفعالية، إذا كنت تريد أن تعرف، سأشرحها قليلا، ولكن يمكنك أيضا تخطي القسم التالي وحفظ أو نسخ+لصق wdt:P31/wdt:P279* من هنا عندما تحتاج ذلك. مسارات الخاصية مسارات الخاصية هي طريقة لتدوين مسار خصائص بين عنصرين، أبسط مسار هو مجرد خاصية واحدة، والتي تشكل ثلاثية عادية: ?item wdt:P31 ?class. يمكنك إضافة عناصر مسار باستخدام شرطة مائلة للأمام (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. هذا يعادل أيا مما يلي: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. تمرين: قم بإعادة كتابة استعلام \"أحفاد باخ\" من قبل لاستخدام هذا النحو.علامة النجمة (*) بعد عنصر المسار تعني \"صفر أو أكثر من هذا العنصر. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> إذا لم تكن هناك عناصر أخرى في المسار، ?a something* ?b يعني أن ?b قد يكون أيضا ?a مباشرة، مع عدم وجود عناصر مسار بينهما على الإطلاق. يشبه الزائد (+) ، ولكنه يعني \"واحد أو أكثر من هذا العنصر\"، يجد الاستعلام التالي كل أحفاد باخ: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! إذا استخدمنا علامة النجمة بدلا من علامة الجمع هنا، فستتضمن نتائج استعلام باخ نفسه.تشبه علامة الاستفهام (?) علامة النجمة أو علامة زائد، ولكنها تعني \"صفر أو واحد من هذا العنصر\".يمكنك فصل عناصر المسار بشريط عمودي (|) بدلا من شرطة مائلة للأمام: هذا يعني \"إما - أو\": قد يستخدم المسار أيا من هذه الخصائص. (لكن ليس كليهما; فجزء من المسار \"إما أو\" يطابق دائما مسار طول واحد.)يمكنك أيضا تجميع عناصر المسار باستخدام أقواس (())، والجمع بحرية بين كل عناصر البنية هذه (/|*+?): وهذا يعني أن هناك طريقة أخرى للعثور على جميع أحفاد باخ: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! بدلا من استخدام خاصية \"الطفل\" للانتقال من باخ إلى أحفاده، فإننا نستخدم خاصيتي \"الأب\" و\"الأم\" للانتقال من الأحفاد إلى باخ، قد يشمل المسار أمين وأبا واحدا، أو أربعة آباء، أو أب أو أب-أم-أم-أب، أو أي مزيج آخر. (على الرغم من أن باخ بالطبع لا يمكن أن يكون أم لشخص ما، فإن العنصر الأخير سيكون دائما الأب). التصفيات (الخبر السار أولا: لا يقدم هذا القسم أية صيغة سباركل إضافية - نعم! خذ نفسا سريعا واسترخِ، يجب أن يكون هذا جزءا من الكعكة، أليس كذلك؟)حتى الآن، تحدثنا فقط عن بيانات بسيطة: الموضوع، والخاصية، والموضوع، لكن بيانات ويكي بيانات أكثر من ذلك: يمكن أن تكون لها أيضا مؤهلات ومراجع، على سبيل المثال، للموناليزا (Q12418) ثلاثة بيانات made from material (P186): oil paint (Q296955): المادة الرئيسية poplar wood (Q291034)، مع المؤهل applies to part (P518)painting support (Q861259) : هذه هي المادة التي رُسِمت عليها الموناليزا wood (Q287)، مع المؤهلات applies to part (P518)stretcher (Q1737943) وstart time (P580) 1951 : هذا جزء تمت إضافته إلى اللوحة لاحقا. لنفترض أننا نريد للعثور على جميع اللوحات مع سطح اللوحة، وهذا هو، وبيانات made from material (P186) تلك مع تصفية applies to part (P518)painting support (Q861259) ، كيف نفعل ذلك؟ هذه معلومات أكثر مما يمكن تمثيله في ثلاثية واحدة.الجواب هو: المزيد من الثلاثيات! (حكم التصفح: حل ويكي بيانات لكل شيء تقريبا هو \"المزيد من العناصر\"، وقاعدة خدمة استعلام ويكي بيانات المقابلة هي \"المزيد من الثلاثيات\"، المراجع، الدقة الرقمية، القيم بالوحدات، الإحداثيات الجغرافية، وما إلى ذلك، كل شيء نحن نخطوه هنا، كما نعمل مثل هذا.) حتى الآن، استخدمنا البادئة wdt: في ثلاثيات بياننا، والتي تشير مباشرة إلى هدف البيان، ولكن هناك أيضا بادئة أخرى: p:، والتي لا تشير إلى الكائن، بل إلى عقدة بيان، هذه العقدة إذن موضوع ثلاثيات أخرى: البادئة ps: (pللخاصيةsبيان) تشير إلى كائن البيان، والبادئة pq: (pخاصيةqمؤهل) للمؤهلات، وprov:wasDerivedFrom تشير إلى عقد مرجعية (والتي سنتجاهلها الآن).كان ذلك كثيرا من النص المجرد، إليك مثال ملموس للموناليزا: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) يمكننا اختصار هذا كثيرا باستخدام بناء الجملة [] ، واستبدال المتغيرات ?statement: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. هل يمكنك استخدام هذه المعرفة لكتابة استعلام عن كل اللوحات مع سطح لوحاتها؟ها هو الحل الخاص بي: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! أولا، نحدد ?painting لجميع حالات painting (Q3305213) أو فئة فرعية منها، بعد ذلك، نستخرج المادة من عقدة البيان p:P186، مع تحديد البيانات لتلك التي تحتوي على مؤهل applies to part (P518)painting support (Q861259) . ORDER وLIMIT نعود إلى برنامجنا المنتظم المقرر لميزات سباركل.حتى الآن، كانت لدينا فقط استعلامات حيث كنا مهتمين بجميع النتائج، ولكن من الشائع جدا ألا نهتم إلا بعدد قليل من النتائج: تلك الأكثر تطرفا بطريقة أو بأخرى - أقدمها، وأعلاها، وأحدثها وأعلاها سكانا، وأقلها في نقطة الانصهار والأكثر أطفالا والمواد والأكثر استخداما وما إلى ذلك، العامل المشترك هنا هو أن النتائج مصنفة بطريقة ما، ثم نهتم بالنتائج القليلة الأولى (تلك التي تحتوي على أفضل رتبة).يتم التحكم في هذا عن طريق جملتين، يتم إلحاقهما بكتلة WHERE {} (بعد الأقواس وليس داخلها!): ORDER BY وLIMIT.ORDER BY something يفرز النتائج حسب something. something يمكن أن يكون أي تعبير، في الوقت الحالي، النوع الوحيد من التعبيرات التي نعرفها هي متغيرات بسيطة (?something)، لكننا سنرى بعض الأنواع الأخرى في وقت لاحق، يمكن أيضا تغليف هذا التعبير إما في ASC() أو DESC() لتحديد ترتيب الفرز (إنهاء تصاعدي'أو إنهاء تنازلي). (إذا لم تقم بتحديد أي منهما، فسيكون الإعداد الافتراضي هو الفرز التصاعدي; لذ ASC(something) يساوي فقط something.)LIMIT count يقطع قائمة النتائج في نتائج count، حيث count هو أي رقم طبيعي، على سبيل المثال، LIMIT 10 يحد الاستعلام إلى عشر نتائج، LIMIT 1 فقط يعرض نتيجة واحدة.(يمكنك أيضا استخدام LIMIT بدون ORDER BY، وفي هذه الحالة، لا يتم فرز النتائج; لذلك ليس لديك أي ضمان للنتائج التي ستحصل عليها، وهو أمر جيد إذا عرفت أن هناك عددا معينا من النتائج، أو كنت مهتما فقط ببعض النتائج، ولكن لا يهمك أي منها، وفي كلتا الحالتين، إضافة LIMIT يمكنها تسريع الاستعلام بدرجة كبيرة; حيث يمكن لخدمة استعلام ويكي بيانات التوقف عن البحث عن النتائج بمجرد العثور على ما يكفي لملء الحد.)وقت التمرين! حاول كتابة استعلام يُرجِع الدول العشر الأكثر اكتظاظا بالسكان. (البلد هو sovereign state (Q3624078)، والخاصية الخاصة بالسكان هي P:P1082)، يمكنك البدء بالبحث عن البلدان مع سكانها، ثم إضافة عبارتي ORDER BY وLIMIT clauses.ها هو الحل الخاص بي: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! لاحظ أنه إذا كنا نريد البلدان الأكثر سكانا، فعلينا أن نطلبها من خلال عدد السكان الهابط، بحيث تكون النتائج الأولى هي التي تحتوي على أعلى القيم. تمرين لقد غطينا الكثير من الأرض حتى الآن - أعتقد أن الوقت قد حان لبعض التمارين. (يمكنك تخطي هذا القسم إذا كنت في عجلة من أمرك). كتب آرثر كونان دويل اكتب استعلاما يعيد جميع الكتب بواسطة السير آرثر كونان دويل. تلميح العناصر والخصائص ذات الصلة هي: Arthur Conan Doyle (Q35610)، author (P50). مثال الحل SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  العناصر الكيميائية اكتب استعلاما يقوم بإرجاع جميع العناصر الكيميائية برمز عنصرها ورقمها الذري، حسب رقمها الذري. تلميح العناصر والخصائص ذات الصلة هي: chemical element (Q11344)، element symbol (P246)، atomic number (P1086). مثال الحل SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  الأنهار التي تتدفق إلى المسيسيبي اكتب استعلاما يعيد جميع الأنهار التي تتدفق مباشرةً إلى نهر المسيسيبي. (يتمثل التحدي الرئيسي في العثور على الخاصية الصحيحة...) تلميح العناصر والخصائص ذات الصلة هي: Mississippi River (Q1497)، mouth of the watercourse (P403). مثال الحل SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  الأنهار التي تتدفق إلى الميسيسيبي 2 اكتب استعلامًا يعيد جميع الأنهار التي تتدفق إلى نهر المسيسيبي، بشكل مباشر أو غير مباشر. تلميح هذا الاستعلام مطابق تقريبا للاستعلام السابق، الفرق هو أنك ستحتاج في هذه المرة إلى مسار بدلا من ثلاثية. (إذا تخطيت القسم حول المسارات، تخطى هذا التمرين أيضا.) مثال الحل SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL في التمرينات أعلاه ، كان لدينا استعلام عن جميع الكتب التي كتبها السير آرثر كونان دويل: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! لكن هذا ممل بعض الشيء، هناك الكثير من البيانات المحتملة عن الكتب، ونعرض التسمية فقط؟ لنحاول صياغة استعلام يتضمن أيضا title (P1476) وillustrator (P110) وpublisher (P123) وpublication date (P577).قد تبدو المحاولة الأولى كما يلي: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! قم بتشغيل هذا الاستعلام، كما أكتب هذا، فإنه لا يؤدي إلا إلى نتيجتين اثنين - هزيلة قليلا! لماذا هذا؟ وجدنا أكثر من مائة كتاب في وقت سابق!السبب هو أنه لمطابقة هذا الاستعلام; يجب أن تتطابق نتيجة محتملة (كتاب) مع جميع الثلاثيات المدرجة في القائمة: يجب أن يكون لها عنوان، ورسام، وناشر، وتاريخ نشر، إذا كان يحتوي على بعض هذه الخصائص، وليس كلها، فلن يتطابق، وهذا ليس ما نريده في هذه الحالة: نريد في المقام الأول قائمة بجميع الكتب، إذا توفرت بيانات إضافية، فنحن نرغب في تضمينها، لكننا لا نريد أن يحد ذلك من قائمة النتائج.الحل هو أن تخبر خدمة استعلام ويكي بيانات أن هذه الثلاثيات اختيارية: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! هذا يعطينا المتغيرات الإضافية (<،code>?title ?publisher الخ) إذا كان البيان المناسب موجودا، ولكن إذا لم يكن البيان موجودا، فلن يتم تجاهل النتيجة، المتغير ببساطة لم يتم ضبطه.ملاحظة: من المهم جدا استخدام عبارات OPTIONAL منفصلة هنا، إذا وضعت كل ثلاثة أضعاف في بند واحد، مثل هنا - SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! - ستلاحظ أن معظم النتائج لا تتضمن أية معلومات إضافية; ويرجع ذلك إلى أن هناك شرطا اختياريا يشتمل على ثلاثية متعددة لا يتطابق إلا عند استيفاء جميع هذه الثلاثية: وهذا يعني: إذا كان للكتاب عنوان، أو رسام، أو ناشر، أو تاريخ نشر، فإن الجملة الاختيارية تتطابق، ويتم تعيين تلك القيم للمتغيرات المناسبة، ولكن إذا كان للكتاب، على سبيل المثال، عنوان لكن بدون رسام، فإن الجملة الاختيارية لا تتطابق، وعلى الرغم من عدم التخلص من النتيجة، تظل جميع المتغيرات الأربعة فارغة. تعبيران: FILTER وBIND قد يبدو هذا القسم أقل تنظيما بقليل من الأخرى; لأنه يغطي موضوعا واسعا ومتنوعا إلى حد ما، المفهوم الأساسي هو أننا نرغب الآن في القيام بشيء مع القيم التي قمنا حتى الآن باختيارها وإعادتها عشوائيا، والتعبيرات هي طريقة التعبير عن هذه العمليات على القيم، هناك العديد من أنواع التعبيرات، والكثير من الأشياء التي يمكنك القيام بها معها، ولكن أولا، لنبدأ بالأساسيات: أنواع البيانات. أنواع البيانات كل قيمة في سباركل لها نوع، والتي تخبرك ما هو نوع القيمة وما يمكنك القيام به، أهم الأنواع هي: بند، مثل wd:Q42 لDouglas Adams (Q42). قيمة منطقية، مع القيمتين الممكنتين true وfalse، لا يتم تخزين القيم المنطقية في بيانات، ولكن العديد من التعبيرات تعرض قيمة منطقية، مثل 2 < 3 (true) أو \"a\" = \"b\" (false). سلسلة، جزء من النص، تتم كتابة القيم الحرفية السلسلة في علامتي تنصيص. نص أحادي اللغة، سلسلة بوسم لغة مرفق، في الحرفية، يمكنك إضافة وسم اللغة بعد السلسلة ذات @، مثل \"Douglas Adams\"@en. الأرقام، إما أعداد صحيحة (1) أو أرقام عشرية (1.23). تواريخ، يمكن كتابة القيم الحرفية للتاريخ من خلال إضافة ^^xsd:dateTime (حساسة للأحرف – ^^xsd:datetime لن تعمل!) إلى سلسلة تاريخ ايزو 8601: \"2012-10-29\"^^xsd:dateTime. (لا يدعم ويكي بيانات الطوابع الزمنية ذات الساعات والدقائق والثواني، إلخ.)  المشغلون تتوفر عوامل التشغيل الرياضية المعروفة: +، -، *، / لإضافة، أو طرح، أو ضرب، أو قسمة الأرقام، <، >، =، <=، >= لمقارنتها، تتم كتابة اختبار عدم المساواة ≠ !=، يتم تعريف المقارنة لأنواع أخرى، على سبيل المثال، \"abc\" < \"abd\" صحيح (مقارنة معجمية)، مثل \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime وwd:Q4653 != wd:Q283111 ويمكن دمج الشروط المنطقية مع && (منطقي و: a && b صحيح إذا كان كل من a وb صحيحين) و|| (منطقي أو: a || b صحيح إذا كان كل (أو كلاهما) a وb صحيحين). FILTER معلومات For a sometimes faster alternative to FILTER, you might also look at MINUS, see example.FILTER(condition). هي جملة يمكنك إدراجها في استعلام سباركل الخاص بك، حسنا، قم بتصفية النتائج، داخل الأقواس، يمكنك وضع أي تعبير من النوع المنطقي، ويتم استخدام تلك النتائج فقط التي يتم فيها إرجاع التعبير true.على سبيل المثال، للحصول على قائمة بجميع البشر الذين ولدوا في عام 2015; نحصل أولا على جميع البشر بتاريخ ميلادهم - SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} - ثم قم بتصفية ذلك لإرجاع النتائج فقط حيث يكون تاريخ الميلاد هو عام 2015، هناك طريقتان للقيام بذلك: استخراج سنة التاريخ مع الدالة YEAR، واختبار تلك أنها 2015 - FILTER(YEAR(?dob) = 2015). - أو تحقق من أن التاريخ ما بين 1 يناير (شامل) و2015 و1 يناير 2016 (حصري): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). أود أن أقول أن أول الأول أكثر وضوحا، ولكن تبين أن الثاني أسرع بكثير; لذلك دعونا نستخدم ذلك: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! يرتبط الاستخدام المحتمل الآخر لـFILTER بالتسميات، خدمة التسمية مفيدة للغاية إذا كنت تريد فقط عرض تسمية متغير، ولكن إذا كنت ترغب في القيام بالأشياء مع التسمية - على سبيل المثال: تحقق مما إذا كانت تبدأ بـ\"السيد\"، ستجد أنها لا تعمل: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. لحسن الحظ; ليست خدمة التسمية هي الطريقة الوحيدة للحصول على تسمية العنصر، يتم تخزين التسميات أيضا على شكل ثلاثيات منتظمة، باستخدام المحمول rdfs:label، بالطبع، هذا يعني جميع التسميات، وليس فقط الإنجليزية، إذا كنا نرغب في الحصول على تسميات باللغة الإنجليزية فقط، فسنضطر إلى تصفية لغة التسمية: FILTER(LANG(?label) = \"en\"). تقوم الدالة LANG بإرجاع لغة سلسلة أحادية اللغة، وهنا نقوم فقط بتحديد تلك التسميات الموجودة بالإنجليزية، الاستعلام الكامل هو: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"السيد \")).
}
 Try it! نحصل على التسمية مع الثلاثي ?human rdfs:label ?label، ونقصره على التسميات الإنجليزية، ثم نتحقق مما إذا كان يبدأ بـ \"Mr.\".يمكن للمرء أيضا استخدام FILTER مع تعبير نمطي، في المثال التالي SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! إذا كان قيد تنسيق المعرف هو [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND، BOUND، IF غالبا ما يتم استخدام هذه الميزات الثلاثة بالتزامن; لذا سأشرح أولا كل ثلاثة منها، ثم أريك بعض الأمثلة.يمكن استخدام جملة BIND(expression AS ?variable). لتعيين نتيجة تعبير لمتغير (عادةً متغير جديد، ولكن يمكنك أيضا استبدال المتغيرات الموجودة).BOUND(?variable) يختبر إذا كان المتغير مرتبطا بقيمة (يعيد true أو false)، وهي مفيدة في الغالب على المتغيرات التي يتم تقديمها في جملة OPTIONAL.IF(condition,thenExpression,elseExpression) يقيم إلى thenExpression if condition يقيم إلى true وإلى elseExpression if condition يقيم إلى false، أي: IF(true, \"yes\", \"no\") يقيم إلى\"yes\" وIF(false, \"great\", \"terrible\") يقيم إلى \"terrible\".يمكن استخدام BIND لربط نتائج بعض الحسابات بمتغير جديد، يمكن أن يكون هذا نتيجة وسيطة لعملية حسابية أكبر أو كنتيجة مباشرة للاستعلام، على سبيل المثال، للحصول على سن ضحايا عقوبة الإعدام: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # أو، كتعبير واحد:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! يمكن أيضا استخدام BIND لربط قيم ثابتة للمتغيرات ببساطة لزيادة إمكانية القراءة، على سبيل المثال، استعلام يجد جميع الكاهنات: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! يمكن استبداله مثل هذا: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! الجزء المحتمل من الاستعلام، من ?woman to ?priest.، ربما أصبح الآن أكثر قابلية للقراءة، ومع ذلك، فإن كتلة BIND الكبيرة أمامها تشتيت للغاية; لذا يجب استخدام هذه التقنية باعتدال. (في واجهة مستخدم خدمة استعلام ويكي بيانات، يمكنك أيضا تمرير فأرتك فوق أي مصطلح مثل wd:Q123 أو wdt:P123 ورؤية التسمية والوصف للكيان; لذلك ?female أكثر قابلية للقراءة فقط من wd:Q6581072 إذا تجاهلت هذه الميزة.)يتم استخدام تعبيرات IF عادةً مع BOUND كالتعبير، على سبيل المثال، لنفترض أن لديك طلب استعلام يعرض بعض الأشخاص، وبدلا من إظهار تسميتم فقط، تود عرض pseudonym (P742) إذا كان لديهم واحدا، ولا يستخدمون إلا التسمية إذا كان الاسم المستعار غير موجوة، لهذا; يمكنك تحديد الاسم المستعار في جملة OPTIONAL (يجب أن يكون اختياريا، لا تريد التخلص من النتائج التي لا تحتوي على اسم مستعار)، ثم استخدم BIND(IF(BOUND(… لتحديد الاسم المستعار أو التسمية. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! تشمل الخصائص الأخرى التي يمكن استخدامها بهذه الطريقة nickname (P1449) وposthumous name (P1786) وtaxon common name (P1843)، أي شيء يمكن أن يكون فيه نوع من \"الرجوع\" منطقي.يمكنك أيضا دمج BOUND مع FILTER للتأكد من أنه قد تم استيفاء كتلة واحدة على الأقل من عدة كتل OPTIONAL ، على سبيل المثال، دعنا نحصل على جميع رواد الفضاء الذين وصلوا إلى القمر، بالإضافة إلى أعضاء Apollo 13 (Q182252) (على مقربة كافية، أليس كذلك؟)، لا يمكن التعبير عن هذا التقييد كمسلك خاصية واحدة; لذلك نحتاج إلى جملة OPTIONAL لـ\"عضو في بعض مهمات القمر\" وأخرى لـ\"عضو في أبولو 13\"، لكننا نريد فقط تحديد تلك النتائج حيث يكون واحد على الأقل من تلك الشروط صحيحا. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE يمكن استخدام الدالة COALESCE function كاختصار للنمط BIND(IF(BOUND(?x), ?x, ?y) AS ?z). لردود الفعل المذكورة أعلاه: يستغرق عددا من التعبيرات ويعيد أول تعبير يتم تقييمه بدون أخطاء، على سبيل المثال، الاسم البديل \"الاسم المستعار\" أعلاه BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). يمكن استبداله بشكل أكثر إيجازا كـ BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). كما أنه من السهل إضافة تسمية احتياطية أخرى في حالة عدم تعريف ?writerLabel أيضا: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  التجمع حتى الآن، كانت جميع الاستعلامات التي رأيناها عبارة عن استعلامات وجدت جميع العناصر التي تستوفي بعض الشروط، في بعض الحالات، قمنا أيضا بتضمين بيانات إضافية حول هذا البند (اللوحات مع المواد، كتب آرثر كونان دويل مع العنوان والرسام).لكن من الشائع للغاية أننا لا نريد قائمة طويلة بجميع النتائج، بدلا من ذلك، قد نطرح أسئلة مثل هذه: كم عدد اللوحات التي رُسِمت على قماش / خشب الحور / إلخ؟ ما هو أعلى عدد سكان لكل بلد؟ ما هو العدد الإجمالي للبنادق التي تنتجها كل شركة مصنعة؟ من الذي ينشر، في المتوسط، أطول الكتب؟  سكان المدينة دعونا ننظر إلى السؤال الثاني في الوقت الحالي، من السهل كتابة طلب بحث يسرد جميع المدن جنبا إلى جنب مع سكانها وبلدها، مرتبة حسب البلد: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (ملاحظة: يقوم هذا الاستعلام بإرجاع الكثير من النتائج، مما قد يتسبب في مشكلة للمتصفح الخاص بك، قد ترغب في إضافة جملة LIMIT.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! لقد استبدلنا ORDER BY بـGROUP BY، تأثير هذا هو أن يتم تجميع كافة النتائج مع نفس ?country معا في نتيجة واحدة: هذا يعني أنه يجب علينا تغيير جملة SELECT أيضا، إذا احتفظنا بالجملة القديمة SELECT ?country ?city ?population، والتي ?city و?population سيتم إرجاعها؟ تذكر، هناك العديد من النتائج في هذه النتيجة واحدة، جميعها لديها نفس ?country; لذلك يمكننا تحديد ذلك، ولكن بما أنها يمكن أن تكون ?city و?population مختلفة، يجب أن تخبر خدمة استعلام ويكي بيانات أيا من هذه القيم لتحديدها، هذه هي دالة الدالة التجميعية، في هذه الحالة، استخدمناMAX: من بين جميع قيم ?population، نختار الحد الأقصى لنتيجة المجموعة. (يجب علينا أيضا أن نمنح هذه القيمة اسما جديدا ببنية AS، ولكن هذه مجرد تفاصيل بسيطة).هذا هو النمط العام لكتابة استعلامات المجموعة: كتابة استعلام عادي يقوم بإرجاع البيانات التي تريدها (لا يتم تجميعها، مع العديد من النتائج لكل \"مجموعة\")، ثم إضافة جملة GROUP BY وإضافة دالة تجميع لجميع المتغيرات غير المجمعة في جملة SELECT. مواد الطلاء دعونا نجربها بسؤال آخر: كم لوحة رُسِمت على كل مادة؟ أولا، قم بكتابة استعلام يقوم فقط بإرجاع كل اللوحات مع مواد رسمها. (يجب الحرص على استخدام بيانات made from material (P186) تلك فقط باستخدام مؤهل applies to part (P518)painting support (Q861259) .) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! عد ذلك، قم بإضافة عبارة GROUP BY على ?material، ثم دالة تجميعية على المتغير المحدد الآخر (?painting)، في هذه الحالة، نحن مهتمون بعدد اللوحات، الدالة التجميعية لذلك COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! مشكلة واحدة في هذا هي أننا لا نملك التسمية الخاصة بالمواد، وبالتالي فإن النتائج غير مناسبة للتفسير، إذا أضفنا فقط متغير التسمية، فسنحصل على خطأ: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate \"مجموع سيء\" هي رسالة خطأ قد تشاهدها كثيرا عند التعامل مع استعلامات المجموعة، وهي تعني أن أحد المتغيرات المحددة يحتاج إلى دالة تجميعية ولكنه لا يحتوي على دالة واحدة، أو أن لديه دالة مجمعة ولكن ليس من المفترض أن تكون له دالة واحدة، في هذه الحالة، تعتقد خدمة استعلام ويكي بيانات أنه قد تكون هناك ?materialLabel متعددة لكل ?material (على الرغم من أننا نعلم أن ذلك لا يمكن أن يحدث)، وبالتالي فإنه يشكو من أنك لا تحدد وظيفة تجميعية لهذا المتغير.أحد الحلول هو التجميع على عدة متغيرات، إذا قمت بإدراج متغيرات متعددة في جملة GROUP BY ، فستكون هناك نتيجة واحدة لكل مجموعة من هذه المتغيرات، ويمكنك تحديد كل هذه المتغيرات بدون دالة مجمعة، في هذه الحالة، سنقوم بجمع كل من ?material و?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! لقد انتهينا تقريبا من الاستعلام، مجرد تحسين واحد آخر: نود أن نرى المواد الأكثر استخداما أولا، لحسن الحظ; يُسمَح لنا باستخدام المتغيرات الجديدة المجمعة من جملة SELECT (هنا، ?count) في جملة ORDER BY ; لذلك هذا بسيط جدا: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! كتمرين، لنقم بإجراء الاستعلامات الأخرى أيضا. البنادق حسب الشركة المصنعة ما هو العدد الإجمالي للأسلحة المنتجة من قبل كل مصنع؟ تلميح العناصر والخصائص ذات الصلة هي: firearm (Q12796)، manufacturer (P176)، total produced (P1092). مثال الحل SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?produced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  الناشرون حسب عدد الصفحات ما متوسط (الوظيفة: AVG) عدد صفحات الكتبلكل ناشر؟ تلميح العناصر والخصائص ذات الصلة هي: publisher (P123)، number of pages (P1104). مثال الحل SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING إضافة صغيرة لهذا الاستعلام الأخير: إذا نظرت إلى النتائج، قد تلاحظ أن أعلى نتيجة لها معدل كبير شنيع، أكثر من عشرة أضعاف المركز الثاني يكشف جزءً من التحقيق أن هذا يرجع إلى أن الناشر (UTET (Q4002388)) نشر كتابا واحدًا فقط مع بيان number of pages (P1104)، Grande dizionario della lingua italiana (Q3775610)، والذي يؤدي إلى تحريف النتائج قليلا، لإزالة القيم الخارجية من هذا القبيل; يمكننا محاولة تحديد الناشرين الذين نشروا كتابين على الأقل مع بيانات number of pages (P1104) في ويكي بيانات.كيف نفعل ذلك؟ عادةً، نقوم بتقييد النتائج باستخدام جملة FILTER ، ولكن في هذه الحالة، نريد تقييدها استنادا إلى المجموعة (عدد الكتب)، وليست أية نتيجة فردية، يتم هذا باستخدام جملة HAVING ، التي يمكن وضعها مباشرة بعد جملة GROUP BY وتحدث تعبيرا مثل FILTER: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  ملخص الدالات التجميعية فيما يلي ملخص قصير للوظائف التجميعية المتاحة: COUNT: عدد العناصر، يمكنك أيضا كتابة COUNT(*) لحساب جميع النتائج ببساطة. SUM، AVG: مجموع أو متوسط جميع العناصر، على التوالي، إذا لم تكن العناصر أرقاما، فستحصل على نتائج غريبة. MIN، MAX: القيمة الدنيا أو القصوى لجميع العناصر، على التوالي، هذا يعمل لجميع أنواع القيم، يتم فرز الأرقام عدديا، والسلاسل والأنواع الأخرى بطريقة معجزة. SAMPLE: أي عنصر، هذا مفيد في بعض الأحيان إذا كنت تعرف أن هناك نتيجة واحدة فقط، أو إذا كنت لا تهتم بأي واحد يتم إرجاعه. GROUP_CONCAT: يربط جميع العناصر، نادرا ما يكون مفيدا، ولكن إذا كنت فضوليا، يمكنك البحث عنه في مواصفات سباركل. بالإضافة إلى ذلك، يمكنك إضافة معدل DISTINCT لأي من هذه الدوال لإزالة النتائج المكررة، على سبيل المثال، إذا كانت هناك نتيجتان لكن كليهما لهما نفس القيمة في ?var، عندها COUNT(?var) ستعيد 2 ولكن COUNT(DISTINCT ?var) سيعرض 1فقط، غالبا ما يتعين عليك استخدام DISTINCT عندما يمكن أن يقوم استعلامك بإرجاع نفس العنصر عدة مرات، يمكن أن يحدث هذا إذا كنت تستخدم، على سبيل المثال، ?item wdt:P31/wdt:P279* ?class ، وهناك مسارات متعددة من ?item إلى ?class: ستحصل على نتيجة جديدة لكل من هذه المسارات، على الرغم من أن جميع القيم في النتيجة متطابقة. (إذا كنت لا تجمع، يمكنك أيضا التخلص من هذه النتائج المكررة عن طريق بدء الاستعلام باستخدام SELECT DISTINCT بدلا من SELECT فقط.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS こと Wikidata Query Service は、Wikidata のコンテンツへの洞察を提供する強力なツールです。このガイドでは WDQS の使い方を説明します。interactive tutorial by Wikimedia Israel も参照してください。自分で SPARQL クエリを書く前に、{{Item documentation}}やその他の一般的な SPARQL クエリのテンプレートを調べて、その中にすでに書きたいクエリが含まれていないかどうか確認してください。 Contents 1 はじめる前に 2 SPARQLの基本 3 初めてのクエリ 3.1 自動補完 4 より進んだトリプルのパターン 5 インスタンスとクラス 5.1 プロパティパス 6 修飾子 7 ORDERとLIMIT 7.1 演習 7.1.1 アーサー・コナン・ドイルの本 7.1.2 化学元素 7.1.3 ミシシッピ川に流れ込む川 7.1.4 ミシシッピ川に流れ込む川 その2 8 OPTIONAL 9 式、FILTERとBIND 9.1 データ型 9.2 演算子 9.3 FILTER 9.4 BIND、BOUND、IF 9.5 COALESCE 10 グループ化 10.1 都市の人口 10.2 画材 10.3 メーカー別の銃 10.4 ページ数別の出版社 10.4.1 HAVING 10.5 集約関数の概要 10.6 wikibase:ラベルと集約 11 VALUES 12 Label in multiple languages 13 さらには… 14 関連項目 はじめる前に このガイドはとても長く威圧的に見えるかもしれませんが、どうか敬遠しないでください。SPARQLの基本を学ぶだけでも、かなりのことができるようになります。#初めてのクエリまでで読むのを止めたとしても、興味深いクエリをたくさん書くための知識としては十分です。さらにこのチュートリアルの各セクションを読めば、よりパワフルなクエリを書くことができるでしょう。WikidataやSPARQL、WDQSについて、これまでまったく聞いたことがない方のために、これらの用語について簡単に説明しておきましょう。 Wikidata は知識データベースです。「カナダの首都はオタワである」「モナリザはポプラの木に油絵の具で描かれている」「金の融点は1,064.18度である」といったような、何百万もの文から成ります。 SPARQL は知識データベースに対して定式化された質問（クエリ）を行うための言語です。適切なデータベースとSPARQLクエリがあれば、「音楽のもっとも主要な調性は?」「もっとも多くの俳優に演じられたキャラクターは?」「血液型の分布は?」「今年パブリックドメインになる作家の作品は?」といった疑問に答えることができます。 WDQS こと Wikidata Query Service は、上のふたつを統合したものです。SPARQLクエリを入力すると、Wikidataのデータセットに対して検索を行い、その結果を表示します。  SPARQLの基本 シンプルなSPARQLクエリは次のようなものです。 SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT節にはクエリの結果として得たい変数を列挙します（変数はクエスチョン・マークで始まります）。WHERE節はそれらの変数に対する制約からなり、ほとんどの場合はトリプルの形をとります。Wikidata（および類似の知識データベース）のすべての情報は、トリプルの形で保存されています。クエリが実行されると、クエリサービスは得たいトリプルの制約を満たすような変数の値を知識データベース上に見つけようと試みます。そしてそのような変数の組み合わせが見つかるごとに、それをひとつの結果として返します。 トリプルは主語、述語、目的語を持つ文のように読むことができます(トリプルがピリオドで終わるのはそのためです)。 SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} このクエリの回答は、例えば “lemon” です。Wikidataでは、ほとんどのプロパティは “has” の性質を持つプロパティです。そのためこのクエリは以下のように書いてもいいでしょう。 SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} これは?fruit has color ‘yellow’ と読めます（?fruit is the color of ‘yellow’ ではありません — parent/child のような対になるプロパティのためにこれは心に留めておいてください）。しかしながら、WDQSの説明のためには、これはあまりいい例ではありませんでした。taste（〜な味がする）は主観的なので、Wikidataにはこれに対応するプロパティがないのです。代わりに、たいていの場合においては曖昧さのない、parent/child（親／子）の関係について考えてみましょう。 初めてのクエリ バロック音楽の作曲家、ヨハン・ゼバスティアン・バッハの、すべての子供を列挙したいものと考えてみてください。上のクエリで見たような擬似要素を使うとして、あなたならどんなクエリを書きますか？こんな感じのクエリを書いたのではないでしょうか。 SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # （注：‘#’ より後ろはすべてはコメントで、WDQSには無視されます。）
} あるいはこんなのや、 SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} こんなのかもしれませんね。 SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} 最初のふたつのトリプルは、?childは parent/father に Bach を持っていなければならない、と言っています。3つめのは、Bach はその子供に?childを持っていなければならない、と言っています。ここでは2つめのを採用することにしましょう。では、これを適切なWDQSクエリに変換するためには、あと何が必要でしょうか。ウィキデータでは、項目やプロパティを特定するために使われているのは、例えば「父親」（プロパティ）とか、「バッハ」（項目）とかいった、人間にわかりやすい名前ではありません。（これにはちゃんとした理由があります。「ヨハン・ゼバスティアン・バッハ」はドイツの画家の名前でもありますし、「バッハ」は人物の姓であるだけでなく、フランスの自治体や、火星のクレーターなどの名前でもあり、これらを指しているかもしれないからです。） 代わりに、ウィキデータの項目とプロパティには、識別子が割り当てられています。ある項目の識別子を見つけるには、項目を検索して、（例えば説明文などから）それらしいものが見つかったら、その Q ナンバーをコピーします。プロパティの識別子を見つけるのにも同じことを行いますが、単に検索窓に探している言葉を入力するのではなく、「P:探している言葉」と入力すれば、プロパティに限定して検索を行います。この検索の結果として、あの有名な作曲家のヨハン・ゼバスティアン・バッハは Q1339 であり、そしてある人物の父親を指定するプロパティは P:P22 であることがわかります。最後に忘れてはいけないのが、接頭辞をつけることです。単純なWDQSトリプルでは、項目にはwd:を、そしてプロパティにはwdt:を、その頭につけなければいけません。（ただしこれは値が決まっているときだけにしてください。変数に接頭辞をつけてはいけません。）これをまとめると、初めての正しいWDQSクエリが出来上がります。 SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! 「Try it!」のリンクをクリックすると、WDQSのページでクエリが実行されます。結果はどうなりましたか？ child wd:Q57225 wd:Q76428 … うーんこれはちょっとがっかりですね。識別子しか表示されていません。識別子をクリックすれば該当のWikidataのページを見ることはできるのですが（そこには人にわかりやすいラベルもあるのですが）、検索結果を見るのにもうちょっといい方法はないのでしょうか？はい、実はこれがあるんですね！（修辞疑問文ってすごいと思いませんか？）次の魔法の一文を WHERE 節のどこかに追加すると、 SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } するとクエリ中のすべての変数に対して、自動的にひとつの変数が追加されます。例えば?fooという変数には?fooLabelという変数が追加され、この変数には?fooを満たす項目のラベルの値が保持されます。この変数をSELECT節に追加すれば、項目とともにそのラベルも得ることができます。 SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! このクエリを実行してみてください。すると項目番号だけでなく、色々と子供の名前が表示されるはずです。 child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  自動補完 でもこのSERVICEから始まるコードを覚えとくのはしんどそうですよね？　それにクエリを書くたびに検索を繰り返すのもうんざりですよね。幸いなことに、WDQSにはこれに対する大いなる解決策、つまり「自動補完」が用意されています。クエリエディタ query.wikidata.org でクエリを書いている途中に、どこででもいいので Ctrl+Space を押すと、そこで入力するのにふさわしいコードの候補が表示されます。そこで適当な候補を up/down の矢印キーで選んでから、Enter キーを押して確定してください。たとえば、SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }と毎回毎回入力する代わりに、SERVとだけ入力して、Ctrl+Space キーを押せばいいんです。すると一番上の候補に、ラベル用のこの魔法の一文がバッチリ表示されているものと思います。準備は整いました！あとは Enter キーを押してこれを確定させるだけです。（入力されたコードのフォーマットは少しばかり違っているかもしれませんが、問題ありません。）自動補完では検索も可能です。wd:やwdt:のようなWikidataの節頭辞を入力したあとに、続けて何か文字を入力し、Ctrl+Space キーを押すと、Wikidataをこの文字で検索し、検索結果を候補として表示します。wd:なら項目を検索しますし、wdt:ならプロパティを検索します。たとえば、Johann Sebastian Bach (Q1339)とfather (P22)を検索して探す代わりに、wd:Bachとwdt:fathとだけ入力して、表示された候補の中から正しいものを選ぶだけでいいのです。（この機能は、wd:Johann Sebastian Bachのようにテキスト中にスペースがある場合でも有効です。） より進んだトリプルのパターン そういうわけで、いまはヨハン・ゼバスティアン・バッハのすべての子供をみたところでした。より具体的にいうと、父親としてヨハン・ゼバスティアン・バッハを持つすべての項目を得たところです。しかしバッハには妻が2人いましたので、これらの項目は2つの異なる母親を持っています。もしヨハン・ゼバスティアン・バッハの、最初の妻であるマリア・バルバラ・バッハ (Q57487) との間の子供だけをみたい場合は、どうしたらいいでしょうか？　上で書いたクエリをもとに、このクエリを書いてみましょう。できましたか？　オッケー、では解答をみていくことにしましょう。いちばんシンプルな方法は、制約に2つめのトリプルを追加することです。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 英語に直すと、これは次のように読むことができます。 Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. 少しばかり不自然に聞こえますね。自然言語であれば、これは次のように略されるでしょう。 Child has father Johann Sebastian Bach and mother Maria Barbara Bach. 実は、SPARQLでも同様に、同じ省略を表現することが可能です。ピリオドの代わりにセミコロン (;) でトリプルを終えると、別の述語 ｰ 目的語の組を追加することができます。これにより上のクエリを次のように略すことが可能です。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 結果は同じですが、クエリ中の繰り返しは減らすことができました。では、ここまでの結果に加えて、作曲家かつピアニストである子供にしか興味がないとしたらどうでしょうか。これに適したプロパティと項目は、occupation (P106)とcomposer (Q36834)、そしてpianist (Q486748)です。私の解答は次のようになります。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ここでは;を使った省略が、2つの必要な職業を追加するために、 さらに2回使われています。しかし、お気づきかもしれませんが、ご覧のようにここにもまだ繰り返しがあります。このコードだとあたかもこう言っているかのようです。 Child has occupation composer and occupation pianist. これを私たちは普通、こう略します。 Child has occupation composer and pianist. SPARQLにはこのためのシンタックスも同様にあります。;が述語と目的語の組をトリプルに追加することを（主語を再利用することによって）可能にしたのと同じように、,を使うことによって、別の目的語をトリプルに追加することが（主語と述語の双方を再利用することによって）可能になります。これによりクエリは次のように省略することができます。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 注：インデントやその他の空白は、実のところ重要ではありません。クエリがより読みやすくなるように、インデントしただけです。上のクエリは次のように書くことも可能です。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # 両方の職業を1行で
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! あるいは、だいぶ読みにくくはなりますが、次のようなのも可能です。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # インデントなし。これは ; と , の識別が難しくなる
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 幸いにもWDQSエディタは自動的に行をインデントしてくれますので、通常はこれを気にする必要はありません。さあ、ではここまでをまとめてみましょう。クエリは文章のように組み立てられることを見てきました。ある主語についてのトリプルは、それぞれがピリオドで終わります。同じ主語についての複数の述語は、セミコロンで区切られます。そして、同じ主語と述語に対する複数の目的語は、コンマで区切って列挙することが可能です。 SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} ここでSPARQLで使用可能なもうひとつの省略形を紹介したいと思います。いまいちど仮定のお話におつきあい願うことになりますが…本当はバッハの子供には関心はなかったとしましょう。（いや、これはひょっとすると、仮定の話ではなかったかもしれませんね！）子供ではなく、その「孫」に（仮定的に）興味があったのでした。ここで厄介な問題がひとつあります。孫は父親がバッハの子供なのかもしれないし、母親がバッハの子供なのかもしれない。どちらでもありうるのです。父親と母親は別々のプロパティなので、これは面倒です。代わりにぐるっと、関係を逆転させてしまいましょう。ウィキデータには「子」というプロパティもあって（P:P40 です）、これは親が主語になって親から子への関係性になるのと同時に、子供の性別を区別しないのです。これを念頭に、バッハの孫を返すクエリを書いてみましょう。書けましたか？私の解答はこうです。 SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 自然言語に直せば、これは次のように読むことができます。 Bach has a child ?child. ?child has a child ?grandChild. ここでも、上の文章を短縮することを提案します。その上で、SPARQLではどうしたら同様の省略をすることができるかお見せしたいと思います。子供に関心がない場合には、実際にはどうするか考えてみてください。孫のことを話すときにしか変数を使わない、というのが答えです。そこで上の文は次のように略すことができるはずです。 Bach has as child someone who has a child ?grandChild. ここではバッハの子供が誰かを言う代わりに、単に “someone” と言いました。それが誰であるかには関心がないからです。しかし someone 'who' と言っておくことで、それについて引き続き言及することができます。つまり関係節を作ることができ、その節の中で “someone” について何かをいうことができるということです。（たとえば、he or she “has a child ?grandChild” という風に。）ある意味で、 “someone” は変数なのです。ただしこの修飾節の中でのみ有効な特別な変数で、さらに、それに明示的に言及することはしない変数です（“someone who is this and does that” とは言いますが、“someone who is this and someone who does that” とは言いません。それだと someone は別々の違う「誰か」になるからです。）SPARQLでは、これを次のように書くことができます。 SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 変数のあった場所に角括弧の組を使うことができ ([])、これが無名変数として機能します。角括弧の中では述語 - 目的語の組を指定することができ、これは通常のトリプルの後に;を置いた場合と同様です。しかしここでの暗黙的な主語は、角括弧が示すところの無名変数になります。（注：;の後とこれもまた同様に、セミコロンを置けばさらに述語 - 目的語の組を追加することができますし、コンマを置けば述語を共有する目的語をさらに追加することができます。）これでトリプル・パターンについては終わりです！　SPARQLについてさらに見ていきますが、自然言語との類似性が高いパートを終えるに当たって、その関係をもう一度まとめておきたいと思います。 自然言語 例 SPARQL 例 文 Juliet loves Romeo. ピリオド juliet loves romeo. 接続詞（節の） Romeo loves Juliet and kills himself. セミコロン romeo loves juliet; kills romeo. 接続詞（名詞の） Romeo kills Tybalt and himself. コンマ romeo kills tybalt, romeo. 関係節 Juliet loves someone who kills Tybalt. 角括弧 juliet loves [ kills tybalt ].  インスタンスとクラス 先に私は、ほとんどのWikidataプロパティは “has” 関係だといいました。has child（子供を持つ）、has father（父親を持つ）、has occupation（職業を持つ）、といったように。しかし時には（実際のところはしばしば）、それがなんで「ある」か（what something is）を話す必要があります。しかし実はそこにも2種類の関係があるのです。 Gone with the Wind is a film.（『風と共に去りぬ』は映画である） A film is a work of art.（映画は芸術作品である） 『風と共に去りぬ』は一つの特定の映画です。そこには特定の監督（ヴィクター・フレミング）がおり、具体的な上映時間（238分）があり、キャストメンバー表（クラーク・ゲーブル、ヴィヴィアン・リー、…）があり、といった具合です。一方で「映画」は一般的な概念です。個々の映画は監督や上映時間やキャストを持つことができますが、「映画」という概念それ自体は、どんな特定の監督も上映時間もキャストも持ちません。そして映画は芸術作品であり（a film is a work of art）、芸術作品は通常その作者を持ちますが、「映画」という概念自体は作者を持ちません。この概念の特定の「実例（インスタンス）」のみが、それを持ちます。この違いゆえに、Wikidataには “is”（〜である）を表すプロパティが2つ、つまり instance of (P31) と subclass of (P279) があるのです。『風と共に去りぬ』は「映画」というクラスの特定のインスタンスです。「映画」というクラスは、より一般的なクラスである「芸術作品」の下位クラス（より具体的なクラス。特殊化）です。この違いをはっきりさせるためには、ふたつの違った動詞を使ってみることが役に立ちます。それは「〜である」と「一種の〜である」です。もし「一種の〜である」を使うことができる場合は（例えば映画は「一種の芸術作品である」のように）、下位クラス、つまりより広いクラスを特殊化したものについて話していることになるので、subclass of (P279)を使うべきです。もし「一種の〜である」が使えない場合は（例えば『風と共に去りぬ』は「一種の映画である」という文章は意味を成しません）、特定の実例について話していることになるので、instance of (P31)を使うべきです。ではSPARQLクエリを書く際にこれが意味することは何でしょうか。それは、「具体的な個々の芸術作品すべて」を検索したい時には、それが「芸術作品」に直接分類されているものをすべて検索したところで、それだけでは十分ではない、ということです。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # 芸術作品に分類されているもの
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 私がこれを書いている2016年10月の時点では、上のクエリが返すのは2,815件の結果だけです。実際の芸術作品がこれより多いのは明らかです。問題は、このクエリの結果には、「芸術作品」ではなく「映画」にだけ分類されている『風と共に去りぬ』のような、そういった項目が欠けていることです。「映画」は「芸術作品」の下位クラスではあるのですが、SPARQLで検索するときには、これを考慮に入れて検索するよう明示的に指示しなければなりません。ひとつの可能な解決策としては、すでに触れた [] 構文を使うことがあります。『風と共に去りぬ』は「芸術作品」の下位クラスである何らかのクラスに分類される、と表現するのです（練習のために実際にこのクエリを書いてみてください）。しかしこれにも問題があります。 今度は「芸術作品」に直接分類されている項目が含まれなくなります。 また「芸術作品」の下位クラスであってもそれ以外の下位クラスに分類されている項目は含まれないままです。例えば「白雪姫」は「アニメ映画」に分類されていますが、これは「芸術作品」の下位クラスである「映画」のさらに下位クラスです。この場合、「下位クラス」であるという言明を2回繰り返さないと検索で到達することができません。しかし実際はこれは3回でもあり得ますし、4回や5回、いや何回でもあり得ます。 解決策はこうです。 ?item wdt:P31/wdt:P279* ?class ——これが意味するのは、itemはある一つのクラスclassに分類されるが、そのクラスはclassだけでなくその下位クラスであってもよく、さらにその下の下の、どれだけ下のクラスでもあってもよい、ということです。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # 芸術作品のあらゆる下位クラスに分類されているもの
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! （このクエリを実行することはお勧めしません。WDQSは（何とかかろうじて）このクエリを処理することはできますが、結果を表示をする際に、件数が多すぎてブラウザが落ちる可能性があるからです。）というわけで、すべての芸術作品、すべてのビル、すべての居留地を検索する方法がわかりました。魔法の呪文 wdt:P31/wdt:P279* を、適切な分類と一緒に使えばよいのです。このクエリではまだ説明していないSPARQLのワザも少しばかり使っていますが、ごく正直にいえば、それらのワザが役立つのはこの時ぐらいのものです。なのでWDQSを効果的に使うためにこの呪文の働きを理解する必要はありません。知りたい方のためにこの後すぐに説明しますが、でも次のセクションは飛ばして、wdt:P31/wdt:P279* だけ覚えておくか、必要な時にここからコピペしてもよいのです。 プロパティパス プロパティパスは、ふたつの項目をつなぐ複数のプロパティの経路（パス）を、ごく簡潔に書き記すための方法です。最もシンプルなパスは単一のプロパティからなります。これは通常のトリプル（3つ組）をつくります。 ?item wdt:P31 ?class. パスを構成する要素（プロパティ）を追加するにはスラッシュ (/) を使います。 ?item wdt:P31/wdt:P279/wdt:P279 ?class. これは以下の二つのいずれとも等しくなります。 ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. 練習として、先に出てきた「バッハの孫」のクエリを、この構文を使って書き直してみましょう。アスタリスク (*) をパス要素の後につけると、その要素のゼロ回以上の繰り返しが可能であることを意味します。 ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> もしパスに他の要素がなければ、?a something* ?bは?bが?a他の要素を挟まずにすぐ後ろに来ても良いことを表します。 プラス (+) はアスタリスクに似ていますが、1回以上の繰り返しを意味します。次のクエリはバッハの子孫をすべて探します: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! もしここでプラスの代わりにアスタリスクを使うと、クエリの結果はバッハ自身も含んでしまいます。疑問符 (?) はアスタリスクやプラスに似ていますが、0回か1回の繰り返しを意味します。バーティカルバー (|) をスラッシュの代わりに使ってパスを区切ることもできます。この場合、「または」を意味します。パスはどちらか片方のプロパティを使いますが、組み合わされることはありません。「または」は常に1要素のパスにマッチします。丸括弧 (()) でパスの要素や今まで紹介してきた構文の要素 (/|*+?) を囲むこともできます。次のようにして、別のやり方でバッハの子孫を探すことができます: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 「子」のプロパティを使う代わりに、「父」と「母」のプロパティを使いました。このパスは2人の母と1人の父、4人の父、父母母父というように、任意の組み合わせにマッチします。 (もちろん、バッハは誰かの母ではないので、最後の要素は常に父になります。) 修飾子 （最初に良い知らせです。このセクションでは新しく学ぶSPARQLの構文はありません。やったね。深呼吸して落ち着いて臨めば、きっとここは朝飯前です。いいですね？）今までのところは、主語・プロパティ・目的語といった、単純な文についてのみ話してきました。しかし、ウィキデータの文はそれだけでなく、修飾子 (qualifier) と 出典 (references) を持つことができます。例えば、モナリザ (Q12418) には、made from material (P186)の文が3つあります。 oil paint (Q296955)は、主要な材料です。 poplar wood (Q291034)には、applies to part (P518)painting support (Q861259) の修飾子がついています。これは、モナリザが描かれている面の材質です。 wood (Q287)には、applies to part (P518)stretcher (Q1737943) とstart time (P580) 1951の修飾子がついています。これは、作品に後で付け足された部分の材料です。 塗装面についての情報を持つすべての絵画作品を求めたいと仮定しましょう。つまり、made from material (P186) 文を持つすべての絵画作品で、かつその文には修飾子 applies to part (P518)painting support (Q861259) があるということです。これにはどうしたらいいでしょうか。単一のトリプルで表現できる以上の情報がそこにはあります。答えは「トリプルを増やす」です（経験から言えば、Wikidata における解決策のほとんどは「項目を増やす」であり、WDQS でそれに該当するのが「トリプルを増やす」です。出典、数値の精度、単位付きの値、地理座標など、ここでは触れないすべてにおいて、これは当てはまります）。これまで、文のトリプルの接頭辞として wdt: を使ってきました。これは文の目的語を直接指し示します。しかしそれ以外の接頭辞もあります。p: は目的語を指し示すのではなく、「ある文というノード」を指し示します。そしてこのノードが他のトリプルの主語になります。接頭辞 ps: (property statement の略です) は文を目的語として指し示します。接頭辞 pq: (property qualifier) は修飾子を指し示し、prov:wasDerivedFrom は出典というノード（ここでは触れません）を指し示します。抽象的な説明が続いてしまいました。モナリザを例に具体的な例を示します。 wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) [] シンタックスで ?statement 変数を置き換えることにより、次のように大幅に省略することができます。 wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. この知識を活かして、塗装面についての情報を持つすべての絵画作品を求めるクエリを書くことができますか？私の解答はこうです。 SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 最初に、?painting を painting (Q3305213) の実例として、もしくはそのサブクラスとして限定します。次に p:P186 文により素材の情報を抽出します。このとき、その文は、applies to part (P518)painting support (Q861259) 修飾子を持っている文に限定します。 ORDERとLIMIT さて、SPARQLの機能の紹介にもどります。これまで私達はマッチするすべての結果を取得するクエリを学んできました。ですが、数件だけとってきたいというシチュエーションはよくあるはずです。典型的には、一番突出している値をとってくるケース、例えば最も古い、最も若い、最も早い、最も新しい、最も人口が多い、最も低い融点、最も子供の人数が多い、最もよく使われた物質、などです。これらの共通項は結果が何らかの値で「順位付け」されているということです。したがって私達は一番最初の結果 (順位付けで一番になるような結果) だけ考えたいということです。これはWHERE {}の中括弧の後に書く2つの節によって達成されます。それがORDER BYとLIMITです。ORDER BY somethingは、somethingによって結果を並び替えます。somethingは任意の式です。今の所、私達が知っているのは単なる変数 (?something) だけですが、あとで他の式も見ることにします。この式はソートの順序を指定するためにASC()やDESC()で囲むことができます (それぞれ、昇順 ascending と降順 descending に対応します)。 (もしどちらも指定しなかった場合、デフォルトでは昇順にソートされます。つまり、ASC(something)はsomethingと一緒です。)LIMIT countは結果のリストをcount件に制限します。countには任意の自然数を指定することができます。例えば、LIMIT 10は結果を10件に制限し、LIMIT 1は一つの結果を返すようにします。(ORDER BYをつけずにLIMITを使うこともできます。この場合、結果は並び替えされていないので、マッチする結果の内どのような結果がヒットするかは保証されません。これはあなたがマッチする件数の上限を知っている場合や、個々の結果には興味がなくマッチする中で一部の結果にだけ興味がある場合には気にならないものでしょう。どちらのケースでも、LIMITはクエリの処理時間を大きく縮めます。それは、指定された件数の結果をWDQSが見つけると、検索を止めても良くなるからです。)エクササイズの時間です!最も人口の多い10の国を返すクエリを作成してみてください。(国はsovereign state (Q3624078)で、人口のプロパティはP:P1082です。)人口のある国を検索することから始めて、ORDER BY句とLIMIT句を追加できます。私の解答はこうです。 SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! 「最も人口の多い」国が必要な場合は、最初の結果が最も高い値を持つ国になるように、人口の「降順」で順序付ける必要があることに注意してください。 演習 ここまでで基礎の多くをカバーしましたので、ここで練習の時間をとりましょう。（急いでいる場合は、このセクションをスキップできます。） アーサー・コナン・ドイルの本 サー・アーサー・コナン・ドイルのすべての本を返すクエリーを作成します。 ヒント 関連する項目とプロパティ: Arthur Conan Doyle (Q35610), author (P50). 解答例 SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  化学元素 すべての化学元素とその元素記号および原子番号を、原子番号順に返すクエリーを作成します。 ヒント 関連する項目とプロパティ: chemical element (Q11344), element symbol (P246), atomic number (P1086). 解答例 SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  ミシシッピ川に流れ込む川 ミシシッピ川に直接流れ込むすべての川を返すクエリーを作成します。(主な課題は、正しいプロパティを見つけることです…) ヒント 関連する項目とプロパティ: Mississippi River (Q1497), mouth of the watercourse (P403). 解答例 SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  ミシシッピ川に流れ込む川 その2 ミシシッピ川に直接または間接的に流れ込むすべての川を返すクエリを記述します。 ヒント このクエリは、前のクエリとほとんど同じです。違いは、今回はトリプルではなくパスが必要なことです(パスに関するセクションをスキップした場合は、この練習もスキップしてください)。 解答例 SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL 上記の演習では、サー・アーサー・コナン・ドイルのすべての本を検索しました。 SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! しかしこれは少々退屈です。本に関するデータは他にもたくさんあるのに、タイトルだけを表示するなんて。そこでクエリを加工して、title (P1476)、illustrator (P110)、publisher (P123)、およびpublication date (P577)も含むようにしてみましょう。最初に書いてみたのはこんな感じになりました。 SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! クエリーを実行してみます。私がこれを書いた時点では、返ってきた結果は2つだけでした。少々残念な結果ですね。なぜこうなったのでしょうか。前は100冊以上の本が見つかったのに。その理由は、このクエリに一致するためには、結果（本）がここで列挙したすべてのトリプルに一致する必要があるためです。結果にはタイトル、イラストレーター、出版社、および出版日のすべてが含まれていなければなりません。これらのプロパティの一部が含まれていても、すべてが含まれていなければ、一致しません。しかしそれでは本来ここで欲しかったものにはなりません。まず欲しいのはすべての本のリストなのですから。追加のデータが利用可能であればそれも含めたいのですが、そのことで結果のリストを制限したくはないのです。解決策は、これらのトリプルが「オプション」であることをWDQSに伝えることです。 SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! これにより、該当する文が存在する場合は追加の変数（?title、?publisherなど）が得られますが、文が存在しない場合でも結果は破棄されません。単に変数が設定されないだけです。注意:ここでは、個別のOPTIONAL句を使用することが非常に重要です。すべてのトリプルを1つの句に入れると、次のようになります - SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! - ほとんどの結果には追加情報が含まれていません。これは、複数のトリプルを持つオプション句が一致するのは、これらのトリプルをすべて満たすことができる場合のみであるためです。つまり、ブックにタイトル、イラストレーター、発行者および発行日がある場合、オプション句は一致し、これらの値は適切な変数に割り当てられます。ただし、ブックにタイトルがあってもイラストレーターがいない場合などは、オプション句全体が一致せず、結果は破棄されませんが、4つの変数はすべて空のままです。 式、FILTERとBIND このセクションは、かなり広範で多様なトピックを扱っているため、他のセクションよりも少し整理されていないように思われるかもしれません。基本的な概念は、私たちが今まで無差別に選択して返してきた値を使って何かをしたいということです。そして、「式」は、値に対するこれらの操作を表現する方法です。式には多くの種類があり、それを使ってできることはたくさんありますが、まず、基本的なデータ型から始めましょう。 データ型 SPARQLの各値には型があり、その型によって、その値の種類と、その値を使って何ができるかがわかります。最も重要な型は次のとおりです。 項目。Douglas Adams (Q42)に対するwd:Q42など。 ブール型。とりうる値はtrueとfalseの2つです。ブール型の値である真偽値そのものは文には使われませんが、多くの式は真偽値を返します。例えば、2 < 3 (true)や\"a\" = \"b\" (false)など。 文字列型。テキストを構成する。文字列リテラルは二重引用符で括って書かれます。 単一言語文字列。言語タグ付きの文字列です。リテラルでは言語タグを文字列の後ろに@記号をつけて付加します。例：\"Douglas Adams\"@en 数値型。整数(1)もしくは小数(1.23)。 日付型。日付リテラルはISO 8601で書かれた日付文字列に^^xsd:dateTimeを付加することで書くことができます（大文字と小文字を区別します。^^xsd:datetimeは不正です）。例：\"2012-10-29\"^^xsd:dateTime  演算子 +、-、*、/を使用して数値を加算、減算、乗算、または除算したり、<、>、=、<=、>=を使用してそれらを比較したりできます。不等式テスト≠は!=と記述されます。比較は他のタイプにも定義されます。たとえば、\"abc\"<\"abd\"は真(字句比較)であり、\"2016-01-01\"^^xsd:dateTime>\"2015-12-31\"^^xsd:dateTimeおよびwd:Q4653!=wd:Q283111も同様です。また、ブール条件は&&(論理および:a&&bは、aとbの両方が真の場合に真)および(論理または:a bは、aとbのいずれか(または両方)が真の場合に真)と組み合わせることができます。 FILTER 情報 FILTERに代わるより高速な方法として、MINUSを参照することもできます。exampleを参照してください。FILTER(condition).は、結果をフィルタリングするためにSPARQLクエリに挿入できる句です。括弧内には、ブール型の任意の式を入れることができ、式がtrueを返す結果のみが使用されます。たとえば、2015年に生まれたすべての人間のリストを取得するには、まずすべての人間とその生年月日を取得します - SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} -そして、それをフィルタして、生年月日の年が2015である結果のみを返します。これを行うには、2つの方法があります。YEAR関数を使用して日付の年を抽出し、それが2015であることをテストします- FILTER(YEAR(?dob) = 2015). -または、日付が2015年1月1日（を含む）から2016年1月1日（を含まない）の間であることを確認します。 FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). 最初の方が簡単だと思いますが、2番目の方がはるかに高速であることがわかったので、それを使用しましょう。 SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! FILTERのもう1つの使用法は、ラベルに関連しています。ラベルサービスは、変数のラベルを表示するだけの場合に非常に便利です。しかし、ラベルを使って何かをしたい場合-例えば、「Mr.」で始まるかどうかをチェックしたい場合-それは機能しないことがわかります。 SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! このクエリはfictional human (Q15632617)のすべてのインスタンスを検索し、そのラベルが\"Mr.\"で始まるかどうかをテストします(STRSTARTSは\"string starts[with]\"の略で、STRENDSとCONTAINSもあります)。これが機能しない理由は、ラベルサービスがクエリ評価の非常に遅い段階で変数を追加するためです。?humanLabelでフィルタをかけようとした時点では、ラベルサービスはまだその変数を作成していません。幸いなことに、ラベルサービスはアイテムのラベルを取得する唯一の方法ではありません。ラベルは、述語rdfs:labelを使用して、通常のトリプルとしても保存されます。もちろん、これは英語のラベルだけでなく、すべてのラベルを意味します。英語のラベルだけが必要な場合は、ラベルの言語に基づいてフィルタする必要があります。 FILTER(LANG(?label) = \"en\"). LANG関数は単一言語文字列の言語を返します。ここでは、英語のラベルのみを選択します。完全なクエリは次のとおりです。 SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! ?human rdfs:label?labelトリプルを持つラベルを取得し、それを英語のラベルに制限し、それが「Mr.」で始まるかどうかをチェックします。正規表現でFILTERを使用することもできます。次に例を示します。 SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! IDのフォーマット制約が[A-Za-z][-.0-9A-Za-z]{1,}の場合: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! このように、特定の要素を除外することができます。 FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) フィルタを適用して、入力されていない要素を含めることができます。 FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND、BOUND、IF これらの3つの機能は、組み合わせて使用されることが多いので、最初に3つすべてを説明し、次にいくつかの例を示します。BIND(expression AS?variable).句を使用して、式の結果を変数(通常は新しい変数ですが、既存の変数を上書きすることもできます)に割り当てることができます。BOUND(?variable)は、変数が値にバインドされているかどうかをテストします(trueまたはfalseを返します)。これは主に、OPTIONAL句で導入された変数に役立ちます。IF(condition,thenExpression,elseExpression)は、conditionがtrueと評価された場合はthenExpressionと評価され、conditionがfalseと評価された場合はelseExpressionと評価されます。 つまり、IF(true,\"yes\",\"no\")は\"yes\"と評価され、IF(false,\"great\",\"terrible\")は\"terrible\"と評価されます。BINDは、いくつかの計算の結果を新しい変数にバインドするために使用できます。これは、より大きな計算の中間結果である場合もあれば、クエリの直接の結果である場合もあります。例えば、死刑の被害者の年齢を取得するには: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BINDは、読みやすさを向上させるために、定数値を変数に単純にバインドするためにも使用できます。たとえば、すべての女性聖職者を検索するクエリは次のようになります。 SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! は次のように書き直すことができます： SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ?womanから?priest.までのクエリの意味のある部分は、おそらくより読みやすくなりました。しかし、そのすぐ前にある大きなBINDブロックはかなり気が散るので、このテクニックは控えめに使用されるべきです。(WDQSユーザーインターフェイスでは、wd:Q123またはwdt:P123のような任意の用語の上にマウスを移動して、エンティティのラベルと説明を表示することもできます。したがって、?femaleは、その機能を無視した場合にのみwd:Q6581072よりも読みやすくなります。)IF式は、BOUNDで構築された条件式とともに使用されることがよくあります。たとえば、一部の人間を表示するクエリがあり、そのラベルを表示するだけでなく、ラベルがある場合はpseudonym (P742)を表示し、ペンネームが存在しない場合にのみラベルを使用するとします。そのためには、OPTIONAL句でペンネームを選択し(オプションである必要があります。ペンネームのない結果をスローアウトしたくはありません)、BIND(IF(BOUND(…)を使用して、ペンネームまたはラベルを選択します。 SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! この方法で使用できるその他のプロパティには、nickname (P1449)、posthumous name (P1786)、およびtaxon common name (P1843)が含まれます。これらは、何らかの「フォールバック」が意味をなすものです。BOUNDをFILTERと組み合わせて、いくつかのOPTIONALブロックの少なくとも1つが満たされていることを確認することもできます。たとえば、月に行ったすべての宇宙飛行士と、Apollo 13 (Q182252)のメンバー(十分に近いですよね?)を取得しましょう。この制限は単一のプロパティパスとして表現できないため、「月のミッションのメンバー」に対して1つのOPTIONAL節と、「アポロ13のメンバー」に対して別の節が必要です。ただし、これらの条件のうち少なくとも1つが真である結果のみを選択します。 SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE COALESCE関数は、前述のフォールバックのBIND(IF(BOUND(?x),?x,?y)AS?z).パターンの省略形として使用できます。この関数はいくつかの式を受け取り、エラーなしで評価された最初の式を返します。 たとえば、上記の「pseudonym」フォールバック BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). より簡潔に書くことができます。 BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). また、?writerLabelが定義されていない場合に別のフォールバックラベルを追加することも簡単です。 BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  グループ化 これまで見てきたクエリはすべて、何らかの条件を満たすすべての項目を求めるクエリでした。場合によっては、項目に関する文（絵画についてその画材、アーサー・コナン・ドイルの本についてそのタイトルとイラストレーター、など）を追加しました。しかしすべての結果を網羅した長いリストは不要なことも珍しくありません。代わりに必要なのは、次のような質問に対する答えかもしれないのです。 カンバス、ポプラの木…等に描かれた絵画作品の数はいくつか 各国ごとにその国内の都市のうちで人口が最も多いのはどの都市か 各メーカごとにその社で作られる銃の合計は何挺か 平均して最も長い本を出版している出版社はどこか  都市の人口 ここでは、2番目の質問を見てみましょう。すべての都市とその人口および国を国順にリストするクエリを作成するのは、非常に簡単です。 SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (注:このクエリは「多くの」結果を返すため、ブラウザに問題を引き起こす可能性があります。LIMIT句を追加することをお勧めします。)結果を国ごとに並べ替えているので、ある国に属するすべての都市は、結果の中で1つの連続したブロックを形成します。そのブロック内で最も高い人口を見つけるために、ブロックを「グループ」と考え、グループ内のすべての人口値を1つの値、つまり最大値に「集約」したいと思います。これは、WHEREブロックの下のGROUP BY句と、SELECT句の集約関数(MAX)で行われます。 SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! ORDER BYをGROUP BYに置き換えました。これにより、同じ?countryを持つすべての結果が1つの結果にグループ化されます。これは、SELECT句も変更する必要があることを意味します。前のままの句SELECT ?country ?city ?populationにしていた場合、どの?cityと?populationが返されるのでしょうか。ひとつのグループには多くの結果が含まれることを忘れないでください。それらはすべて同じ?countryを持つので、それを選択することはできますが、?cityと?populationに関しては、結果ごとに異なる可能性があります。WDQSにこれらの値の中からどれを選択するかを指示する必要があるのです。これが「集約関数」の仕事です。この例ではMAXを使用しました。この関数は、すべての?population値の中から、グループごとに最大の値を選択してくれます。（この値にはAS構文で新しい名前を付ける必要がありますが、これは細かい話になります。）これがグループクエリを記述するための一般的なパターンです。まず必要なデータ（グループ化されておらず、「グループ」ごとに多くの結果がある）を返す通常のクエリを記述してください。次にGROUP BY句を追加します。最後に、SELECT句の変数のうち、グループ化されないすべての変数に集約関数を追加してください。 画材 別の質問で試してみましょう。絵画の作品数をそこで使われた画材別に知りたいとしたら、どのようなクエリを書けばよいでしょうか。最初に、単にすべての絵画作品を、その作品の画材とともに返すクエリを作成します（made from material (P186)文にapplies to part (P518)painting support (Q861259) 修飾子をつけたものだけを使用するように注意してください）。 SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! 次に、?materialにGROUP BY句を適用し、さらにSELECT句でそれ以外の変数(?painting)に集約関数を適用します。ここでは絵画の作品数に関心がありますので、集約関数にCOUNTを使用します。 SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! ここでひとつ問題なのは、画材のラベルが取得されていないために、結果の解釈に少し不便であることです。以下のように単にラベル変数を追加しただけでは、エラーが発生します。 SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate \"Bad aggregate\"は、グループクエリを操作するときにおそらく頻繁に遭遇するエラーメッセージです。これが意味するのは、SELECT句の変数のひとつに集約関数が必要なのに存在しないか、または集約関数を期待されていない変数に集約関数があるかの、いずれかです。今回の場合は、WDQSは、?materialのグループごとに?materialLabelの値は複数存在するかもしれないと考えます(そうではないことは私たちにはわかっているのですが)。そのため、この変数に適用すべき集約関数が指定されていないよと苦情を述べているのです。ひとつの解決策は、複数の変数にまたがってグループ化してしまうことです。GROUP BY句に複数の変数を列挙した場合、それらの変数の組み合わせがひとつのグループになるので、それに対して返される結果に含まれるこれら変数の値はひとつに決まります。このため、これらの変数はすべて、集約関数なしでSELECT句に指定することができるようになります。今回の場合は、?materialと?materialLabelのふたつを以下のようにグループ化します。 SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! これでほぼクエリは出来上がりですが、もう1つだけ改善点があります。最もよく使用されている画材が最初に表示されるようにしたいということです。幸いなことに、SELECT句で新たに集約された変数（ここでは?count）は、ORDER BY句で使うことが許されています。そのため、改善するのは以下のように非常に簡単です。 SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! 練習として、別のクエリもやってみましょう。 メーカー別の銃 各メーカーが生産している銃のメーカーごとの総数はいくつでしょうか? ヒント 関連する項目とプロパティ: firearm (Q12796), manufacturer (P176), total produced (P1092) 解答例 SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  ページ数別の出版社 各出版社が出版している本の出版社ごとの平均ページ数は何ページでしょうか？（平均にはAVG関数が使えます） ヒント 関連する項目とプロパティ: publisher (P123), number of pages (P1104) 解答例 SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING 最後のクエリに関して補足です。実際にクエリを実行してみると、トップの出版社の平均ページ数は、2番目の出版社の10倍以上という法外な数字であることに気づくと思います。少し調べてみるとその訳がわかるのですが、この出版社（UTET (Q4002388)）が出版している本でページ数の文（number of pages (P1104)）があるのは、1冊だけ（Grande dizionario della lingua italiana (Q3775610)）しかありません。このことが結果を少しばかり歪めているのです。このような外れ値を取り除くために、少なくとも2冊以上、ページ数の文（number of pages (P1104)）のある本を出版している出版社だけを、Wikidataから選ぶようにしてみてはどうでしょうか。そのようにするにはどうしたらいいでしょうか？　通常、結果に限定を加えるためにはFILTER節を使います。しかし今回はひとつひとつの結果に基づいてではなく、グループ化された結果（本の冊数）に基づいて限定を加えたいのです。 これを実現するには、 GROUP BY節のすぐ後にHAVING節を置き、FILTERの時と同じように式を取ればよいのです。 SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  集約関数の概要 以下は集約関数（集計関数）の簡単な概要です。 COUNT: 要素の数。単に結果の数を知りたい場合はCOUNT(*)と書くことができます。 SUM, AVG: すべての要素の合計(SUM)と平均(AVG)。要素は数値でないと意味のある結果は得られません。 MIN, MAX: すべての要素の最小値(MIN)と最大値(MAX)。これらはすべてのデータ型で有効です。数値の場合は数の大小で、文字列とその他のデータ型の場合は辞書順でソートします。 SAMPLE: 任意の要素を返します。これは結果がひとつだけだとわかっている場合、もしくはどれもよいので結果をひとつ得られればよい場合に便利です。 GROUP_CONCAT: すべての要素を連結します。例えば、その項目に対して複数の文があるようなプロパティ、例えばある人物の職業などの情報を、ひとつの結果に丸ごと含めて得たい場合などに便利です。それぞれの職業は再グループ化して連結されるので、結果には複数の記述としてではなく、ただ1つの変数として表すことができます。より詳しく知りたい方は、SPARQL specificationを調べてみてください。 加えてこれらすべての関数において、結果の重複を除外するためにDISTINCT修飾子を付加することができます。例えば結果が2件返ってきたが?var変数の値がいずれも同じだった場合、COUNT(?var)は2を返しますが、COUNT(DISTINCT ?var)1を返します。クエリが同じ項目を複数回返す可能性があるときは、DISTINCTを使わなければならないことが多いでしょう。例えばクエリに?item wdt:P31/wdt:P279* ?classという文があり、かつ?itemから?classへ複数のパスが存在する場合が、そのような例になります。このときそれぞれのパスから新しく結果が返されますが、これらすべての結果の値は同一です。なおクエリでグループを使用していない場合は、クエリを単なるSELECTではなく、SELECT DISTINCTから始めることによっても、結果の重複を除外することができます。 wikibase:ラベルと集約 2つ以上の国で市民権を持つすべての学者をWikidat内に検索するような、以下のようなクエリでは、これらの国の名前は?citizenships列に表示されません。 select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! ?citizenshipsを表示するためには、次のように、明示的にこれら?personLabelと?citizenshipLabelの名前をwikibase:label サービスの呼び出しで挙げなければなりません。 """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, es una herramienta poderosa para proporcionar información sobre el contenido de Wikidata. Esta guía te enseñará cómo usarla. Mira también el tutorial interactivo de Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Antes de comenzar 2 Conceptos básicos de SPARQL 3 Nuestra primera query 3.1 Autocompletado 4 Funciones avanzadas 5 Instancias y clases 5.1 Propiedades y rutas 6 Calificadores 7 ORDER y LIMIT 7.1 Ejercicios 7.1.1 Libros de Arthur Conan Doyle 7.1.2 Elementos químicos 7.1.3 Ríos que desembocan en el Mississippi 7.1.4 Ríos que desembocan en el Mississippi II 8 OPCIONAL 9 Expresiones, FILTER y BIND 9.1 Tipos de datos 9.2 Operadores 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupación 10.1 Poblaciones de ciudades 10.2 Materiales de pintura 10.3 Armas por fabricante 10.4 Editores por cantidad de páginas 10.4.1 HAVING 10.5 Sumario de las funciones agregación 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 Y más allá… 14 Véase también Antes de comenzar Si bien esta guía puede parecer muy larga e intimidante, ¡no dejes que eso te asuste! El solo hecho de aprender los conceptos básicos de SPARQL te llevará lejos, incluso si dejas de leer después de #Nuestra primera query ya sabrás lo suficiente como para construir muchas consultas interesantes. Cada sección de este tutorial te permitirá crear consultas aún más complejas.Si nunca has oído hablar de Wikidata, SPARQL, o WDQS antes, aquí una breve explicación de estos términos: Wikidata es una base de datos de conocimiento. Contiene muchas declaraciones como \"la capital de Canadá es Ottawa\", o \"la Mona Lisa está pintada al óleo sobre madera de álamo\", o \"el oro tiene un punto de fusión de 1,064.18 grados Celsius\". SPARQL es un lenguaje para formular preguntas (consultas) para bases de datos de conocimiento. Con la base de datos adecuada, una consulta SPARQL podría responder a preguntas como \"¿cuál es la tonalidad más popular en la música?\" o \"¿qué personaje fue representado por la mayoría de los actores? o \"¿cuál es la distribución de los tipos de sangre? o \"¿qué obras pasaron a ser de dominio público este año?\" WDQS, el servicio de consulta de Wikidata, reúne ambas funciones: si escribes una consulta SPARQL, la ejecuta contra el conjunto de datos de Wikidata y te muestra el resultado.  Conceptos básicos de SPARQL Una consulta SPARQL sencilla tiene este aspecto: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La cláusula SELECT enumera las variables que deseas que se respondan (las variables comienzan con un signo de interrogación), y la cláusula WHERE contiene las restricciones, principalmente en forma de ternas. Toda la información en Wikidata (y bases de datos de conocimiento similares) se almacena en forma de terna; cuando se ejecuta una consulta, el servicio de consulta intenta completar las variables con valores reales para que las ternas resultantes aparezcan en la base de datos de conocimiento, y devuelve un resultado para cada combinación de variables que encuentra. Una terna se puede leer como una oración (por eso termina con un punto), con un \"sujeto\", un \"predicado\" y un \"objeto\": SELECT ?fruta
WHERE
{
  
?fruta tieneColor amarillo.
  ?fruta gusto agrio.
} Los resultados para esta consulta podrían incluir, por ejemplo, “limón”. En Wikidata, la mayoría de las propiedades se pueden leer como propiedades que comienzan con “tiene”, así que la consulta podría ser en su lugar: SELECT 
?fruta
WHERE
{
  
?fruta color amarillo.
  ?fruta gusto agrio.
} Lo cual se lee “?fruta tiene color ‘amarillo’” (no como “?fruta es de color ‘amarillo’” – ten esto en cuenta para los pares de propiedades como \"padre\" / \"niño\"!).Sin embargo, ese no es un buen ejemplo para WDQS. El gusto es subjetivo, por lo que Wikidata no tiene una propiedad para ello. En su lugar, pensemos en las relaciones entre padres e hijos, que en su mayoría son inequívocas. Nuestra primera query Supongamos que queremos enumerar a todos los hijos del compositor barroco Johann Sebastian Bach. Usando pseudo-elementos como en las consultas anteriores, ¿cómo escribirías esa consulta?Esperemos que tengas algo como esto: SELECT ?hijo
WHERE
{
  #  hijo \"tiene padre\" Bach
  ?hijo padre Bach.
  # (Nota: todo lo que se escribe después de un '#' es un comentario y es ignorado por WDQS.)
} O esto, SELECT ?hijo
WHERE
{
  # hijo \"tiene padre\" Bach 
  ?hijo papá Bach. 
} o esto, SELECT ?hijo
WHERE
{
  #  Bach \"tiene hijo\" hijo
  
Bach hijo ?hijo.
} Las primeras dos ternas dicen que el ?hijo debe tener el padre Bach; el tercero dice que Bach debe tener el hijo ?hijo. Vayamos con el segundo por ahora.Entonces, ¿qué queda por hacer para convertir esto en una consulta WDQS adecuada? En Wikidata, los elementos y las propiedades no se identifican con nombres legibles como \"padre\" (propiedad) o \"Bach\" (elemento). (Por una buena razón: \"Johann Sebastian Bach\" es también el nombre del pintor alemán, y \"Bach\" también puede referirse al apellido, o a la comuna francesa, o a cráter en Mercurio, etc.) En vez de nombres, a los elementos y propiedades de Wikidata se les asigna un identificador. Para encontrar el identificador de un elemento, buscamos el elemento y copiamos el número \"Q\" que corresponde al elemento que buscamos (lo podés identificar a partir de la descripción, por ejemplo). Para encontrar el identificador de una propiedad, hacemos lo mismo, pero buscamos \"P: término de búsqueda\" en lugar de solo el \"término de búsqueda\", lo que limita la búsqueda a las propiedades. Esto nos dice que el famoso compositor Johann Sebastian Bach es la Q1339, y la propiedad para designar al padre de un elemento es la P:P22.Por último pero no menos importante, necesitamos incluir los prefijos. Para las consultas de ternas simples, los items deberían tener como prefijo wd:, y las propiedades wdt:. (Esto solo aplica a valores fijos - las variables no tienen un prefijo)Juntando esto, llegamos a nuestra primera consulta WDQS: SELECT ?hijo
WHERE
{
# ?hijo padre Bach
  ?hijo wdt:P22 wd:Q1339.
}
 Try it! Haz clic en el enlace \"Pruébalo\", luego \"Ejecutar\" la consulta en la página WDQS. ¿Qué obtienes? Hijo wd:Q57225 wd:Q76428 … Bueno, eso es decepcionante. Acabamos de ver un listado con los identificadores (Q). Puedes hacer clic en ellos para ver su página en Wikidata (incluida la etiqueta legible por humanos), pero ¿no hay una mejor manera de ver los resultados?Bueno, ¡claro que la hay! (¿no son geniales las preguntas retóricas?) Solo tienes que incluir el texto mágico. SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } Dentro de la cláusula WHERE , puedes obtener variables adicionales: por cada variable ?foo en tu consulta, ahora también tienes una variable ?fooLabel, que contiene la etiqueta del elemento detrás de ?foo . Si agrega esto a la cláusula SELECT , obtendrás el artículo y su etiqueta: SELECT ?hijo ?hijoLabel
WHERE
{
# ?hijo padre Bach
  ?hijo wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Intente ejecutar la consulta nuevamente: deberías ver no solo las \"Q\" de los elementos, sino también los nombres de los distintos elementos. hijo hijoLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autocompletado El fragmento de SERVICE parece difícil de recordar, ¿verdad? Y pasar por la función de búsqueda todo el tiempo mientras escribimos la consulta también es tedioso. Afortunadamente, WDQS ofrece una gran solución para esto: \"autocompletar\". En el editor de consultas de query.wikidata.org, puedes presionar Ctrl+Space en cualquier punto de la consulta y obtener sugerencias para generar el código más apropiado; elige la sugerencia correcta con las teclas de flecha arriba / abajo , y presiona Enter para seleccionarla.Por ejemplo, en lugar de escribir SERVICE wikibase: label {bd: serviceParam wikibase: language \"en\". } cada vez que creas una consulta, puedes simplemente escribir SERV, presionar Ctrl+Space, ¡y la primera sugerencia será el conjuro completo del servicio de etiquetas, listo para usar! Simplemente presiona Enter para aceptarlo. (El formato será un poco diferente, pero eso no importa).El autocompletado también puede ayudarte en tus búsquedas. Si escribes uno de los prefijos de Wikidata, como wd: o wdt:, luego escribes el texto, por último presionas Ctrl + < kbd>Space buscará ese texto en Wikidata y sugerirá resultados. wd: busca elementos, wdt: busca propiedades. Por ejemplo, en lugar de buscar los elementos de Johann Sebastian Bach (Q1339) y father (P22), puedes escribir wd:Bach y wdt:padre y luego simplemente seleccionas la entrada correcta del autocompletado. (Esto funciona incluso con espacios en el texto, por ejemplo, wd: Johann Sebastian Bach ). Funciones avanzadas Ahora que hemos visto a todos los hijos de Johann Sebastian Bach, más específicamente: todos los items con el padre Johann Sebastian Bach. Pero Bach tenía dos esposas, y esos items tienen dos madres diferentes: ¿qué pasa si solo queremos ver a los hijos de Johann Sebastian Bach con su primera esposa, Maria Barbara Bach (Q57487)? Intenta escribir esa consulta, basada en la anterior.Listo? Bien, entonces vayamos a la solución! La forma más sencilla de hacerlo es agregar una segunda terna con esa restricción: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339.
  ?hijo wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En español, esto se lee cómo: El niño tiene padre Johann Sebastian Bach. El niño tiene madre Maria Barbara Bach. Suena un poco raro, no? En lengua natural, esto se abreviaría cómo: El niño tiene padre Johann Sebastian Bach y madre Maria Barbara Bach. De hecho, es posible expresar la misma abreviatura en SPARQL: si acabamos una terna con un punto y coma (;) en vez de un periodo (.), puedes añadir otro predicado-par de objeto. Esto nos permite abreviar la consulta de arriba de la siguiente manera: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Lo cual tiene los mismos resultados, pero menos repetición en la consulta.Ahora supongamos que, fuera de estos resultados, estamos interesados solo en aquellos hijos que también eran compositores y pianistas. Las propiedades pertinentes y los elementos son occupation (P106), composer (Q36834) y pianist (Q486748). ¡Prueba actualizar la consulta para añadir estas restricciones!Aquí mi solución: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Esta consulta utiliza la abreviatura ; dos veces más para agregar las dos ocupaciones requeridas. Pero como puedes notar, todavía hay algo repetitivo. Esto es como si dijéramos: El niño tiene como ocupación compositor y como ocupación pianista. Lo cual abreviaríamos normalmente así: El niño tiene como ocupación compositor y pianista. SPARQL también tiene sintaxis para ello: al igual que un ; te permite agregar un par-objeto de predicado a una terna (reutilizando el tema), una , te permite anexar otro objeto a una terna (reutilizando tanto el sujeto como el predicado). Con esto, la consulta puede abreviarse así: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Nota: la sangría y otros espacios en blanco no son realmente importantes- solo agregué los espacios a la consulta para que sea más legible. También puedes escribir esto como: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # ambas ocupaciones en una linea
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! o, algo menos legible: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # Ninguna sangría; lo hace duro de distinguir entre ; y ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Afortunadamente, el editor WDQS agrega las sangrías en las líneas automáticamente, así que normalmente no tienes que preocuparte por esto.Bien, hagamos un resumen. Hemos visto que las consultas están estructuradas como un texto. Cada terna sobre un tema se termina con un punto.. Múltiples predicados sobre el mismo sujeto están separados por punto y coma ;, y múltiples objetos para el mismo sujeto y predicado se pueden enumerar separados por comas ,. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Ahora quiero introducir una abreviatura más que ofrece SPARQL. Así que si me haces el favor de seguirme a un escenario hipotético más ...Supongamos que no estamos realmente interesados en los hijos de Bach. (¡Quién sabe, tal vez eso sea realmente cierto para ti!) Pero estamos interesados en sus nietos. (Hipotéticamente.) Hay una complicación aquí: un nieto puede estar relacionado con Bach a través de la madre o del padre. Esas son dos propiedades diferentes, lo cual es un inconveniente. Mejor cambiemos la relación: Wikidata también tiene una propiedad \"secundaria\", P:P40, que apunta de padre a hijo y es independiente del género. Con esta información, ¿puedes escribir una consulta que devuelva a los nietos de Bach?Aquí mi solución: SELECT ?nieto ?nietoLabel
WHERE
{
  wd:Q1339 wdt:P40 ?hijo.
  ?hijo wdt:P40 ?nieto.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En lengua natural, se lee: Bach tiene un hijo ?hijo. ?hijo tiene un hijo ?nieto. Una vez más, propongo que abreviemos esta oración, y luego quiero mostrarles cómo SPARQL admite una abreviatura similar. Observa cómo en realidad no nos importa el niño: no usamos la variable excepto para hablar sobre el nieto. Por lo tanto, podríamos abreviar la frase así: Bach tiene como hijo a alguien que tiene un hijo ?nieto. En lugar de decir quién es el hijo de Bach, solo decimos \"alguien\": no nos importa quién es. Pero podemos referirnos a ellos porque dijimos \"alguien quién'\": esto inicia una cláusula relativa, y dentro de esa cláusula relativa podemos decir cosas sobre \"alguien\" (por ejemplo, que él o ella \"tiene un hijo ?nieto”). En cierto modo, \"alguien\" es una variable, pero una especial que solo es válida dentro de esta cláusula relativa, y una a la que no nos referimos explícitamente (decimos \"alguien que es esto y hace eso\", no \"alguien que es esto y alguien que hace eso\"- son dos \"personas\" diferentes).En SPARQL, esto puede ser escrito así: SELECT ?nieto ?nietoLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?nieto ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Puedes usar un par de corchetes ([]) en lugar de una variable, los cuales actúan como una variable anónima. Dentro de los paréntesis, puedes especificar pares de objetos de predicado, como después de un ; después de una terna normal; el sujeto implícito es en este caso la variable anónima que representan los corchetes. (Nota: al igual que después de un ;, puedes agregar más pares de objetos de predicado con más puntos y coma ;, o más objetos para el mismo predicado con comas).Y eso es todo para patrones de ternas! Hay más en SPARQL, pero como estamos a punto de dejar las partes que son fuertemente análogas al lenguaje natural, me gustaría resumir esa relación una vez más: Lengua natural ejemplo SPARQL ejemplo oración Julieta ama Romeo. Punto Julieta ama Romeo '.' Conjunción (cláusula) Romeo ama Julieta 'y' se mata . Punto y coma Romeo ama Julieta ; mata Romeo. Conjunción (sustantivo) Romeo mata Tybalt 'y' él mismo. Coma Romeo mata tybalt, Romeo. Cláusula relativa Julieta ama a alguien quien mata Tybalt. Corchetes Julieta ama [ mata Tybalt ].  Instancias y clases Antes, dije que la mayoría de las propiedades en Wikidata \"tienen\" relación: \"tiene\" hijo, \"tiene\" padres, \"tiene\" ocupación. Pero a veces (de hecho, frecuentemente), necesitamos hablar acerca de algo que \"es. Pero de hecho, hay dos tipos de relaciones ahí: \"Lo que el viento se llevó\" es una película. Una película \"es\" una obra de arte. Lo que el viento se llevó es una película en particular. Tiene un director en particular (Victor Fleming), una duración específica (238 minutos), una lista de actores de reparto (Clark Gable, Vivien Leigh, ...), y así sucesivamente.Película es un concepto general. Las películas pueden tener directores, una duración y miembros del elenco, pero el concepto “película” como tal no tiene ningún director, duración o miembros del elenco en particular. Y aunque una película 'es' una obra de arte, y una obra de arte generalmente tiene un creador, el concepto de \"película\" en sí no tiene un creador, solo las \"instancias\" particulares de este concepto sí lo tienen.Esta diferencia es la razón por la que hay dos propiedades para \"es\" en Wikidata: instance of (P31) y subclass of (P279). Lo que el viento se llevó es un ejemplo particular de la clase \"película\"; la clase \"película\" es una subclase (clase más específica; especialización) de la clase más general \"obra de arte\".Para ayudarte a comprender la diferencia, puedes intentar usar dos verbos diferentes: \"es un\" y \"es un tipo de\". Si \"es un tipo de\" obra (por ejemplo, una película \"es un tipo de\" obra de arte), indica que estás hablando de una subclase, una especificación de una clase más amplia y debe usar subclass of (P279). Si \"es un tipo de\" no funciona (por ejemplo, la frase \"Lo que se llevó el viento\" es un tipo de \"película\" no tiene sentido), indica que está hablando de una instancia en particular y debe usar instance of (P31).Entonces, ¿qué significa esto cuando estamos escribiendo consultas SPARQL? Cuando queremos buscar \"todas las obras de arte\", no es suficiente buscar todos los elementos que son directamente ejemplos de \"obras de arte\": SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31 wd:Q838948. # instancia de obra de arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mientras escribo esto (octubre de 2016), la consulta solo arroja 2815 resultados, obviamente, ¡hay más obras de arte que eso! El problema es que esta consulta no arroja aquellos elementos como Lo que el viento se llevó , que es solo un ejemplo de \"película\", no de \"obra de arte\". \"Película\" es una subclase de \"obra de arte\", pero tenemos que decirle a SPARQL que lo tenga en cuenta al buscar.Una posible solución a esto es la sintaxis de [] de la que hablamos: Lo que el viento se llevó es una instancia de 'alguna' subclase de \"obra de arte\". (Para ejercicio, ¡intenta escribir esa consulta!) Pero todavía tiene problemas: Ya no incluimos elementos que son directamente ejemplos de obras de arte. Todavía nos faltan elementos que son ejemplos de alguna subclase de alguna otra subclase de \"obra de arte\", por ejemplo, Blancanieves y los siete enanitos es una película animada, la cual es una película, la cual es una obra de arte. En este caso, debemos seguir dos declaraciones de \"subclase de\", pero también pueden ser tres, cuatro, cinco, cualquier número en realidad. La solución: ?item wdt: P31/wdt:P279* ?class. Esto significa que hay una \"instancia de\" y luego cualquier número de declaraciones \"subclase de\" entre el elemento y la clase. SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31/wdt:P279* wd:Q838948. # instancia de cualquier subclase de obra de arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (No recomiendo ejecutar esta consulta. WDQS puede (apenas) manejarlo, pero tu navegador puede bloquearse al intentar mostrar los resultados porque hay demasiados).Ahora ya sabes cómo buscar todas las obras de arte, todos los edificios o todos los asentamientos humanos: solo tienes que escribir el encantamiento mágico wdt:P31/wdt:P279*, junto con la clase correspondiente. Este código utiliza algunas funciones SPARQL que no he explicado todavía, pero honestamente, este es casi el único uso relevante de esas funciones, por lo que no es necesario \"entender\" cómo funciona WDQS para usar WDQS de manera efectiva. Si quieres saberlo, te lo explicaré un poco, pero también puedes omitir la siguiente sección y memorizar o copiar + pegar wdt:P31/wdt:P279* desde aquí cuando necesites eso. Propiedades y rutas Cuando hablamos de \"rutas de propiedades\" nos referimos a la ruta de una propiedad entre dos elementos. La ruta más simple es solo una propiedad, la cual comúnmente tiene forma de terna: ?item wdt:P31 ?class. Puedes agregar elementos de ruta con una barra diagonal (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Esto es equivalente a cualquiera de las siguientes: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Ejercicio: reescribe la query de los \"nietos de Bach\" que hicimos anteriormente pero con esta sintaxis.Un asterisco (*) después de un elemento significa \"'cero' o más de este elemento\" ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> Si no hay otros elementos en la ruta, ?a algo* ?b significa que ?b también podría ser ?a directamente, con ningún elemento en la ruta entre ellos. Un signo más ( + ) es similar a un asterisco, pero significa \"'uno' 'o más de este elemento\". La siguiente consulta rastrea a todos los descendientes de Bach: SELECT ?descendiente ?descendienteLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendiente.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Si utilizamos un asterisco en vez de un más en este caso, los resultados de la consulta incluirían al mismo Bach.Un signo de interrogación (?) es similar a un asterisco o a un \"más\", pero significa \"\"cero o uno\" de este elemento\".Puedes separar las rutas de los elementos con una barra vertical (|) en vez de una barra inclinada; esto significa \"algún - o\": la ruta podría usar cualquiera de esas propiedades (pero no ambas).También puedes agrupar elementos de ruta entre paréntesis ( () ), y combinar libremente todos estos elementos de sintaxis (/|*+? ). Esto significa que otra forma de encontrar a todos los descendientes de Bach es: SELECT ?descendiente ?descendienteLabel
WHERE
{
  ?descendiente (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En lugar de usar la propiedad \"hijo\" para ir de Bach a sus descendientes, usamos las propiedades \"padre\" y \"madre\" para ir de los descendientes a Bach. El camino puede incluir dos madres y un padre, o cuatro padres, o padre-madre-madre-padre, o cualquier otra combinación. (Aunque, por supuesto, Bach no puede ser la madre de alguien, por lo que el último elemento siempre será el padre). Calificadores (Primero, las buenas noticias: ¡esta sección no introduce nuevas sintaxis de SPARQL! Así que tómate un pequeño respiro y relájate, esto debería ser muy sencillo.)Hasta ahora solo hemos hablado acerca de declaraciones simples: sujeto, propiedad, objeto. Pero las declaraciones de Wikidata son más que eso: una declaración también puede tener calificadores y referencias. Por ejemplo, la Mona Lisa (Q12418) tiene tres declaraciones para made from material (P186): oil paint (Q296955), material principal; poplar wood (Q291034), con el calificativo applies to part (P518)painting support (Q861259) – este es el material sobre el cual fue pintado el cuadro; y wood (Q287), con el calificativo applies to part (P518)stretcher (Q1737943) y start time (P580) 1951 – esta es una arte que fue agregada a la pintura más tarde. Supongamos que queremos encontrar todas las pinturas con sus respectivas superficies sobre las que fueron pintadas, es decir, aquellas made from material (P186) declaraciones con el calificativo applies to part (P518)painting support (Q861259) . ¿Cómo lo hacemos? Esto es más información de la que podemos representar en una terna simple.La respuesta es: ¡más ternas! (Regla de oro: La solución de Wikidata para la mayoría de las cosas es \"más elementos\", y la correspondiente regla para WDQS es \"más ternas\". Referencias, precisión numérica, unidades con valores, geolocalización, etc., todas estas nos las estamos salteando aquí, pero también funcionan de esta manera). Hasta ahora hemos usado el prefijo wdt: para nuestras declaraciones en ternas, las cuales señalan directamente al objeto de una declaración. Pero existe también otro prefijo: p:, el cual no señala al objeto, sino al \"nodo de declaración\". Este nodo es entonces el sujeto de otra terna: el prefijo ps: (para property -propiedad- statement -declaración-) señala al objeto de la declaración, el prefijo pq: (property -propiedad- qualifier -calificativo-) a los calificativos, y prov:wasDerivedFrom apunta a los nodos de referencias (los cuales no abordaremos ahora).Esto fue mucho texto en abstracto. Aquí vamos con un ejemplo más concreto para la Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Podemos abreviar mucho esto si utilizamos la sintaxis [], remplazando las variables ?item wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. ¿Puedes usar este conocimiento para escribir una consulta para todas las pinturas y que muestre el material de la superficie sobre la que fue pintada?Aquí mi solución: SELECT ?pintura ?pinturaLabel ?material ?materialLabel
WHERE
{
  ?pintura wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Primero, limitamos ?pintura a todas las instancias de painting (Q3305213) o subclase de la misma. Luego, obtenemos el material del nodo de declaración p:P186, limitando las declaraciones a aquellas que tienen un calificador applies to part (P518)painting support (Q861259) . ORDER y LIMIT Regresamos a nuestro programa establecido de más características SPARQL.Hasta ahora, solo hemos tenido consultas en las que estábamos interesados en todos los resultados. Pero es muy común que solo nos interesen algunos pocos resultados: los que son más extremos de alguna manera: la población más antigua, la más joven, la más antigua, la más alta, el punto de fusión más bajo, la mayoría de los niños, la mayoría de los materiales utilizados, etc. El factor común aquí es que los resultados están \"clasificados\" de alguna manera, y luego nos preocupamos por los primeros resultados (aquellos con la mejor clasificación).Esto se controla mediante dos cláusulas, que se agregan al bloque WHERE {} (después de las llaves, ¡no adentro!): ORDER BY y LIMIT.ORDER BY algo ordena los resultados por algo. algo puede ser cualquier expresión, por ahora, el único tipo de expresión que conocemos son variables simples (?algo), pero veremos algunos otros tipos más adelante. Esta expresión también puede incluirse en ASC() o DESC() para especificar el orden de clasificación ( 'asc' final o 'desc' ' 'finalizando). (Si no especifica ninguno de los dos, el valor predeterminado es orden ascendente, por lo que ASC(algo) es equivalente a solo algo).LIMIT count acorta la lista de resultados en count resultados, donde count es cualquier número. Por ejemplo, LIMIT 10 limita la consulta a 10 resultados. LIMIT 1 solo devuelve un único resultado.(También puedes usar LIMIT sin ORDER BY. En este caso, los resultados no se ordenan, por lo que no tiene ninguna garantía de qué resultados obtendrás. Lo cual está bien si sabes que solo hay un cierto número de resultados, o simplemente estás interesado en el resultado algún , pero no te importa cuál. En cualquier caso, agregando LIMIT puede acelerar significativamente la consulta, ya que WDQS puede detener la búsqueda de resultados tan pronto como se encuentre lo suficiente como para llenar el límite).¡Tiempo de ejercitar!. Intenta escribir una consulta que devuelva los diez países más poblados. (Un país es sovereign state (Q3624078), y la propiedad para la población es P:P1082). Puedes comenzar por buscar países con su población y luego agregar las cláusulas de ORDER BY y LIMIT.Aquí mi solución: SELECT ?país ?paísLabel ?población
WHERE
{
  ?país wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?población.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Tené en cuenta que si queremos saber los países más poblados, tenemos que ordenarlos por población descendente , para que los primeros resultados sean los que tengan los valores más altos. Ejercicios Hemos cubierto mucho terreno hasta ahora, creo que es hora de hacer algunos ejercicios. (Puedes saltarte esta sección si tienes prisa). Libros de Arthur Conan Doyle Escribe una consulta que arroje como resultado todo los libros de Sir Arthur Conan Doyle. Pista Las propiedades y declaraciones relevantes son : Arthur Conan Doyle (Q35610), author (P50). Ejemplo de solución: SELECT ?libro ?libroLabel
WHERE
{
  ?libro wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Elementos químicos Escribe una consulta que arroje como resultado todos los elementos químicos con sus respectivos símbolos y su número atómico, ordenados por su número atómico. Pista Las propiedades y declaraciones relevantes son: chemical element (Q11344), element symbol (P246), atomic number (P1086). Ejemplo de solución SELECT ?elemento ?elementoLabel ?símbolo ?número
WHERE
{
  ?elemento wdt:P31 wd:Q11344;
           wdt:P246 ?símbolo;
           wdt:P1086 ?número.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?número
 Try it!  Ríos que desembocan en el Mississippi Escribe una consulta que arroje como resultados todos aquellos ríos que desembocan en el río Mississippi. (El desafío principal es encontrar la propiedad correcta) Pista Las propiedades y declaraciones relevantes son : Mississippi River (Q1497), mouth of the watercourse (P403). Ejemplo de solución: SELECT ?río ?ríoLabel
WHERE
{
  ?río wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Ríos que desembocan en el Mississippi II Escribe una consulta que arroje como resultado a todos los ríos que desembocan en el río Mississippi, directa o indirectamente. Pista Esta consulta es casi idéntica a la anterior. La diferencia está en que ahora lo que necesitas es el \"camino\" en vez de la terna. (Si te salteaste la sección acerca de los \"caminos\", puedes saltear también este ejercicio). Ejemplo de solución SELECT ?río ?ríoLabel
WHERE
{
  ?río wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  OPCIONAL En uno de los ejercicios anteriores tuvimos una consulta acerca de todos los libros escritos por Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Pero es un poco aburrida. ¿Hay mucho potencial en la información sobre libros, y solamente mostramos las etiquetas?. Intentemos elaborar una consulta que incluya la title (P1476), illustrator (P110), publisher (P123) y la publication date (P577).Un primer intento debería verse como algo así: SELECT ?libro ?título ?ilustradorLabel ?editorialLabel ?fecha_de_publicación
WHERE
{
  ?libro wdt:P50 wd:Q35610;
        wdt:P1476 ?título;
        wdt:P110 ?ilustrador;
        wdt:P123 ?editorial;
        wdt:P577 ?fecha_de_publicación.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Ejecuta esta consulta. Mientras estoy escribiendo esto, la consulta solo me devuelve nueve resultados - bastante escaso, ¿por qué sucede esto si antes encontramos cientos de libros?La razón es que para coincidir con esta consulta, un resultado potencial (un libro) debe coincidir con todas las ternas que enumeramos: debe tener un título, un ilustrador, un editor y una fecha de publicación. Si tiene algunas de esas propiedades, pero no todas, no coincidirá. Y eso no es lo que queremos en este caso: principalmente queremos una lista de todos los libros; si hay datos adicionales disponibles, nos gustaría incluirlos, pero no queremos que eso limite nuestra lista de resultados.La solución es decirle a WDQS que aquellas ternas son \"opcionales\": SELECT ?libro ?título ?ilustradorLabel ?editorialLabel ?fecha_de_publicación
WHERE
{
  ?libro wdt:P50 wd:Q35610.
  OPTIONAL { ?libro wdt:P1476 ?título. }
  OPTIONAL { ?libro wdt:P110  ?ilustrador. }
  OPTIONAL { ?libro wdt:P123  ?editorial. }
  OPTIONAL { ?libro wdt:P577  ?fecha_de_publicación. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Esto nos da variables adicionales (?título, ?editorial) si existe la declaración apropiada, pero si la declaración no existe, el resultado no se descarta - la variable simplemente no está establecida.Nota: es muy importante usar la cláusula OPTIONAL separada aquí. Si pones todas las ternas en una sola cláusula, como aquí - SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! - notarás que la mayoría de los resultados no incluyen información adicional. Esto se debe a que una cláusula opcional con múltiples ternas solo coincide cuando todos esas ternas pueden satisfacerse. Es decir: si un libro tiene un título, un ilustrador, una editorial y una fecha de publicación, la cláusula opcional coincide y esos valores se asignan a las variables apropiadas. Pero si un libro tiene, por ejemplo, un título pero no un ilustrador, la cláusula opcional completa no coincide y, aunque el resultado no se descarta, las cuatro variables permanecen vacías. Expresiones, FILTER y BIND Esta sección puede parecer un poco menos organizada que las otras, porque cubre un tema bastante amplio y diverso. El concepto básico es que ahora nos gustaría hacer algo con los valores que, hasta ahora, hemos seleccionado y devuelto indiscriminadamente. Y las expresiones son la manera de expresar estas operaciones en valores. Hay muchos tipos de expresiones y muchas cosas que puedes hacer con ellas, pero primero, comencemos con lo básico: los tipos de datos. Tipos de datos Cada valor en SPARQL ttiene un tipo, el cual nos dice que clase de valor es y qué puedes hacer con él. Los \"tipos\" más importantes son: elemento, como wd:Q42 para Douglas Adams (Q42). booleano, con los dos valores posibles true y false. Los valores booleanos no estan guardados en las declaraciones, pero muchas expresiones nos devuelven valores booleanos, e.j. 2 < 3 (true) o \"a\" = \"b\" (false). cadena de caracteres (string), un fragmento de texto. La cadena de caracteres literal está escrita en comillas dobles. texto monolingüe , puedes agregar la etiqueta del lenguaje después de la cadena con el signo @, por ejemplo \"Douglas Adams\"@es. numeros, ya sean enteros (1) o decimales (1.23). fechas. Date literals pueden ser escritas agregando ^^xsd:dateTime (¡distingue mayúsculas de minúsculas – ^^xsd:datetime o no funcionará!) a ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. (Wikidata todavía no soporta marcas de tiempo con horas, minutos, segundos, etc.)  Operadores Tenemos disponible los operadores matemáticos familiares: +, -, *, / para sumar, restar, multiplicar o dividir números y <, >, =, <=, >= para compararlos. El test de desigualdad ≠ se escribe !=. Las comparaciones también están definidas para otros tipos de datos, por ejemplo, \"abc\" < \"abd\" es verdadero (comparación léxica), como también lo es \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime y wd:Q4653 != wd:Q283111. Condicionales booleanos pueden ser combinados con && (\"Y\" lógico: a && b es verdadero sí y solo sí a y b son verdaderos) y el || (\"O\" lógico: a || b es verdadero al menos a o b son verdaderos (o los dos).) FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example.FILTER(condición). es una cláusula que puedes insertar en tu consulta SPARQL para filtrar los resultados. Dentro de los paréntesis, puedes poner cualquier expresión de tipo booleano, y solo se utilizan aquellos resultados donde la expresión devuelve true.Por ejemplo, para obtener una lista de todos los seres humanos nacidos en 2015, primero necesitamos obtener a todos los seres humanos con su fecha de nacimiento. SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} - y luego filtrar que solo nos devuelva los resultados donde el año de nacimiento sea 2015. Hay dos cominos para esto: extraer el año de la fecha con la función YEAR FILTER(YEAR(?dob) = 2015). - o verifique que la fecha sea entre el 1 de enero st (incluido), 2015 y el 1 de enero st, 2016 (exclusivo): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Diría que el primero es más sencillo, pero resulta que el segundo es mucho más rápido, así que vamos a usar eso: SELECT ?persona ?personaLabel ?dob
WHERE
{
  ?persona wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! El servicio de etiquetas es muy útil si solo deseas mostrar la etiqueta de una variable. Pero si quieres hacer cosas con la etiqueta, por ejemplo, verificar si comienza con \"Sr. \"- encontrarás que no funciona: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! Esta consulta encuentra todas las instancias de fictional human (Q15632617) y prueba si su etiqueta comienza con \"Mr.\" (STRSTARTS es la abreviatura de \"string starts [with]\"; también hay STRENDS y CONTAINS). La razón por la que esto no funciona es que el servicio de etiquetas agrega sus variables muy tarde durante la evaluación de la consulta; en el punto donde intentamos filtrar ?humanLabel , el servicio de etiquetas aún no ha creado esa variable.Afortunadamente, el servicio de etiquetado no es la única forma de obtener la etiqueta de un item. Las etiquetas también se almacenan como ternas regulares, utilizando el predicado rdfs:label. Por supuesto, esto significa todas las etiquetas, no solo las que estan en inglés; si solo queremos etiquetas en inglés, tendremos que filtrar el idioma de la etiqueta: FILTER(LANG(?label) = \"en\"). La función LANG devuelve el idioma de una cadena monolingüe, y aquí solo seleccionamos las etiquetas que están en inglés. La consulta completa es: SELECT ?ser_humano ?label
WHERE
{
  ?ser_humano wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Sr. \")).
}
 Try it! Obtenemos la etiqueta con la terna ?ser_human rdfs:label ?label , la restringimos a etiquetas en inglés y luego verificamos si comienza con “Mr. \".También podes usar FILTER con una expresión regular. En el ejemplo siguiente: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Si la restricción de formato para una ID es [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! Es posible filtrar elementos específicos de esta manera FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Estas tres funciones se usan a menudo en conjunto, por lo que primero explicaré las tres y luego mostraré algunos ejemplos.Se puede utilizar una cláusula BIND (expresión AS ?variable). para asignar el resultado de una expresión a una variable (generalmente una nueva variable, pero también puede sobrescribir las existentes).BOUND (?variable) comprueba si una variable se ha vinculado a un valor (devuelve true o false). Es sobre todo útil en las variables que se introducen en una cláusula OPTIONAL.IF (condición, thenExpression, elseExpression) se evalúa como thenExpression si condition se evalúa como true , y elseExpression si la condition se evalúa como false . Es decir, IF (true, \"yes\", \"no\") se evalúa como \"yes\" , y IF (false, \"great\", \"terrible\" ) evalúa a \"terrible\" .BIND se puede usar para vincular los resultados de algunos cálculos a una nueva variable. Esto puede ser un resultado intermedio de un cálculo mayor o simplemente un resultado directo de la consulta. Por ejemplo, para obtener la edad de las víctimas de la pena capital: SELECT ?persona ?personaLabel ?edad
WHERE
{
  ?persona wdt:P31 wd:Q5;
          wdt:P569 ?nacido;
          wdt:P570 ?muerte;
          wdt:P1196 wd:Q8454.
  BIND(?muerte - ?nacido AS ?edadendias).
  BIND(?edadendias/365.2425 AS ?edadena_os).
  BIND(FLOOR(?edadena_os) AS ?edad).
  # o, como una expresión:
  #BIND(FLOOR((?muerte - ?nacido)/365.2425) AS ?edad).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND también se puede usar para enlazar simplemente valores constantes a variables para aumentar la legibilidad. Por ejemplo, una consulta que encuentre a todas las mujeres sacerdotes: SELECT ?mujer ?mujerLabel
WHERE
{
  ?mujer wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! puede ser escrito así: SELECT ?mujer ?mujerLabel
WHERE
{
  BIND(wdt:P31 AS ?instancia_de).
  BIND(wd:Q5 AS ?ser_humano).
  BIND(wdt:P21 AS ?sexo_o_g_nero).
  BIND(wd:Q6581072 AS ?femenino).
  BIND(wdt:P106 AS ?ocupaci_n).
  BIND(wd:Q42603 AS ?sacerdote).
  ?mujer ?instancia_de ?ser_humano;
         ?sexo_o_g_nero ?femenino;
         ?ocupaci_n ?sacerdote.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! La parte significativa de la consulta, desde ?mujer a ?sacerdote . , ahora es probablemente más legible. Sin embargo, el gran bloque BIND que está justo enfrente es bastante molesto, por lo que esta técnica debe usarse con moderación. (En la interfaz de usuario de WDQS, también puedes colocar el mouse sobre cualquier término como wd: Q123 o wdt: P123 y ver la etiqueta y la descripción de la entidad, por lo que ?femenino es más legible que wd: Q6581072 si ignoras esa función.)Las expresiones IF a menudo se usan con BOUND como expresión. Por ejemplo, supongamos que tienes una consulta que muestra algunos humanos, y en lugar de mostrar su etiqueta, le gustaría mostrar su pseudonym (P742) si tienen una, y solo usar la etiqueta si el seudónimo no existe. Para esto, selecciona el seudónimo en una cláusula OPTIONAL (tiene que ser opcional, no quieres tirar los resultados que no tienen un seudónimo) y luego usa BIND (IF (BOUND (... ) para seleccionar el seudónimo o la etiqueta. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Otras propiedades que se pueden usar de esta manera incluyen nickname (P1449), posthumous name (P1786) y taxon common name (P1843) - cualquier cosa donde algún tipo de \"segunda alternativa\" tenga sentido.También puedes combinar BOUND con FILTER para garantizar que al menos uno de los varios bloques de OPTIONAL se haya cumplido. Por ejemplo, obtengamos a todos los astronautas que fueron a la Luna, así como a los miembros de Apollo 13 (Q182252) (lo suficientemente cerca, ¿verdad?). Esa restricción no puede expresarse como una ruta de propiedad única, por lo que necesitamos una cláusula OPTIONAL para \"miembro de alguna misión lunar\" y otra para \"miembro de Apolo 13\". Pero solo queremos seleccionar aquellos resultados donde al menos una de esas condiciones sea verdadera. SELECT ?astronauta ?astronautaLabel
WHERE
{
  ?astronauta wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronauta wdt:P450 ?misi_n.
    ?misi_n wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronauta wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?misi_n).
  }
  FILTER(BOUND(?misi_n)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  COALESCE La función COALESCE se puede usar como una abreviatura del enlace BIND (IF (BOUND (?x),?x,?y) AS ?z). para las alternativas mencionadas arriba: toma varias expresiones y devuelve la primera que evalúa sin error. Por ejemplo, el anterior \"pseudónimo\" como segunda opción. BIND(IF(BOUND(?pseud_nimo),?pseud_nimo,?escritorLabel) AS ?label). puede ser escrito más concretamente como BIND(COALESCE(?pseud_nimo, ?escritorLabel) AS ?label). y esto es también sencillo para añadir otra etiqueta de \"segunda opción\" en el caso de que ?escritorLabel no esté definida tampoco: BIND(COALESCE(?pseud_nimo, ?escritorLabel, \"<no label>\") AS ?label).  Agrupación Hasta ahora, todas las consultas que hemos visto fueron consultas que encontraron todos los items que satisficieron algunas condiciones; en algunos casos, incluimos declaraciones extras en el ítem (pinturas con materiales, libros de Arthur Conan Doyle con título e ilustrador)Pero es muy común que no necesitemos una larga lista de todos los resultados. En vez de eso, podríamos preguntarnos cosas como esta: ¿\"Cuántas\" pinturas fueron pintadas en lienzo / madera de álamo / etc.? ¿Cuál es la \"mayor\" población en cada una de las ciudades de un país? ¿Cuál es el \"total\" de armas producidas por cada fabricante? ¿Quién publica, \"en promedio\", los libros más largos?  Poblaciones de ciudades Veamos la respuesta a la segunda pregunta por ahora. Es bastante simple escribir una query que liste todas las ciudades con su población y país, ordenadas por país: SELECT ?país ?ciudad ?población
WHERE
{
  ?ciudad wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?país;
        wdt:P1082 ?población.
}
ORDER BY ?país
 Try it! (Nota: esta consulta devuelve una \"gran\" cantidad de resultados, que podría causar problemas con tu navegador. Puedes agregar una cláusula LIMIT.)Ya que estamos ordenando resultados por país, todas las ciudades pertenecientes a un país forman un bloque contiguo en los resultados. Para encontrar la población más elevada dentro de ese bloque, deberíamos considerar ese bloque como un \"grupo\" y \"sumar\" todos los valores individuales de población en un sólo número: el máximo. Esto se hace con la cláusula GROUP BY debajo del bloque WHERE, y la función de suma (MAX) en la cláusula SELECT. SELECT ?país (MAX(?población) AS ?maxPoblación)
WHERE
{
  ?ciudad wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?país;
        wdt:P1082 ?población.
}
GROUP BY ?país
 Try it! Hemos reemplazado la cláusula ORDER BY por GROUP BY. Esto generará que todos los resultados con el mismo ?país estén ahora agrupados en un sólo resultado. Esto significa que deberemos cambiar la cláusula SELECT. Si mantuviésemos la anterior (SELECT ?país ?ciudad ?población), ¿qué código ?país y ?población devolvería?. Recuerda, hay muchos respuestas en este único resultado; todos tienen el mísmo ?país, por lo que podríamos seleccionar eso, pero como todos podrían tener un ?ciudad y ?población diferentes, tendremos que indicarle al WDQS cuáles valores seleccionar. Esto es un trabajo para la \"función aggregate\" (suma o agregación). En este caso, hemos usado MAX: de todos los valores de ?población, seleccionaremos el máximo del grupo de resultados. (Tendremos también que asignarle un nombre a este valor con el constructor AS, pero este es un detalle menor.)Este es el patrón general para escribir consultas de grupo: Se escribe una consulta normal que devuelve los resultados que queremos (no agrupados, con muchos resultados por \"grupo\"), y luego agregamos la cláusula GROUP BY y añadimos todos las variables no agrupadas en una función agregación en la cláusula SELECT. Materiales de pintura Intentemos con otra pregunta: ¿Cuántas pinturas fueron pintadas con cada material?. Primero, escribamos una consulta que sólo devuelva todas las pinturas junto al material con el que fueron realizadas. Observemos que sólo utilicemos las declaraciones del tipo made from material (P186) con un calificador applies to part (P518)painting support (Q861259) . SELECT ?material ?pintura
WHERE
{
  ?pintura wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Luego, agreguemos la cláusula GROUP BY en el ?material, y luego una función de agregación en la otra variable seleccionada (?pintura). En este caso, estamos interesados en un número de pinturas; la función agregada para esto es la función COUNT. SELECT ?material (COUNT(?pintura) AS ?count)
WHERE
{
  ?pintura wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! Un problema con esto es que no tenemos las etiquetas de los materiales, por lo que los resultados son un tanto difíciles de interpretar. Si sólo agregamos la variable de etiqueta, nos encontraremos con un error: SELECT ?material ?materialLabel (COUNT(?pintura) AS ?count)
WHERE
{
  ?pintura wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate \"Bad aggregate\" es un mensaje de error que probablemente veamos con frecuencia cuando trabajemos con consultas en grupo; significa que una de las variables seleccionadas necesita una función de agregación pero no tiene, o que tiene una función pero no debería tenerla. En este caso, WDQS piensa que pueden existir múltiples ?materialLabel por ?material (aun cuando sabemos que esto no puede pasar), por lo que arroja el mensaje de error debido a que no hay una función de agregación para esa variable.Una posible solución es agrupar múltiples variables, si nuestra lista tiene múltiples variables en la clásula GROUP BY, sólo hay un sólo resultado para cada combinación de esas variables, y podemos seleccionar todas las variables sin una función agregación. En este caso, agruparemos ?material y ?materialLabel. SELECT ?material ?materialLabel (COUNT(?pintura) AS ?count)
WHERE
{
  ?pintura wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! Casi terminamos con la consulta -Sólo nos queda una mejora: nos gustaría visualizar los materiales más utilizados primero. Por fortuna, se nos permite utilizar aquí las nuevas funciones agregación de la cláusula SELECT (en este caso, <code?count) en una cláusula ORDER BY, por lo que es bastante sencillo: SELECT ?material ?materialLabel (COUNT(?pintura) AS ?count)
WHERE
{
  ?pintura wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! Como un ejercicio, hagamos las otras consultas también. Armas por fabricante ¿Cuál es el número total de armas producidas por cada fabricante? Pista Los elementos relevantes de esta propiedad son: firearm (Q12796), manufacturer (P176), total produced (P1092). Ejemplo de solución SELECT ?fabricante ?fabricanteLabel (SUM(?producido) AS ?producido)
WHERE
{
  ?modelo wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?fabricante;
         wdt:P1092 ?producido.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?fabricante ?fabricanteLabel
ORDER BY DESC(?producido)
 Try it!  Editores por cantidad de páginas ¿Cuál es el número de páginas promedio (función: AVG) de libros por cada editor? Pista Los ítems y propiedades relevantes son: publisher (P123), number of pages (P1104). Solución de ejemplo SELECT ?editor ?editorLabel (AVG(?páginas) AS ?promPáginas)
WHERE
{
  ?libro wdt:P123 ?editor;
        wdt:P1104 ?páginas.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?editor ?editorLabel
ORDER BY DESC(?promPáginas)
 Try it!  HAVING Una pequeña adenda a la última consulta -Si miramos los resultados, podemos observar que el primer resultado tiene un promedio excesivamente grande, como diez veces más grande que el segundo lugar. Un poco de investigación nos muestra que esto se debe a que el editor (UTET (Q4002388)) sólo publicó un sólo libro con la propiedad number of pages (P1104), Grande dizionario della lingua italiana (Q3775610), lo que altera los resultados un poco. Para remover casos como este, podríamos intentar seleccionar sólo los editores que tienen publicados al menos dos libros con la propiedad number of pages (P1104) en Wikidata.¿Cómo hacemos esto? Normalmente, nos restringimos a resultados con la cláusula FILTER, pero en este caso queremos restringir basándonos en el grupo (la cantidad de libros), no por el resultado individual. Esto se realiza con la cláusula HAVING, que puede ser insertada luego de GROUP BY y toma una expresión tal como lo hace la función FILTER: SELECT ?editor ?editorLabel (AVG(?páginas) AS ?promPáginas)
WHERE
{
  ?libro wdt:P123 ?editor;
        wdt:P1104 ?páginas.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?editor ?editorLabel
HAVING(COUNT(?libro) > 1)
ORDER BY DESC(?promPáginas)
 Try it!  Sumario de las funciones agregación Este es un breve sumario de las funciones de agregación disponibles: COUNT: Cuenta la cantidad de elementos. También podemos escribir COUNT(*) para contar todos los resultados. SUM, AVG: la suma o el promedio de todos los elementos, respectivamente. Si los elementos no son números, se obtendrán resultados raros. MIN, MAX: el valor mínimo o máximo de todos los elementos, respectivamente. Esto funciona para todo tipo de valores, los números son ordenados de manera algebraica, mientras que cadenas o otro tipo de datos de manera léxica. SAMPLE: cualquier elemento. Esto es ocasionalmente útil si sabemos que sólo hay un resultado, o si no nos importa cuál es el resultado que se devuelve. GROUP_CONCAT: concatena todos los elementos. Raramente útil, pero si eres curioso, se puede obtener más información en la especificación SPARQL Adicionalmente, podemos agregar el modificador DISTINCT a cualquiera de esas funciones para eliminar resultados duplicados. Por ejemplo, si hay más de dos resultados pero ambos tienen el mismo valor en ?var, entonces COUNT(?var) devuelve 2 pero COUNT(DISTINCT ?var) sólo devuelve 1. Normalmente, se utiliza DISTINCT cuando se tiene una consulta que puede devolver el mismo valor reiteradas veces -esto puede pasar si, por ejemplo, se utiliza ?ítem wdt:P31/wdt:P279* ?clase, y luego hay múltiples caminos desde ?item hasta ?class: Obtendras un nuevo resultado por cada uno de estos caminos, incluso cuando todas las variables en el resultado son idénticas. (si no te encuentras agrupando, se puede eliminar también los resultados duplicados comenzando la consulta con SELECT DISTINCT en vez de solamente comenzar con SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, il servizio di query di Wikidata, è un potente strumento per accedere ai contenuti di Wikidata. Questa guida ti insegnerà come usarlo. Leggi anche il tutorial interattivo di Wikimedia Israele Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Prima di iniziare 2 SPARQL di base 3 La nostra prima query 3.1 Completamento automatico 4 Modelli di triple avanzate 5 Istanze e classi 5.1 Percorsi delle proprietà 6 Qualificatori 7 ORDER e LIMIT 7.1 Esercizio 7.1.1 Libri di Arthur Conan Doyle 7.1.2 Elementi chimici 7.1.3 Affluenti del Mississippi 7.1.4 Affluenti del Mississippi II 8 OPTIONAL 9 Espressioni, FILTER e BIND 9.1 Tipi di dati 9.2 Operatori 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Raggruppamento 10.1 Popolazioni delle città 10.2 Materiali per la pittura 10.3 Pistole per produttore 10.4 Editori per numero di pagine 10.4.1 HAVING 10.5 Riepilogo delle funzioni aggregatrici 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 E oltre… 14 Vedi anche Prima di iniziare Questa guida sembra molto lunga, forse addirittura intimidatoria. Per favore, non lasciare che ti spaventi! SPARQL è complicato, ma delle semplici basi già ti faranno fare molta strada – se vuoi, puoi smettere di leggere dopo #La nostra prima query, e ne saprai già abbastanza per scrivere molte query interessanti. Le sezioni successive aggiungono informazioni su questi argomenti che puoi usare per scrivere differenti query. Ognuna di esse ti darà la possibilità di scrivere query ancora più interessanti, ma nessuna di esse è indispensabile - puoi smettere di leggere in qualsiasi momento e avrai comunque utili informazioni!Se non hai mai sentito prima parlare di Wikidata, SPARQL o WDQS, ecco una breve spiegazione di questi termini: Wikidata è un database delle conoscenze. Contiene molte dichiarazioni come “la capitale del Canada è Ottawa”, o “La Gioconda è un dipinto a olio su tavola di legno di pioppo”, o “l'oro ha una capacità termica di 25 418 joule per mole-kelvin”. SPARQL è un linguaggio per formulare domande (query) per i database delle conoscenze. Con il giusto database, una query SPARQL può rispondere a domande come “qual è la tonalità più popolare nella musica?” o “quale personaggio è stato interpretato dal maggior numero di attori?” o “qual è la distribuzione del tipo di sangue?” o “quali opere e di quali autori sono entrate nel pubblico dominio quest'anno?”. WDQS, Wikidata Query Service, unisce i due insieme: tu immetti una query SPARQL, lui la esegue sul dataset di Wikidata e ti mostra il risultato.  SPARQL di base Una semplice query SPARQL ha il seguente aspetto: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clausola SELECT elenca le variabili che si desidera vengano restituite (le variabili iniziano con un punto interrogativo), e la clausola WHERE contiene restrizioni su di esse, principalmente sotto forma di triple. Tutte le informazioni in Wikidata (e database delle conoscenze simili) sono memorizzate sotto forma di triple; quando si esegue la query, il servizio query prova a compilare le variabili con i valori effettivi in modo che le triple risultanti vengano visualizzate come nel database della conoscenza, e restituisce un risultato per ciascuna combinazione di variabili che trova. Una tripla può essere letta come una frase (ecco perché termina con un punto), con un \"soggetto\", un \"predicato\" e un \"oggetto\": SELECT ?frutto
WHERE
{
  ?frutto haColore giallo.
  ?frutto haSapore aspro.
} I risultati per questa query potrebbero includere, ad esempio, \"limone\". In Wikidata, la maggior parte delle proprietà sono proprietà di tipo \"ha\", quindi la query si potrebbe leggere: SELECT ?frutto
WHERE
{
  ?frutto colore giallo.
  ?frutto sapore aspro.
} che si legge come “?frutto ha colore ‘giallo’” (non “?frutto è di colore ‘giallo’” – tienilo a mente per coppie di proprietà come “genitore”/“figlio”!).Tuttavia, questo non è un buon esempio per WDQS. Il gusto è soggettivo, quindi Wikidata non ha una proprietà per questo. Invece, pensiamo alle relazioni genitori/figli, che sono per lo più non ambigue. La nostra prima query Supponiamo di voler elencare tutti i figli del compositore barocco Johann Sebastian Bach. Usando pseudo-elementi come nelle query precedenti, come scriveresti quella query?Spero che tu abbia qualcosa del genere: SELECT ?figlio
WHERE
{
  #  figlio \"ha genitore\" Bach
  ?figlio genitore Bach.
  # (nota: ogni cosa dopo un ‘#’ è un commento ed è ignorato da WDQS.)
} o questo, SELECT ?figlio
WHERE
{
  # figlio \"ha padre\" Bach 
  ?figlio padre Bach. 
} o questo. SELECT ?figlio
WHERE
{
  #  Bach \"ha figlio\" figlio
  Bach figlio ?figlio.
} Le prime due triple dicono che il ?figlio deve avere come padre/genitore Bach; la terza dice che Bach deve avere il figlio ?figlio, Per ora esaminiamo il secondo.Quindi, cosa rimane da fare per trasformare questo in una query WDQS corretta? Su Wikidata, gli oggetti e le proprietà non sono identificati da nomi leggibili dall'utente umano come \"padre\" (proprietà) o \"Bach\" (elemento). (Per una buona ragione: \"Johann Sebastian Bach\" è anche il nome di un pittore tedesco e Bach potrebbe anche riferirsi al cognome, al comune francese, al cratere di Mercurio, etc.) Invece, agli oggetti e alle proprietà di Wikidata viene assegnato un identificatore. Per trovare l'identificatore di un oggetto, cerchiamo l'elemento e copiamo il numero-Q del risultato che sembra sia l'elemento più simile a quello che stiamo cercando (in base alla descrizione, ad esempio). Per trovare l'identificatore di una proprietà, facciamo lo stesso, ma cerchiamo “P:termine cercato” invece che solo “termine cercato”, questo limita la ricerca solo alle proprietà. Questo ci dice che il famoso compositore Johann Sebastian Bach è Q1339, e la proprietà per designare il padre di un oggetto è P:P22.E, ultimo ma non meno importante, abbiamo bisogno di includere dei prefissi. Per semplici triple WDQS, gli elementi devono essere preceduti da wd:, e le proprietà da wdt:. (Ma questo si applica solo ai valori fissi - le variabili non necessitano di un prefisso!)Mettendo insieme tutto questo, arriviamo alla nostra prima query WDQS corretta: SELECT ?figlio
WHERE
{
# ?figlio  padre   Bach
  ?figlio wdt:P22 wd:Q1339.
}
 Try it! Clicca su “Provalo” e poi “Esegui query” nella pagina WDQS. Che cosa ottieni? figlio wd:Q57225 wd:Q76428 … Beh, questo è deludente. Vedi solo gli identificatori. Puoi cliccare su di loro per vedere la corrispondente pagina Wikidata (inclusa un'etichetta leggibile dall'uomo), ma non c'è un modo migliore per vedere i risultati?Certo che sì! (Le domande retoriche non sono grandi?) Se includi il testo magico SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } da qualche parte all'interno della clausola WHERE, otterrai ulteriori variabili: per ogni variabile ?foo nella tua query, ora hai anche una variabile ?fooLabel , che contiene l'etichetta dell'elemento ?foo. Se l'aggiungi alla clausola SELECT, ottieni sia l'elemento che la sua etichetta. SELECT ?figlio ?figlioLabel
WHERE
{
# ?figlio  padre   Bach
  ?figlio wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Prova a eseguire la query: dovresti vedere non solo il numero degli elementi, ma anche i nomi dei vari figli figlio figlioLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Completamento automatico Quel frammento di codice SERVICE sembra difficile da ricordare, giusto? E passare attraverso la funzione di ricerca tutto il tempo mentre scrivi la query è anche noioso. Fortunatamente, WDQS offre un'ottima soluzione a questo: il \"completamento automatico\". Nell'editor di query in query.wikidata.org, puoi premere Ctrl+Spazio in qualsiasi punto della query e ottenere suggerimenti per il codice che potrebbero essere appropriati; seleziona il suggerimento corretto con freccia su/freccia giù e premi Invio per selezionarlo.Ad esempio, invece di scrivere SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } ogni volta, puoi semplicemente scrivere SERV, premere Ctrl+Spazio, e il primo suggerimento completerà magicamente il frammento di codice, pronto per l'uso! Basta premere Invio per accettarlo. (La formattazione sarà leggermente diversa, ma non importa.)E il completamento automatico può anche fare ricerche per te. Se digiti uno dei prefissi di Wikidata, come wd: o wdt:, e poi scrivi semplicemente il testo di seguito, Ctrl+Spazio cercherà quel testo su Wikidata e suggerirà risultati. wd: cerca negli elementi, wdt: cerca nelle proprietà. Ad esempio, invece di cercare gli elementi per Johann Sebastian Bach (Q1339) e father (P22), puoi semplicemente digitare wd:Bach e wdt:pad e quindi basta selezionare la voce giusta dal completamento automatico. (Funziona anche con spazi nel testo, ad es. wd:Johann Sebastian Bach.) Modelli di triple avanzate Così ora abbiamo visto tutti i figli di Johann Sebastian Bach - in particolare: tutti gli elementi che hanno Johann Sebastian Bach come padre. Ma Bach ha avuto due mogli, e quindi quegli elementi hanno due madri diverse: e se volessimo vedere solo i figli di Johann Sebastian Bach con la sua prima moglie, Maria Barbara Bach (Q57487)? Prova a scrivere quella query, in base a quella sopra.Fatto? Ok, allora andiamo alla soluzione! Il modo più semplice per farlo è aggiungere una seconda tripla con quella restrizione: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339.
  ?figlio wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In italiano questo si legge: Figlio che ha padre Johann Sebastian Bach. Figlio che ha madre Maria Barbara Bach. Sembra un po' imbarazzante, no? In linguaggio naturale, dovremmo abbreviare in questa maniera: Figlio che ha padre Johann Sebastian Bach e madre Maria Barbara Bach. In effetti, è possibile esprimere la stessa abbreviazione anche in SPARQL: se si termina una tripla con un punto e virgola (;) anziché un punto, è possibile aggiungere un'altra coppia oggetto-predicato. Questo ci permette di abbreviare la query sopra in: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! che ha gli stessi risultati, ma meno ripetizioni nella query.Ora supponiamo che, al di fuori di questi risultati, siamo interessati solo ai figli che sono stati anche compositori e pianisti. Le proprietà e gli elementi pertinenti sono occupation (P106), composer (Q36834) e pianist (Q486748). Prova ad aggiornare la query precedente per aggiungere queste restrizioni!Ecco la mia soluzione: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Questo usa l'abbreviazione ; altre due volte per aggiungere le due occupazioni richieste. Ma come puoi notare, c'è ancora qualche ripetizione. Questo è come se dicessimo: Il figlio ha occupazione compositore e occupazione pianista. che di solito dovremmo abbreviare come: Il figlio ha occupazione compositore e pianista. E SPARQL ha una sintassi anche per questo: proprio come un ; ti permette di aggiungere una coppia oggetto-predicato ad una tripla (riusando l'oggetto), un , ti permette di aggiungere un altro oggetto a una tripla (riusando sia il soggetto che il predicato). Con questo, la query può essere abbreviata in: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Nota: indentazione e gli altri spazi bianchi non contano davvero: ho appena indentato la query per renderla più leggibile. Puoi anche scrivere questo come: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # entrambe le occupazioni in una riga
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! o, anche se meno leggibile: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # nessuna indentazione; rende difficile distinguere tra ; e ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Fortunatamente, l'editor WDQS indenta automaticamente le linee, quindi di solito non devi preoccuparti di questo.Bene, riassumendo: abbiamo visto che le query sono strutturate come testo. Ogni tripla su un argomento è terminata da un punto. Più predicati relativi allo stesso soggetto sono separati da punti e virgola e più oggetti per lo stesso soggetto e predicato possono essere elencati separati da virgole. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Ora voglio introdurre un'altra abbreviazione che SPARQL offre. Così vediamo un altro scenario ipotetico...Supponiamo che non siamo realmente interessati ai figli di Bach. (Chissà, forse è proprio vero per te!) Ma siamo interessati ai suoi nipoti. (Ipoteticamente.) C'è una complicazione qui: un nipote può essere collegato a Bach tramite la madre o il padre. Sono due proprietà diverse, il che è scomodo. Invece, giriamo intorno alla relazione: Wikidata ha anche una proprietà \"figlio\", P:P40, che punta da genitore a figlio ed è indipendente dal genere. Con questa informazione, puoi scrivere una query che restituisce i nipoti di Bach?Ecco la mia soluzione: SELECT ?nipote ?nipoteLabel
WHERE
{
  wd:Q1339 wdt:P40 ?figlio.
  ?figlio wdt:P40 ?nipote.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In linguaggio naturale, si legge: Bach ha un figlio ?figlio. ?figlio ha un figlio ?nipote. Ancora una volta, propongo di abbreviare questa frase italiana, e poi voglio mostrarvi come SPARQL supporta un'abbreviazione simile. Osserva come in realtà non ci importa del figlio: non usiamo la variabile se non per parlare del nipote. Potremmo quindi abbreviare la frase in: Bach ha qualche figlio che ha un figlio ?nipote. Invece di dire chi è il figlio di Bach, diciamo semplicemente “qualche”: non ci interessa chi è. Ma possiamo riferirci a loro perché abbiamo detto “qualche che”: questo avvia una proposizione relativa, e all'interno di quella clausola possiamo dire cose su \"qualche\" (ad esempio, che lui o lei \"ha un figlio <codice>?nipote\"). In un certo senso, \"qualche\" è una variabile, ma una speciale che è valida solo all'interno di questa proposizione relativa, e una a cui non ci riferiamo esplicitamente (diciamo “qualcuno che è questo e fa così\", non \"qualcuno che è questo e qualcuno che lo fa” – questo è due diversi “qualcuno”).In SPARQL, questo può essere scritto come: SELECT ?nipote ?nipoteLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?nipote ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Puoi usare una coppia di parentesi ([]) al posto di una variabile, che agiscono come una variabile anonima. All'interno delle parentesi, puoi specificare le coppie oggetto-predicato, proprio come dopo un ; dopo una normale tripla; il soggetto implicito è in questo caso la variabile anonima rappresentata dalle parentesi. (Nota: anche come dopo ;, puoi aggiungere più coppie oggetto-predicato con più punti e virgola, o più oggetti per lo stesso predicato con le virgole.)E questo vale per tutti i modelli di triple! C'è di più in SPARQL, ma dato che stiamo per lasciare le parti di esso che sono fortemente analoghe al linguaggio naturale, vorrei riassumere questa relazione ancora una volta: linguaggio naturale esempio SPARQL esempio frase Giulietta ama Romeo. punto giulietta ama romeo. congiunzione (di intere frasi) Romeo ama Giulietta e uccide se stesso. punto e virgola romeo ama giulietta; uccide romeo. congiunzione (di singole parole) Romeo uccide Tebaldo e se stesso. virgola romeo uccide Tebaldo, romeo. proposizione relativa Giulietta ama qualcuno che ha ucciso Tebaldo. parentesi giulietta ama [ ucciso tebaldo ].  Istanze e classi In precedenza, ho detto che la maggior parte delle proprietà di Wikidata sono relazioni \"ha\": \"ha\" figlio, \"ha\" padre, \"ha\" occupazione. Ma a volte (di fatto, spesso), devi anche parlare di cosa \"è\". Ma ci sono in effetti due tipi di relazioni: Via col vento è un film. Un film è un'opera d'arte. Via col vento è uno specifico film. Ha uno specifico regista (Victor Fleming), una specifica durata (238 minuti), una lista di membri del cast (Clark Gable, Vivien Leigh, …), e così via.Film è un concetto generale. I film possono avere registi, durata, a membri del cast, ma il concetto “film” in quanto tale non ha un particolare regista, durata o membri del cast. E anche se un film è un'opera d'arte e un'opera d'arte di solito ha un creatore, il concetto stesso di \"film\" non ha un creatore – solo le specifiche \"istanze\" di questo concetto lo hanno.Questa differenza è il motivo per cui su Wikidata ci sono due proprietà per “è”: instance of (P31) e subclass of (P279). Via col vento è una specifica istanza della classe “film”; la classe “film” è una sottoclasse (classe più specifica, specializzazione) della più generica classe “opera d'arte”.Per aiutarti a capire la differenza, puoi provare a utilizzare due verbi diversi: \"è un\" e \"è un tipo di\". Se \"è un tipo di\" opera (ad esempio un film \"è un tipo di\" opera d'arte), indica che stai parlando di una sottoclasse, una specializzazione di una classe più ampia e dovresti usare subclass of (P279). Se \"è un tipo di\" non lavora (per esempio la frase Via col vento \"è un tipo di\" film, non ha molto senso), indica che stai parlando di una particolare istanza e dovresti usare instance of (P31).Che cosa significa questo per noi quando scriviamo una query SPARQL? Quando vogliamo cercare “tutte le opere d'arte”, non è sufficiente cercare tutti gli elementi che sono direttamente istanze di “opere d'arte”: SELECT ?opera ?operaLabel
WHERE
{
  ?opera wdt:P31 wd:Q838948. # istanza di opera d'arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mentre sto scrivendo questo, la query restituisce solo 2815 risultati – ovviamente, ci sono molte più opere d'arte di queste! Il problema è che non trova elementi come Via col vento, che è solo un'istanza di “film”, non di “opera d'arte”. “film” è una sottoclasse di “opera d'arte”, quindi dobbiamo dire a SPARQL di tenerne conto durante la ricerca.Una possibile soluzione a questo è la sintassi [] di cui abbiamo parlato: Via col vento è un'istanza di alcune sottoclassi “opera d'arte”. (Come esercizio, prova a scrivere quella query!) Ma questo ha ancora problemi: Non includiamo più item che sono direttamente istanze di opere d'arte. Ci mancano ancora elementi che sono istanze di sottoclassi di alcune altre sottoclassi di “opera d'arte” – per esempio, Biancaneve e i sette nani è un film d'animazione, che è un film, che è un'opera d'arte. In questo caso, dobbiamo seguire due dichiarazioni \"sottoclassi di\" – ma potrebbe anche essere tre, quattro, cinque, qualsiasi numero in realtà. La soluzione: ?item wdt:P31/wdt:P279* ?class. Ciò significa che esiste una “istanza di” e quindi un numero qualsiasi di dichiarazioni “sottoclasse di” tra l'elemento e la classe. SELECT ?opera ?operaLabel
WHERE
{
  ?opera wdt:P31/wdt:P279* wd:Q838948. # istanza di una qualsiasi sottoclasse di opera d'arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Non consiglio di eseguire quella query. WDQS può gestirla (a malapena), ma il browser potrebbe bloccarsi quando si tenta di visualizzare i risultati perché ce ne sono così tanti.)Ora sai come cercare tutte le opere d'arte, o tutti gli edifici, o tutti gli insediamenti umani: il magico wdt:P31/wdt:P279*, insieme alla classe appropriata. Ciò utilizza alcune funzionalità SPARQL che non ho ancora spiegato, ma onestamente, questo è quasi l'unico uso rilevante di queste funzionalità, quindi non è necessario capire come funziona per utilizzarlo in modo efficace in WDQS. Se lo vuoi sapere, lo spiegherò tra poco, ma puoi anche saltare la sezione successiva e memorizzare o copiare+incollare wdt:P31/wdt:P279* da qui quando ti serve. Percorsi delle proprietà I percorsi delle proprietà sono un modo per annotare in modo molto preciso un percorso delle proprietà tra due elementi. Il percorso più semplice è solo una singola proprietà, che forma una tripla ordinaria: ?item wdt:P31 ?class. È possibile aggiungere elementi di percorso anteponendo una barra obliqua (/) ?item wdt:P31/wdt:P279/wdt:P279 ?class. Questo è equivalente a uno dei seguenti: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Esercizio: riscrivi la precedente query \"nipoti di Bach\" per utilizzare questa sintassi.un asterisco (*) dopo un elemento di percorso significa “zero o più di questi elementi”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In assenza di altri elementi nel percorso, una notazione del tipo ?a qualcosa* ?b include anche la possibilità che ?b coincida con ?a, senza relazioni intermedie (\"percorso di lunghezza zero\"). Un più (+) è simile a un asterisco, ma significa “uno o più di questi elementi”. La seguente query trova tutti i discendenti di Bach: SELECT ?discendente ?discendenteLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?discendente.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Se qui usassimo un asterisco invece di un più, i risultati della query includerebbero Bach stesso.Un punto interrogativo (?) è simile a un asterisco o a un più, ma significa “zero o uno di questo elemento”.È possibile separare gli elementi del percorso con una barra verticale (|) anziché una barra obliqua; questo significa “o-o”: il percorso potrebbe utilizzare una di queste proprietà. (Ma non entrambe – un percorso o-o corrisponde sempre a un percorso di lunghezza uno).Puoi anche raggruppare gli elementi del percorso con delle parentesi (()), e combinare liberamente tutti questi elementi di sintassi (/|*+?). Ciò significa che un altro modo per trovare tutti i discendenti di Bach è: SELECT ?discendente ?discendenteLabel
WHERE
{
  ?discendente (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Invece di usare la proprietà \"figlio\" per andare da Bach ai suoi discendenti, usiamo le proprietà \"padre\" e \"madre\" per andare dai discendenti a Bach. Il percorso potrebbe includere due madri e un padre, o quattro padri, o padre-madre-madre-padre, o qualsiasi altra combinazione. (Anche se, naturalmente, Bach non può essere la madre di qualcuno, quindi l'ultimo elemento sarà sempre il padre.) Qualificatori (Prima le buone notizie: questa sezione non introduce alcuna sintassi SPARQL aggiuntiva – yuhuu! Fai un respiro veloce e rilassati, questo dovrebbe essere un gioco da ragazzi. Giusto?)Finora, abbiamo solo parlato di semplici dichiarazioni: soggetto, proprietà, oggetto. Ma le dichiarazioni di Wikidata sono più di questo: possono anche avere qualificatori e riferimenti. Ad esempio, la Gioconda (Q12418) ha tre dichiarazioni made from material (P186): oil paint (Q296955), il materiale principale; poplar wood (Q291034), con il qualificatore applies to part (P518)painting support (Q861259) – questo è il materiale su cui La Gioconda è stata dipinta; e wood (Q287), con il qualificatore applies to part (P518)stretcher (Q1737943) e start time (P580) 1951 – questa è una parte che è stata aggiunta al dipinto in seguito. Supponiamo di voler trovare tutti i dipinti con la loro superficie pittorica, cioè quelle made from material (P186) con un qualificatore applies to part (P518)painting support (Q861259) . Come facciamo? Sono più informazioni di quante possano essere rappresentate in una singola tripla.La risposta è: più triple! (Regola generale: la soluzione di Wikidata per quasi tutto è “più elementi” e la regola WDQS corrispondente è “più triple”. Riferimenti, precisione numerica, valori con unità, coordinate geografiche, ecc., tutto quello di cui stiamo parlando, funziona nella stessa maniera.) Finora, abbiamo usato il prefisso wdt: per la nostra dichiarazione delle triple, che punta direttamente all'oggetto della dichiarazione. Ma c'è anche un altro prefisso: p:, che punta non all'oggetto, ma a un nodo della dichiarazione. Questo nodo è quindi il soggetto di altre triple: il prefisso ps: (sta per property statement proprietà-dichiarazione) punta all'oggetto dichiarazione, il prefisso pq: (proprietà qualificatore) ai qualificatori, e prov:wasDerivedFrom punta ai nodi dei riferimenti (che per ora ignoreremo).Quello era un sacco di testo astratto. Ecco un esempio concreto per la Gioconda: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Possiamo abbreviare molto questo con la sintassi [], sostituendo le variabili ?statement: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Puoi usare quanto detto per scrivere una query per tutti i dipinti con la loro superficie pittorica?Ecco la mia soluzione: SELECT ?dipinto ?dipintoLabel ?materiale ?materialeLabel
WHERE
{
  ?dipinto wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiale; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Innanzitutto, limitiamo ?dipinto a tutte le istanze di painting (Q3305213) o una sua sottoclasse. Quindi, estraiamo il materiale dal nodo della dichiarazione p:P186, limitando le istruzioni a quelle che hanno un qualificatore applies to part (P518)painting support (Q861259) . ORDER e LIMIT Ritorniamo al nostro normale programma e vediamo altre funzioni SPARQL.Finora, abbiamo avuto solo domande in cui eravamo interessati a tutti i risultati. Ma è abbastanza comune preoccuparsi solo di alcuni risultati: quelli che sono in qualche modo estremi – popolazione più vecchia o più giovane, i più recenti, le ultime, più alta, col punto di fusione più basso, la maggior parte dei figli, la maggior parte dei materiali utilizzati e così via. Il fattore comune qui è che i risultati sono classificati in qualche modo, e quindi ci interessano i primi risultati (quelli con la classificazione migliore).Questo è controllato da due clausole, che vengono aggiunte al blocco WHERE {} (dopo le parentesi, non dentro!): ORDER BY e LIMIT.ORDER BY qualcosa ordina i risultati per qualcosa. qualcosa può essere qualsiasi espressione – per ora, l'unico tipo di espressione che conosciamo sono variabili semplici (?qualcosa), ma ne vedremo altre più tardi. Questa espressione può anche essere racchiusa in ASC() o in DESC() per specificarne l'ordinamento (ASC sta per ascendente, DESC sta per discendente). (Se non specificato, l'ordinamento predefinito è ascendente, quindi ASC(qualcosa) equivale a scrivere solo qualcosa.)LIMIT numero limita la lista dei risultati a numero risultati, dove numero è un numero naturale. Per esempio, LIMIT 10 limita la query a dieci risultati. LIMIT 1 restituisce solo un singolo risultato.(Puoi anche usare LIMIT senza ORDER BY. In questo caso, i risultati non sono ordinati, quindi non hai alcuna garanzia sui risultati che otterrai. Questo va bene se ti basta sapere che c'è solo un certo numero di risultati, o sei solo interessato ad alcuni risultati, ma non importa quali. In entrambi i casi, aggiungere LIMIT può velocizzare significativamente la query, dal momento che WDQS può smettere di cercare risultati non appena raggiunge il limite.)Tempo di esercizio! Prova a scrivere una query che restituisca i dieci stati più popolati. (Uno stato è uno sovereign state (Q3624078), e la proprietà per la popolazione è P:P1082.) Puoi iniziare cercando gli stati con la loro popolazione, e poi aggiungere le clausole ORDER BY e LIMIT.Ecco la mia soluzione: SELECT ?stato ?statoLabel ?popolazione
WHERE
{
  ?stato wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?popolazione.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Nota che se vogliamo gli stati più popolosi, dobbiamo ordinare per popolazione discendente, in maniera tale che i primi risultati siano quelli con i valori più alti. Esercizio Abbiamo coperto un sacco di argomenti finora – penso che sia giunto il momento per alcuni esercizi. (Puoi saltare questa sezione se hai fretta.) Libri di Arthur Conan Doyle Scrivi una query che restituisce tutti i libri di Sir Arthur Conan Doyle. Suggerimento Gli elementi e le proprietà pertinenti sono: Arthur Conan Doyle (Q35610), author (P50). Soluzione di esempio SELECT ?libro ?libroLabel
WHERE
{
  ?libro wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Elementi chimici Scrivi una query che restituisce tutti gli elementi chimici con il loro simbolo chimico e numero atomico, in ordine del loro numero atomico. Suggerimento Gli elementi e le proprietà pertinenti sono: chemical element (Q11344), element symbol (P246), atomic number (P1086). Soluzione di esempio SELECT ?elemento ?elementoLabel ?simbolo ?numero
WHERE
{
  ?elemento wdt:P31 wd:Q11344;
           wdt:P246 ?simbolo;
           wdt:P1086 ?numbero.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?numbero
 Try it!  Affluenti del Mississippi Scrivi una query che restituisce tutti gli affluenti del fiume Mississippi. (La difficoltà maggiore è trovare la proprietà corretta ...) Suggerimento Gli elementi e le proprietà pertinenti sono: Mississippi River (Q1497), mouth of the watercourse (P403). Soluzione di esempio SELECT ?fiume ?fiumeLabel
WHERE
{
  ?fiume wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Affluenti del Mississippi II Scrivi una query che restituisce tutti gli affluenti, diretti o indiretti, del fiume Mississippi. Suggerimento Questa query è quasi identica alla precedente. La differenza è che questa volta avrai bisogno di un percorso invece di una tripla. (Se hai saltato la sezione sui percorsi, salta anche questo esercizio.) Soluzione di esempio SELECT ?fiume ?fiumeLabel
WHERE
{
  ?fiume wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL Negli esercizi di cui sopra, c'era una query che estraeva tutti i libri di Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Ma è un po 'noioso. Esistono così tanti dati potenziali sui libri e mostriamo solo l'etichetta? Proviamo a creare una query che includa anche title (P1476), illustrator (P110), publisher (P123) e publication date (P577).Un primo tentativo potrebbe assomigliare a questo: SELECT ?libro ?titolo ?illustratoreLabel ?casaEditriceLabel ?pubblicato
WHERE
{
  ?libro wdt:P50 wd:Q35610;
        wdt:P1476 ?titolo;
        wdt:P110 ?illustratore;
        wdt:P123 ?casaEditrice;
        wdt:P577 ?pubblicato.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Esegui la query. Mentre sto scrivendo, restituisce solo due risultati: un po' poco! Perché? Abbiamo trovato oltre un centinaio di libri prima!Il motivo è che per avere corrispondenze con questa query, un risultato potenziale (un libro) deve rispettare tutte le triple che abbiamo elencato: deve avere un titolo e un illustratore e un editore e una data di pubblicazione. Se ne ha solo alcune, ma non tutte, non corrisponde alla query. Non è quello che vogliamo in questo caso: vogliamo un elenco di tutti i libri – se sono disponibili dati aggiuntivi, vorremmo includerli, ma non vogliamo che ciò limiti il nostro elenco di risultati.La soluzione è dire a WDQS che quelle triple sono \"opzionali\": SELECT ?libro ?titolo ?illustratoreLabel ?casaEditriceLabel ?pubblicato
WHERE
{
  ?libro wdt:P50 wd:Q35610.
  OPTIONAL { ?libro wdt:P1476 ?titolo. }
  OPTIONAL { ?libro wdt:P110  ?illustratore. }
  OPTIONAL { ?libro wdt:P123  ?casaEditrice. }
  OPTIONAL { ?libro wdt:P577  ?pubblicato. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Questo ci fornisce le variabili aggiuntive (?title, ?publisher etc.) se esiste l'appropriata dichiarazione, ma se la dichiarazione non esiste, il risultato non viene scartato – la variabile semplicemente non è impostata.Nota: è molto importante utilizzare clausole OPTIONAL separate qui. Se metti tutte le triple in una singola clausola, come qui – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – noterai che la maggior parte dei risultati non include alcuna informazione aggiuntiva. Questo perché una clausola opzionale con più triple corrisponde solo quando tutte queste triple possono essere soddisfatte. Cioè: se un libro ha un titolo, un illustratore, un editore e una data di pubblicazione, allora la clausola opzionale corrisponde e quei valori sono assegnati alle variabili appropriate. Ma se un libro ha, per esempio, un titolo ma non un illustratore, l'intera clausola opzionale non corrisponde, e sebbene il risultato non venga scartato, tutte e quattro le variabili rimangono vuote. Espressioni, FILTER e BIND Questa sezione potrebbe sembrare un po' meno organizzata rispetto alle altre, perché copre un argomento abbastanza ampio e diversificato. Il concetto di base è che ora vorremmo fare qualcosa con i valori che, finora, abbiamo selezionato e restituito indiscriminatamente. E espressioni sono il modo per esprimere queste operazioni sui valori. Ci sono molti tipi di espressioni e molte cose che puoi fare con loro – ma prima, iniziamo dalle basi: i tipi di dati. Tipi di dati Ogni valore in SPARQL ha un tipo, che ti dice che tipo di valore è e cosa puoi fare con esso. I tipi più importanti sono: elemento, come wd:Q42 per Douglas Adams (Q42). booleano, con due possibili valori true and false (vero e falso). I valori booleani non sono memorizzati nelle dichiarazioni, ma molte espressioni restituiscono un valore booleano, ad esempio 2 < 3 (true) o \"a\" = \"b\" (false). stringa, un pezzo di testo. I valori letterali delle stringhe sono scritti tra virgolette. testo monolingua, una stringa con un tag di lingua allegato. In un valore letterale, puoi aggiungere il tag della lingua dopo la stringa con il carattere @, ad esempio \"Douglas Adams\"@en. numeri, sia interi (1) che decimali (1.23). date. Le date possono essere scritte aggiungendo ^^xsd:dateTime (tiene conto delle maiuscole o minuscole – ^^xsd:datetime non lavora!) a una stringa data in formato ISO 8601: \"2012-10-29\"^^xsd:dateTime. (Wikidata non supporta ancora i timestamp con ore, minuti, secondi, ecc.)  Operatori Sono disponibili i classici operatori matematici: +, -, *, / per sommare, sottrarre, moltiplicare o dividere i numeri, <, >, =, <=, >= per confrontarli. Il test di disuguaglianza ≠ è scritto !=. Il confronto è anche definito per altri tipi; per esempio, \"abc\" < \"abd\" è vero (confronto lessicale), come \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime e wd:Q4653 != wd:Q283111. Le condizioni booleane possono essere combinate con && (operatore logico and: a && b è vero se entrambi a e b sono veri) e || (operatore logico or: a || b è vero se almeno uno di a o b è vero). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example.FILTER(condizione). è una clausola che puoi inserire nella query SPARQL per filtrare i risultati. All'interno delle parentesi puoi inserire qualsiasi espressione di tipo booleano e solo quei risultati in cui l'espressione restituisce true sono usati.Ad esempio, per ottenere un elenco di tutti gli umani nati nel 2015, prima otteniamo tutti gli umani con la loro data di nascita – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – e poi filtriamo per restituire solo i risultati in cui l'anno della data di nascita è il 2015. Ci sono due modi per farlo: estrarre l'anno della data con la funzione ANNO e verificare che sia uguale a 2015 – FILTER(YEAR(?dob) = 2015). – o verificare che la data sia compresa tra il 1° gennaio (incluso) 2015 e il 1° gennaio 2016 (escluso): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Direi che il primo è più semplice, ma il secondo risulta molto più veloce, quindi usiamolo: SELECT ?persona ?personaLabel ?ddn
WHERE
{
  ?persona wdt:P31 wd:Q5;
          wdt:P569 ?ddn.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?ddn < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Un altro possibile uso di FILTER è correlato alle etichette. Il servizio label è molto utile se si desidera solo visualizzare l'etichetta di una variabile. Ma se vuoi fare cose con l'etichetta – per esempio: controllare se inizia con “Mr.”- scoprirai che non funziona: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! Questa query trova tutte le istanze di fictional human (Q15632617) e verifica se la loro etichetta inizia con \"Mr. \" (STRSTARTS è l'abbreviazione di “string starts [with]” (stringa inizia [con]); ci sono anche STRENDS (stringa fiisce con) e CONTAINS (stringa contiene)). Il motivo per cui questo non funziona è che il servizio label aggiunge le sue variabili molto tardi durante la valutazione della query; nel punto in cui cerchiamo di filtrare ?humanLabel il servizio label non ha ancora creato quella variabile.Fortunatamente, il servizio label non è l'unico modo per ottenere l'etichetta di un articolo. Le etichette vengono anche memorizzate come triple regolari, usando il predicato rdfs:label. Ovviamente, questo significa tutte le etichette, non solo quelle inglesi; se vogliamo solo etichette in inglese, dovremo filtrare la lingua dell'etichetta: FILTER(LANG(?label) = \"en\"). La funzione LANG, restituisce la lingua di una string monolingua, qui selezioniamo solo le etichette che sono in inglese. La query completa è: SELECT ?umano ?etichetta
WHERE
{
  ?umano wdt:P31 wd:Q15632617;
         rdfs:label ?etichetta.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! Otteniamo l'etichetta con la tripla ?human rdfs:label ?label, limitandole all'etichette in inglese e poi controlliamo se iniziano con “Mr.”.Si può anche usare FILTER con un'espressione regolare. Nell'esempio seguente SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Se il vincolo di formato per un ID è [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! È possibile filtrare elementi specifici in questa maniera FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) È possibile filtrare, ma anche avere elementi non soddisfatti: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Queste tre funzionalità sono spesso utilizzate insieme, quindi prima di tutto le spiegherò tutte e tre e poi mostrerò alcuni esempi.Una clausola BIND(expression AS ?variable). può essere usata per assegnare il risultato di un'espressione a una variabile (di solito una nuova variabile, ma è anche possibile sovrascrivere quelle esistenti).BOUND(?variable) verifica se una variabile è stata associata a un valore (restituisce true o false). È utile soprattutto per le variabili introdotte in una clausola OPTIONAL.IF(condition,thenExpression,elseExpression) viene valutato thenExpression se condition restituisce true e viene valutato elseExpression se condition resttituisce false. Cioè IF(true, \"yes\", \"no\") viene valutato \"yes\", e IF(false, \"great\", \"terrible\") viene valutato \"terrible\".BIND può essere utilizzato per associare i risultati di alcuni calcoli a una nuova variabile. Questo può essere un risultato intermedio di un calcolo più grande o direttamente un risultato della query. Ad esempio, per ottenere l'età delle vittime di pena capitale: SELECT ?persona ?personaLabel ?eta
WHERE
{
  ?persona wdt:P31 wd:Q5;
          wdt:P569 ?nato;
          wdt:P570 ?morto;
          wdt:P1196 wd:Q8454.
  BIND(?morto - ?nato AS ?etaInGiorni).
  BIND(?etaInGiorni/365.2425 AS ?etaInGiorni).
  BIND(FLOOR(?etaInGiorni) AS ?eta).
  # o, come una sola espressione:
  #BIND(FLOOR((?morto - ?nato)/365.2425) AS ?eta).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND può anche essere usato per assegnare semplicemente i valori costanti alle variabili al fine di aumentare la leggibilità della query. Ad esempio, una query che trova tutti i sacerdoti femminili: SELECT ?donna ?donnaLabel
WHERE
{
  ?donna wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! può essere riscritto così: SELECT ?donna ?donnaLabel
WHERE
{
  BIND(wdt:P31 AS ?istanzaDi).
  BIND(wd:Q5 AS ?umano).
  BIND(wdt:P21 AS ?sessoOgenere).
  BIND(wd:Q6581072 AS ?femmina).
  BIND(wdt:P106 AS ?occupazione).
  BIND(wd:Q42603 AS ?sacerdote).
  ?donna ?istanzaDi ?umano;
         ?sessoOgenere ?femmina;
         ?occupazione ?sacerdote.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! La parte significativa della query, da ?donna a ?sacerdote., ora è probabilmente più leggibile. Tuttavia, il grande blocco BIND proprio di fronte ad esso è piuttosto dispersivo, quindi questa tecnica dovrebbe essere usata con parsimonia. (Nell'interfaccia utente di WDQS, puoi anche passare il mouse sopra qualsiasi termine come wd:Q123 o wdt:P123 e vedere l'etichetta e la descrizione per l'entità, quindi ?femmina è più leggibile di wd:Q6581072 se si ignora tale caratteristica.)Le espressioni IF sono spesse usate con BOUND come espressione. Ad esempio, supponiamo di avere una query che mostra alcuni umani e invece di mostrare solo la loro etichetta, vorresti visualizzare il loro pseudonym (P742) se ne hanno uno, e usare l'etichetta solo se non ce l'hanno. Per questo, si seleziona lo pseudonimo in una clausola OPTIONAL (deve essere facoltativo – non vuoi escludere i risultati che non hanno uno pseudonimo), e poi usare BIND(IF(BOUND(… per selezionare lo pseudonimo o l'etichetta. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Altre proprietà che possono essere utilizzate in questo modo includono nickname (P1449), posthumous name (P1786) e taxon common name (P1843) – qualsiasi cosa in cui una sorta di “ripiego” ha un senso.Puoi anche combinare BOUND con FILTER per assicurarti che almeno uno dei vari blocchi OPTIONAL sia stato soddisfatto. Per esempio, prendiamo tutti gli astronauti che sono andati sulla luna, così come i membri dell'Apollo 13 (Q182252) (abbastanza vicino, giusto?). Quella limitazione non può essere espressa come un singolo percorso di proprietà, quindi abbiamo bisogno di una clausola OPTIONAL per “membro di qualche missione lunare” e un'altro per “membro dell'Apollo 13”. Ma vogliamo solo selezionare quei risultati in cui almeno una di queste condizioni è vera. SELECT ?astronauta ?astronautaLabel
WHERE
{
  ?astronauta wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronauta wdt:P450 ?missione.
    ?missione wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronauta wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?missione).
  }
  FILTER(BOUND(?missione)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE La funzione COALESCE può essere usata come abbreviazione del modello BIND(IF(BOUND(?x), ?x, ?y) AS ?z). per il ripiego menzionato prima: richiede un certo numero di espressioni e restituisce la prima che valuta senza errori. BIND(IF(BOUND(?pseudonimo),?pseudonimo,?scrittoreLabel) AS ?etichetta). può essere scritto in modo più conciso come BIND(COALESCE(?pseudonimo, ?scrittoreLabel) AS ?etichetta). ed è anche facile aggiungere un'altra etichetta di fallback nel caso in cui anche ?writerLabel non è definito: BIND(COALESCE(?pseudonimo, ?scrittoreLabel, \"<no label>\") AS ?etichetta).  Raggruppamento Finora, tutte le query che abbiamo visto sono state query che hanno trovato tutti gli elementi che soddisfano alcune condizioni; in alcuni casi, abbiamo incluso anche dichiarazioni extra sull'oggetto (dipinti con materiali, libri di Arthur Conan Doyle con titolo e illustratore).Ma è molto comune non volere una lunga lista di tutti i risultati. Invece, potremmo fare domande come questa: Quanti dipinti sono stati dipinti su tela / legno di pioppo / etc.? Qual'é la più popolosa città di ogni stato? Qual'è il numero totale di pistole prodotte da ciascun produttore? Chi pubblica in media i libri più lunghi?  Popolazioni delle città Diamo un'occhiata alla seconda domanda per ora. È abbastanza semplice scrivere una query che elenchi tutte le città con la loro popolazione e lo stato, ordinati per stato: SELECT ?stato ?citta ?popolazione
WHERE
{
  ?citta wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?stato;
        wdt:P1082 ?popolazione.
}
ORDER BY ?stato
 Try it! (Nota: quella query restituisce un sacco di risultati, che potrebbe causare problemi al tuo browser. Potresti voler aggiungere una clausola LIMIT.)Dal momento che stiamo ordinando i risultati per paese, tutte le città appartenenti a un paese formano un blocco contiguo nei risultati. Per trovare la popolazione più alta all'interno di quel blocco, vogliamo considerare il blocco come un gruppo e aggregare tutti i singoli valori della popolazione in un unico valore: il massimo. Questo viene fatto con una clausola GROUP BY sotto il blocco WHERE, e una funzione aggregante (MAX) nella clausola SELECT. SELECT ?stato (MAX(?populazione) AS ?maxPopolazione)
WHERE
{
  ?citta wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?stato;
        wdt:P1082 ?popolazione.
}
GROUP BY ?stato
 Try it! Abbiamo sostituito ORDER BY con GROUP BY. L'effetto di questo è che tutti i risultati con lo stesso ?stato sono ora raggruppati in un unico risultato. Ciò significa che dobbiamo modificare anche la clausola SELECT. Se manteniamo la vecchia clausola SELECT ?stato ?citta ?popolazione, quale ?citta e ?popolazione verrebbero restituite? Ricorda, ci sono molti risultati in questo unico risultato; hanno tutti lo stesso ?stato, quindi possiamo selezionarlo, ma dal momento che tutti possono avere una differente ?citta e ?popolazione, dobbiamo dire a WDQS quale di questi valori selezionare. Questo è il lavoro della funzione aggregante. In questo caso, abbiamo usato MAX: tra tutti i valori di ?popolazione, selezioniamo il più alto (massimo) per il gruppo di risultati. (Dobbiamo anche dare a quel valore un nuovo nome con il costrutto AS, ma questo è solo un dettaglio minore.)Questo è lo schema generale per scrivere le query con raggruppamento: scrivi una query normale che restituisca i dati che desideri (non raggruppato, con molti risultati per “gruppo”), poi aggiungi una clausola GROUP BY e aggiungi una funzione aggregante a tutte le variabili non raggruppate nella clausola SELECT. Materiali per la pittura Proviamo con un'altra domanda: quanti dipinti sono stati dipinti su ciascun materiale? In primo luogo, scrivi una query che restituisce tutti i dipinti insieme al loro materiale per la pittura. (Stai attento a usare solo le dichiarazioni made from material (P186) con un qualificatore applies to part (P518)painting support (Q861259) .) SELECT ?materiale ?dipinto
WHERE
{
  ?dipinto wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiale; pq:P518 wd:Q861259 ].
}
 Try it! Quindi, aggiungi una clausola GROUP BY su ?materiale, quindi una funzione di aggregazione sull'altra variabile selezionata (?dipinto). In questo caso, siamo interessati al numero di dipinti; la funzione di aggregazione è COUNT. SELECT ?materiale (COUNT(?dipinto) AS ?conta)
WHERE
{
  ?dipinto wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiale; pq:P518 wd:Q861259 ].
}
GROUP BY ?materiale
 Try it! Un problema con questo è che non abbiamo l'etichetta per i materiali, quindi i risultati sono un po' scomodi da interpretare. Se aggiungiamo semplicemente la variabile label, visualizzeremo un errore: SELECT ?materiale ?materialeLabel (COUNT(?dipinto) AS ?conta)
WHERE
{
  ?dipinto wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiale; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materiale
 Try it! Bad aggregate “Bad aggregate” è un messaggio di errore che probabilmente vedrai spesso quando lavori con le query di gruppo; significa che una delle variabili selezionate ha bisogno di una funzione aggregatrice ma non ne ce l'ha, o ha una funzione aggregatrice ma non dovrebbe avercela. In questo caso, WDQS ritiene che potrebbero esserci multipli In questo caso, WDQS ritiene che potrebbero esserci multipli ?materialeLabel per ?material (anche se sappiamo che non può accadere), e quindi lamenta il fatto che non stai specificando una funzione aggregatrice per quella variabile.Una soluzione è raggruppare più variabili. Se si elencano più variabili nella clausola GROUP BY, esiste un risultato per ciascuna combinazione di tali variabili e si possono selezionare tutte quelle variabili senza funzione di aggregazione. In questo caso, raggrupperemo sia ?materiale che ?materialeLabel. SELECT ?materiale ?materialeLabel (COUNT(?dipinto) AS ?conta)
WHERE
{
  ?dipinto wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiale; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materiale ?materialeLabel
 Try it! Abbiamo quasi finito con la query – un ulteriore miglioramento: vorremmo vedere prima i materiali più usati. Fortunatamente, siamo autorizzati a utilizzare le nuove variabili aggregate dalla clausola SELECT (?conta in questo caso) in una clausola ORDER BY, quindi questo è molto semplice: SELECT ?materiale ?materialeLabel (COUNT(?dipinto) AS ?conta)
WHERE
{
  ?dipinto wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiale; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materiale ?materialeLabel
ORDER BY DESC(?conta)
 Try it! Come esercizio, facciamo anche le altre query. Pistole per produttore Qual è il numero totale di pistole prodotte da ciascun produttore? Suggerimento Gli elementi e le proprietà pertinenti sono: firearm (Q12796), manufacturer (P176), total produced (P1092). Soluzione di esempio SELECT ?produttore ?produttoreLabel (SUM(?prodotti) AS ?totaleProdotti)
WHERE
{
  ?modello wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?produttore;
         wdt:P1092 ?prodotti.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?produttore ?produttoreLabel
ORDER BY DESC(?prodotti)
 Try it!  Editori per numero di pagine Qual'è il numero medio (funzione: AVG) di pagine per librp per ogni editore? Suggerimento Gli elementi e le proprietà pertinenti sono: publisher (P123), number of pages (P1104). Soluzione di esempio SELECT ?editore ?editoreLabel (AVG(?pagine) AS ?mediaPagine)
WHERE
{
  ?libro wdt:P123 ?editore;
        wdt:P1104 ?pagine.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?editore ?editoreLabel
ORDER BY DESC(?mediaPagine)
 Try it! HAVING Una piccola aggiunta a quest'ultima query – se guardi i risultati, potresti notare che il risultato più alto ha una media scandalosamente alta, oltre dieci volte quella del secondo posto. Un po 'di indagine rivela che questo è dovuto al fatto che quell'editore (UTET (Q4002388)) ha pubblicato solo un libro con una dichiarazione number of pages (P1104): Grande dizionario della lingua italiana (Q3775610), che distorce un po' i risultati. Per rimuovere tali valori anomali, potremmo provare a selezionare solo gli editori che hanno pubblicato almeno due libri con dichiarazione number of pages (P1104) su Wikidata.Come lo facciamo? Normalmente, limitiamo i risultati con una clausola FILTER, ma in questo caso vogliamo limitare in base al gruppo (il numero di libri), non un risultato singolo. Questo è ottenuto con una clausola HAVING, che può essere posizionato subito dopo una clausola GROUP BY e agisce proprio come FILTER: SELECT ?editore ?editoreLabel (AVG(?pagine) AS ?mediaPagine)
WHERE
{
  ?libro wdt:P123 ?editore;
        wdt:P1104 ?pagine.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?editore ?editoreLabel
HAVING(COUNT(?libro) > 1)
ORDER BY DESC(?mediaPagine)
 Try it!  Riepilogo delle funzioni aggregatrici Ecco un breve riassunto delle funzioni di aggregazione disponibili: COUNT: conta il numero di elementi. Puoi scrivere COUNT(*) per contare semplicemente tutti i risultati. SUM, AVG: rispettivamente la somma o la media di tutti gli elementi. Se gli elementi non sono numeri, otterrai risultati strani. MIN, MAX: rispettivamente il valore minimo o massimo di tutti gli elementi. Questo funziona per tutti i tipi di valore; i numeri sono ordinati numericamente, stringhe e altri tipi in modo lessicale. SAMPLE: qualsiasi elemento. Questo è di tanto in tanto utile se sai che c'è un solo risultato, o se non ti interessa quale viene restituito. GROUP_CONCAT: concatena tutti gli elementi. Raramente utile, ma se siete curiosi, potete cercarlo nella specifica SPARQL specification. Inoltre, è possibile aggiungere un modificatore DISTINCT per ognuna di queste funzioni per eliminare i risultati duplicati. Ad esempio, se ci sono due risultati ma entrambi hanno lo stesso valore in ?var, allora COUNT(?var) restituirà 2 ma COUNT(DISTINCT ?var) restituirà solo 1. Devi spesso usare DISTINCT quando la tua query può restituire lo stesso oggetto più volte – questo può accadere se, ad esempio, si usa ?item wdt:P31/wdt:P279* ?class, e ci sono più percorsi da ?item a ?class: otterrai un nuovo risultato per ognuno di quei percorsi, anche se tutti i valori nel risultato sono identici. (Se non stai raggruppando, puoi anche eliminare quei risultati duplicati avviando la query con SELECT DISTINCT anziché usare solo SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, el Servei de Consultes, és una eina per respondre preguntes que pugueu tenir, i aquesta guia us ajudarà a aprendre com utilitzar-lo. Vegeu també el tutorial interactiu de Wikimedia Israel.Abans d'escriure la vostra pròpia consulta d'SPARQL, reviseu {{Item documentation}} o qualsevol altra plàntilla de consulta SPARQL genèrica per veure si la vostra consulta ja hi ha estat inclosa. Contents 1 Abans de començar 2 Conceptes bàsics d'SPARQL 3 La nostra primera consulta 3.1 Autocompletat 4 Patrons avançats de ternes 5 Instàncies i classes 5.1 Rutes de propietats 6 Qualificadors 7 ORDER i LIMIT 7.1 Exercici 7.1.1 Llibres d'Arthur Conan Doyle 7.1.2 Elements químics 7.1.3 Rius que desemboquen al Mississippi 7.1.4 Rius que desemboquen al Mississippi II 8 OPTIONAL 9 Expressions, FILTER i BIND 9.1 Tipus de dades 9.2 Operadors 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupant 10.1 Població de ciutats 10.2 Materials de pintura 10.3 Armes per fabricant 10.4 Editorials per nombre de pàgines 10.4.1 HAVING 10.5 Resum de funcions d'agregació 10.6 wikibase: Etiquetes i agregacions 11 VALUES 12 Label in multiple languages 13 I més enllà… 14 Vegeu també Abans de començar Aquesta guia pot semblar llarga, tant que potser intimida. No us espanteu! L'SPARQL és complicat, però només amb els conceptes bàsics ja es pot anar força lluny. Si voleu, podeu deixar de llegir després de la nostra primera consulta i ja podreu escriure moltes consultes interessants. Les seccions que venen a continuació d'això només afegeixen informació sobre altres elements que podeu utilitzar per escriure consultes diferents. Cadascuna d'aquestes seccions us capacitarà per escriure consultes encara més potents, però cap d'elles és necessària: podeu deixar de llegir en qualsevol moment i, tot i així, disposareu de molts coneixements útils.Si no heu sentit mai a parlar de Wikidata, SPARQL o WDQS, aquí en teniu una explicació breu: Wikidata és una base de dades de coneixement. Conté molts fets, com ara que «la capital de Canadà és Ottawa», o que «la Mona Lisa fou pintada a l'oli en una fusta de pollancre», o que «l'or té una conductivitat tèrmica de 25.418 joules per mol kelvin». L'SPARQL és un llenguatge per formular consultes a bases de dades de coneixement. Amb la base de dades correcta, una consulta SPARQL podria preguntar qüestions com ara “quina és la tonalitat musical més popular?” o “quin personatge ha estat interpretat per més actors?” o “quina és la distribució de tipus de sang?” o “quines obres d'autor han entrat en el domini públic enguany?”. WDQS, el Servei de Consulta de Wikidata ajunta les dues coses: en definir una consulta SPARQL, el servei l'executa usant les dades de Wikidata, mostrant-ne el resultat.  Conceptes bàsics d'SPARQL Una consulta senzilla en SPARQL s'assembla a això: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clàusula SELECT llista les variables que volem consultar (les variables comencen amb un signe d'interrogació) i la clàusula WHERE conté les restriccions que hi volem aplicar, en forma de ternes. Tota la informació de Wikidata (i d'altres bases de dades de coneixement similars) està desada en forma de ternes; quan executem la consulta, el servei de consultes intenta emplenar les variables amb valors reals existents a la base de dades, tornant un resultat per a cada combinació de variables que troba.Una terna es pot considerar com dos vèrtexs (és a dir, 2 nodes, 2 recursos) connectats per una aresta (un arc, una propietat) dins del vast multigràfic de propietats directe (orientat) que forma Wikidata. Es pot llegir com una frase (per això s'acaba amb un punt), amb un «subjecte», un «predicat» i un «complement directe». SELECT ?fruita
WHERE
{
  ?fruita ésDeColor groc.
  ?fruita téGust agre.
} El resultat d'aquesta consulta pot incloure, per exemple, «llimona». A Wikidata, la majoria de propietats assumeixen que els ítems «tenen» propietats, pel què la consulta podria ser: SELECT ?fruita
WHERE
{
  ?fruita color groc.
  ?fruita gust agre.
} el que es pot llegir com “?fruita té color ‘groc’” (no “?fruita és de color ‘groc’” – tinguem això present per a propietats com “pare”/“fill”!).Tot i això, aquest no és un bon exemple de WDQS. El gust és subjectiu, així que Wikidata no en té una propietat. En canvi, observem la relació pare/fill, que és menys ambigua. La nostra primera consulta Suposem que volem llistar tots els fills del compositor barroc Johann Sebastian Bach. Utilitzant psèudo-elements com a les consultes anteriors, com escriuríem la consulta?Amb sort, aconseguirem una cosa així: SELECT ?fill
WHERE
{
  #  fill «té pare» Bach
  ?fill pare Bach.
  # (Nota: tot el que hi ha darrere d'un ‘#' és un comentari i WDQS ho ignora.)
} o això, SELECT ?fill
WHERE
{
  # fill «té pare» Bach 
  ?fill pare Bach. 
} o això, SELECT ?fill
WHERE
{
  #  Bach «té fill» fill
  Bach fill ?fill.
} Les dues primeres ternes diuen que ?fill ha de tenir Bach com a pare; la tercera diu que Bach ha de tenir el fill ?fill. Per ara i tant, quedem-nos amb la segona.Aleshores, què falta per a convertir això en una consulta vàlida de WDQS? A Wikidata, els ítems i les propietats no s'identifiquen amb noms llegibles-pels-humans com «pare» (una propietat) o «Bach» (un ítem). (I per una bona raó: «Johann Sebastian Bach» també és el nom d'un pintor alemany, i «Bach» també es podria referir al cognom, la comuna francesa, el cràter de Mercuri, etc). En canvi, els ítems i propietats de Wikidata tenen assignades un identificador. Per a trobar l'identificador d'un ítem, fem una cerca de l'ítem i en copien el número Q de l'ítem que coincideixi amb el que estem buscant (per exemple, basant-nos en la descripció). Per trobar l'identificador d'una propietat fem el mateix, però cercant amb «P:terme» amb el que ampliem la cerca a les propietats. Això ens diu que el famós compositor Johann Sebastian Bach és Q1339 i que la propietat per a designar el pare d'un ítem és la P:P22.Finalment, però no per això menys important, necessitem incloure prefixos. Per ternes senzilles de WDQS, els elements s'haurien de prefixar amb wd:, i les propietats amb wdt:. (Però això només s'aplica als valors fixos, les variables no porten prefix!)I, així, arribem a la nostra primera consulta WDQS: SELECT ?fill
WHERE
{
# ?fill  pare   Bach
  ?fill wdt:P22 wd:Q1339.
}
 Try it! Feu clic a l'enllaç «Proveu-ho» i després «Executeu» la consulta a la pàgina de WDQS. Què obteniu? fill wd:Q57225 wd:Q76428 … Bé, això és decebedor. Només veieu els identificadors. Si hi feu clic, anireu a la seva pàgina de Wikidata (on hi ha una etiqueta entenedora pels humans), però no hi ha una forma millor de veure els resultats?Resulta que sí que n'hi ha una (oi que les preguntes retòriques són genials?), si hi incloeu el text màgic SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } en algun lloc dins la clàusula WHERE, aconseguireu variables addicionals: Per a cada variable ?foo de la vostra consulta, ara també tindreu una variable ?fooLabel, la qual conté l'etiqueta de l'element ?foo subjacent. Si afegiu això a la clàusula SELECT, obtindreu tant l'element com la seva etiqueta: SELECT ?fill ?fillLabel
WHERE
{
# ?fill  pare   Bach
  ?fill wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Proveu a executar aquesta consulta i hauríeu de veure els números d'ítem i els noms dels diferents fills. fill fillLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autocompletat El fragment de codi de SERVICE sembla complicat de recordar, oi? I haver d'anar fent consultes tota l'estona mentre escriviu la consulta és tediós. Afortunadament, WDQS ofereix una bona solució per això: l'«autocompletat». A l'editor de consultes de query.wikidata.org, hi podeu prémer en qualsevol moment les tecles Ctrl+Espai (o Alt+Retorn o Ctrl+Alt+Retorn) per a obtenir suggeriments del codi que podríeu necessitar. Seleccioneu el suggeriment correcte fent fletxa amunt/fletxa avall i prement Retorn.Per exemple, en comptes d'escriure SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } cada cop, podeu teclejar només SERV, prémer Ctrl+Espai i el primer suggeriment serà l'etiqueta completa de service, preparada per a ser executada! Premeu Retorn per a acceptar-lo. (El formatat serà una mica diferent, però no importa).I l'autocompletat també pot fer la cerca per sí mateix. Si teclegeu un dels prefixos de Wikidata, com wd: o wdt:, i després escriviu qualsevol cosa darrere, Ctrl+Espai farà la cerca del text a Wikidata i us farà suggeriments. wd: busca ítems i wdt: propietats. Per exemple, en comptes de fer la cerca dels ítems Johann Sebastian Bach (Q1339) i father (P22), podeu senzillament teclejar wd:Bach i wdt:pare i seleccionar el suggeriment correcte de l'autocompletat. Això fins i tot funciona amb espais al text. Per exemple: wd:Johann Sebastian Bach. Patrons avançats de ternes Ara ja sabem els fills d'en Johann Sebastian Bach -més concretament: tots els ítems que tenen com a pare en Johann Sebastian Bach. Però Bach va tenir dues esposes i, per tant, aquests ítems tenien dues mares diferents: i si només volem veure els fills de Johann Sebastian Bach amb la seva primera dona, Maria Barbara Bach (Q57487)? Proveu a escriure aquesta consulta, utilitzant l'anterior com a exemple.Ja ho heu fet? Fem un cop d'ull a la solució! La manera més senzilla és fer-ho afegint una segona terna amb aquesta restricció: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339.
  ?fill wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En català, això és llegiria com: Fill té pare Johann Sebastian Bach. Fill té mare Maria Barbara Bach. Sona estrany, oi? En llenguatge natural, ho hauríem abreujat així: Fill té pare Johann Sebastian Bach i mare Maria Barbara Bach. De fet, és pot expressar la mateixa abreviació en SPARQL: si acabeu una terna amb punt i coma (;), en comptes de amb un punt, podeu afegir un altre parell predicat-complement directe. Això ens permet abreujar la consulta anterior com: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! que ofereix el mateix resultat, però la consulta és més concisa.Ara suposem que, dels resultats, només ens interessen els fills que eren compositors i pianistes. Les propietats i ítems rellevants son occupation (P106), composer (Q36834) i pianist (Q486748). Feu la prova d'actualitzar la consulta anterior amb aquestes restriccions!Aquesta és la meva solució: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Aquí s'utilitza l'abreviació ; dos cops més per a afegir les dues ocupacions requerides. Però ja us haureu adonat que encara hi ha algunes repeticions. Això és com si diguéssim: Fill té l'ocupació compositor i l'ocupació pianista. que podríem abreujar com: Fill té ocupació compositor i pianista. I l'SPARQL té sintaxi per a això també: de la mateixa forma que ; us permet afegir un parell predicat-complement directe a una terna (reutilitzant el subjecte), una , ens permet afegir un altre complement directe a la terna (reutilitzant tant el subjecte com el predicat). Amb això, la consulta es pot abreujar com: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Nota: la indentació i altres espais en blanc realment no son importants -només fan el codi més llegible. També es pot escriure com: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # les dues ocupacions en una línia
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! o, força menys llegible: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # sense indentació; costa bastant distingir entre ; i ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Per sort, l'editor de WDQS indenta les línies de forma automàtica i habitualment no us n'heu de preocupar.Fem un resum: Hem vist que les consultes s'estructuren com a text. Cada terna sobre un subjecte s'acaba amb un punt. Diversos predicats sobre el mateix subjecte es poden separar amb punt i coma, i diversos complements directes del mateix subjecte i predicat es poden llistar separats per comes. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Ara introduirem una abreviació més que ofereix l'SPARQL. Imaginem un altre escenari hipotètic...Suposem que no volem els fills d'en Bach. Però estem interessants en els seus nets. Tenim una complicació aquí: els nets poden relacionar-se amb en Bach mitjançant la mare o el pare, que son dues propietats diferents. Fem-ho diferent, capgirem la relació: Wikidata també té la propietat «fill», P:P40, que apunta de pare a fill i és independent del gènere. Amb aquesta informació, podeu escriure la consulta que retornaria els nets d'en Bach?Aquesta és la solució proposada: SELECT ?net ?netLabel
WHERE
{
  wd:Q1339 wdt:P40 ?fill.
  ?fill wdt:P40 ?net.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En llenguatge natural, això es llegeix com: Bach té un fill ?fill. ?fill té un fill ?net. Un cop més, podem abreujar la frase en català i, després, veurem com l'SPARQL permet fer la mateixa abreviació. Observem com, de fet, no ens importa el fill: només utilitzem la variable per relacionar-la amb el net. Podem, per tant, abreujar la frase com: Bach té com a fill algú que té com a fill ?net. En comptes de dir qui és el fill d'en Bach, només diem «algú»: no ens importa qui és. Però podem utilitzar-los de referència per què diem «algú «que»»: això inicia una clàusula relativa, i dins d'aquesta clàusula relativa hi podem dir coses com «algú» (per exemple, «que tingui un fill ?net»). En certa manera, «algú» és una variable, però una d'especial que només és vàlida dins d'una clàusula relativa, i una a la qual no ens hi referim de forma explícita (diem, «algú que és X i fa Y» -això són dos «algú» diferents).En SPARQL, això es pot escriure com: SELECT ?net ?netLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?net ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Podeu utilitzar un parell de claudàtors ([]) al lloc d'una variable, que actuarien com una variable anònima. Dins d'aquests claudàtors, podem especificar-hi parells predicat-complement directe, tal i com ho fem després de ; després d'una terna normal; el subjecte implícit és, en aquest cas, la variable anònima que representen els claudàtors. (Nota:igual que després de ;, podeu afegir més parells de predicat-complement directe amb més punts i coma, o més objectes pel mateix predicat amb comes).I això és tot sobre els patrons de ternes! Hi ha molt més a parlar d'SPARQL, però com que estem a punt de deixar les parts que tenen relació directa amb el llenguatge natural, resumirem aquesta relació un altre cop: llenguatge natural exemple SPARQL exemple frase Julieta estima Romeo. punt julieta estima romeo. conjunció (clàusula) Romeo estima Julieta i mata ell mateix. punt i coma romeo estima julieta; mata romeo. conjunció (nom) Romeo mata Tybalt i ell mateix. coma romeo mata tybalt, romeo. clàusula relativa Julieta estima algú que mata Tybalt. claudàtors julieta estima [ mata tybalt ].  Instàncies i classes Abans, hem dit que la majoria de propietats de Wikidata contenen relacions de «té»: «té» fill, «té» pare, «té» ocupació. Però algun cop (de fet, sovint), també hem de parlar de que alguna cosa «és». Però, de fet, això són dos tipus de relacions: Allò que el vent s'endugué és una pel·lícula. Una pel·lícula és una obra d'art. Allò que el vent s'endugué és una pel·lícula en concret. Té un director concret (Victor Fleming), una durada concreta (238 minuts), un repartiment (Clark Gable, Vivien Leigh, etc), i més coses.Pel·lícula és un concepte general. Les pel·lícules poden tenir directors, durades i actors del repartiment, però el concepte «pel·lícula» com a tal no té cap director, durada, ni intèrprets. I tot i que una pel·lícula és una obra d'art, i les obres d'art acostumen a tenir un creador, el concepte de «pel·lícula» no té un creador -només «instàncies» concretes d'aquest concepte en tenen.Aquesta diferència és la raó pel què hi ha dues propietats «és» a Wikidata: instance of (P31) i subclass of (P279). «Allò que el vent s'endugué» és una instància concreta de la classe «pel·lícula»; la classe «pel·lícula» és una subclasse (més específicament, una especialització d'una classe) d'una classe més general, «obra d'art».Per ajudar-vos a entendre la diferència, podeu provar a utilitzar dos verbs diferents: «és un» i «és una mena de». Si «és una mena de» funciona (per exemple: una pel·lícula «és una mena de» obra d'art), indica que estem parlant d'una subclasse, d'una especialització d'una classe més general i que hauríem d'utilitzar subclass of (P279). Si «és una mena de» no funciona (per exemple: la frase Allò que el vent s'endugué «és una mena de» pel·lícula no té sentit), indica que estem parlant d'una instància concreta i que hem d'utilitzar instance of (P31).Així, què implica això quan estem escrivint consultes d'SPARQL? Quan volem buscar «totes les obres d'art», no és suficient buscar tots els ítems que són directament instàncies d'«obra d'art». SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31 wd:Q838948. # instància d'obra d'art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mentre escric això (octubre de 216), la consulta retorna solament 2.815 resultats, però, evidentment, existeixen més obres d'art! El problema és que no obtenim elements com ara Allò que el vent s'endugué, que és solament una instància de «pel·lícula», no d'«obra d'art». «Pel·lícula» és una subclasse d'«obra d'art», però li hem de dir a l'SPARQL que ho ha de tenir en compte en fer la cerca.Una solució possible és la sintaxi amb [] que hem comentat abans: Allò que el vent s'endugué és una instància d'alguna subclasse d'«obra d'art». (Com a exercici, proveu a escriure aquesta consulta!) Però això encara genera problemes: No hi incloem ítems que son instàncies directes d'obra d'art. Encara estem obviant ítems que són instàncies d'alguna subclasse d'alguna altra subclasse d'«obra d'art – per exemple, Blancaneus i els set nanets és una pel·lícula animada, el qual és una pel·lícula, que és una obra d'art. En aquest cas, hem de seguir dues declaracions de «subclasse de» – però també podrien ser tres, o quatre, o cinc, qualsevol nombre, de fet. La solució: ?item wdt:P31/wdt:P279* ?class. Això significa que hi ha una «instància de» i després qualsevol nombre de declaracions «subclasse de» entre l'ítem i la classe. SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31/wdt:P279* wd:Q838948. # instància de qualsevol subclasse d'obra d'art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (no recomanem executar aquesta consulta. WDQS ho pot suportar (amb prou feines), però el vostre navegador pot blocar-se en intentar mostrar els resultats, per la gran quantitat que n'obtindrà).Ara sabeu com cercar totes les obres d'art, o edificis, o establiments humans: la màgia de wdt:P31/wdt:P279*, acompanyat de la classe apropiada. Això utilitza més característiques d'SPARQL de les que hem explicat fins ara però, sincerament, és gairebé l'únic rellevant d'aquestes característiques, així que «no necessitem» entendre com funciona a fi d'utilitzar WDQS de forma efectiva. Si ho voleu aprendre ho explicarem en breu, però també podeu saltar-vos la propera secció i memoritzar, o copiar, wdt:P31/wdt:P279* per a quan ho necessiteu. Rutes de propietats En general, el camí que connecta el node font (subjecte) amb el node destinació (objecte) a través del gràfic no és sempre directe: és possible que calgui concatenar zero, un o molts enllaços (segments, és a dir, \"elements del camí\") en una cadena; i hi pot haver diversos d'aquests camins (rutes). L'objecte d'un element de camí de la cadena esdevé el subjecte de l'element següent. A SPARQL, les rutes de propietats són una forma concisa d'escriure la ruta de propietats entre dos ítems. La ruta més simple és una sola propietat, la qual forma una terna normal: ?item wdt:P31 ?class. Podeu afegir elements de ruta amb una barra inclinada (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Això és equivalent a qualsevol dels següents: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercici: reescriure la consulta dels «nets de Bach» amb aquesta sintaxi.Un asterisc (*) després d'un element de ruta significa «zero o més d'aquests elements». ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> Si no hi ha elements a la ruta, ?a algunacosa* ?b significa que ?b pot només ser ?a de forma directa, sense elements de ruta entre ells. Un signe (+) és similar a un asterisc, però significa «un o més d'aquests elements». La consulta següent troba tots els descendents de Bach: SELECT ?descendent ?descendentLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendent.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Si aquí utilitzem un asterisc, en comptes d'un signe de suma, la consulta inclourà el mateix Bach.Un signe d'interrogació (?) és similar a un asterisc o un signe de suma, però significa «zero o cap d'aquests elements».Podeu separar elements de ruta amb una barra vertical (|) en comptes de amb una barra inclinada; això significa «un o altre»: el camí pot tenir qualsevol de les propietats llistades. (Però no combinades - un segment de ruta «un o altre» sempre coincideix amb rutes de longitud 1).També podem agrupar elements de ruta amb parèntesi (()), i combinar tots aquests elements sintàctics (/|*+?). Això significa que una altra manera de trobar tots els descendents de Bach, és: SELECT ?descendent ?descendentLabel
WHERE
{
  ?descendent (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En comptes d'utilitzar la propietat «fill» per anar des de Bach als seus descendents, utilitzem les propietats «pare» i «mare» per anar dels descendents a Bach. La ruta hauria d'incloure dues mares i un pare, o quatre pares, o pare-mare-mare-pare, o qualsevol altra combinació. (Tot i que, per suposat, Bach no pot ser la mare de ningú, així que l'últim element ha de ser sempre pare). Qualificadors (Primer les bones notícies: aquesta secció no introdueix més sintaxi d'SPARQL - visca! Respireu a fons i relaxeu-vos, això hauria de ser senzill, oi?)Fins ara només hem parlat de declaracions senzilles: subjecte, propietat, complement directe. Però les declaracions de Wikidata son més que això: també poden tenir qualificadors i referències. Per exemple, la Mona Lisa (Q12418) té tres declaracions made from material (P186). oil paint (Q296955), el material principal; poplar wood (Q291034), amb el qualificador applies to part (P518)painting support (Q861259) – aquest és el material on es va pintar la Mona Lisa; i wood (Q287), amb els qualificadors applies to part (P518)stretcher (Q1737943) i start time (P580) 1951 – aquesta és una part que es va afegir després a la pintura.. Suposem que volem trobar totes les pintures que tenen una superfície concreta, o sigui, les declaracions made from material (P186) amb un qualificador applies to part (P518)painting support (Q861259) . Com ho podem fer? Aquesta és més informació de la que es pot representar amb una terna senzilla.La resposta és: més ternes! (Regla general: la solució de Wikidata per a gairebé tot és «més ternes». Referències, precisió numèrica, valors amb unitats, coordenades, etc, ple de coses que aquí no tractem, també funcionen així). Fins ara, hem utilitzat el prefix wdt: per les nostres declaracions de ternes, que apunten directament al complement directe de la declaració. Però també hi ha un altre prefix: p:, que no apunta al complement directe si no a un «node de declaració». Aquest node després és el subjecte d'altres ternes: el prefix ps: (per a property statement -declaració en anglès-) apunta a la declaració del complement directe, el prefix pq: (propietat qualificador) als qualificadors i prov:wasDerivedFrom apunta als nodes de referència (els quals per ara ignorarem).Això ha estat un munt de text abstracte. Aquí tenim un exemple concret amb la Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Podem abreujar això un piló amb la sintaxi [], reemplaçant la ?statement de variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Podem utilitzar aquest coneixement per escriure una consulta de totes les pintures amb la seva superfície de pintura?Aquesta és la solució proposada: SELECT ?quadre ?quadreLabel ?material ?materialLabel
WHERE
{
  ?quadre wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Primer, limitem ?quadre a totes les instàncies amb painting (Q3305213) o una subclasse d'això. Després, extraiem el material del node de declaració p:P186, limitant les declaracions a aquelles que tenen un qualificador applies to part (P518)painting support (Q861259) . ORDER i LIMIT Tornem al nostre programa habitual per a més característiques d'SPARQL.Fins ara, només hem vist consultes en les que volíem totes les coincidències. Però és prou habitual necessitar només uns quants resultats: aquells que son més extrems, d'alguna manera - més vells, més joves, primers, últims, amb més població, amb menor punt de fusió, amb més fills, més materials usats, etc. El factor comú és que els resultats es classifiquen d'alguna forma, i després ens interessen els primers resultats (els que son més importants).Això es controla amb dues clàusules, les quals s'afegeixen al bloc WHERE {} (després de les claus, no dins!): ORDER BY i LIMIT.ORDER BY alguna cosa ordena els resultats per alguna cosa. alguna cosa pot ser qualsevol expressió -per ara i tant, l'única forma d'expressió que coneixem son variables senzilles (?alguna cosa), però aviat en veurem algunes d'altres tipus. Aquesta expressió també es pot embolcallar dins ASC() o DESC() per a especificar l'ordre d'ordenació (ascendent o descendent). (Si no voleu especificar cap de les dues coses, l'opció predeterminada és ordenació ascendent, així que ASC(something) equival a només alguna cosa.)LIMIT nombre retalla la llista de resultats a nombre resultats, on nombre és qualsevol nombre natural. Per exemple, LIMIT 10 limita la consulta a 10 resultats. LIMIT 1 només retorna un resultat.(També es pot utilitzar LIMIT sense ORDER BY. En aquest cas, els resultats sortiran sense ordenar, així que no tindrem cap garantia de quin resultat obtindrem. El qual està bé si sabem que hi ha un nombre limitat de resultats, o si només estem interessats en alguns resultats, però no us preocupa quins. En qualsevol cas, afegint LIMIT pot accelerar de forma significativa la consulta, perquè WDQS aturarà la cerca bon punt tingui la quantitat de resultats que se li han demanat.)Temps d'exercici! Proveu d'escriure una consulta que retorni el deu països més poblats. (Un país és un sovereign state (Q3624078), i la propietat per a població és P:P1082.) Podeu començar buscant països amb la seva població, i després afegir-hi les clàusules ORDER BY i LÍMIT.Aquesta és la solució proposada: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Preneu nota de que si volem els països més poblats, ho hem d'ordenar de forma descendent, per fer que els primers resultats siguin els de valors més alts. Exercici Hem cobert molta matèria fins ara – és hora de fer alguns exercicis (podeu saltar-vos aquesta secció si teniu pressa.) Llibres d'Arthur Conan Doyle Escriviu una consulta que retorni tots els llibres de Sir Arthur Conan Doyle. Suggeriment Els ítems i propietats rellevants, son: Arthur Conan Doyle (Q35610), author (P50). Solució d'exemple SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Elements químics Escriviu una consulta que retorni tots els elements químics amb el seu símbol i nombre atòmic, ordenats pel nombre atòmic. Suggeriment Els ítems i les propietats rellevants, son: chemical element (Q11344), element symbol (P246), atomic number (P1086). Solució d'exemple SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  Rius que desemboquen al Mississippi Escriviu una consulta que retorni tots els dius que desemboquen directament al riu Mississippi. (El repte més complicat és trobar la propietat correcta). Suggeriment Els ítems i propietats rellevants, son: Mississippi River (Q1497), mouth of the watercourse (P403). Solució d'exemple SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Rius que desemboquen al Mississippi II Escriviu una consulta que retorni tots els rius que desemboquen, de forma directa o indirecta, al riu Mississippi. Suggeriment Aquesta consulta és gairebé idèntica a l'anterior. La diferència és que aquest cop necessiteu una ruta en comptes d'una terna. (si us heu saltat la secció sobre rutes, salteu-vos també aquest exercici). Solució d'exemple SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL En els exercicis anterior, hi teníem una consulta de tots els llibres de Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Però això és avorrit. Hi ha moltes més dades potencials sobre llibres, i només mostrarem l'etiqueta? Provem a muntar una consulta que també inclogui title (P1476), illustrator (P110), publisher (P123) i publication date (P577).Un primer intent podria ser així: SELECT ?llibre ?titol ?illustradorLabel ?editorLabel ?publicat
WHERE
{
  ?llibre wdt:P50 wd:Q35610;
        wdt:P1476 ?titol;
        wdt:P110 ?illustrador;
        wdt:P123 ?editor;
        wdt:P577 ?publicat.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Executeu aquesta consulta. Mentre escric això, només retorna dos resultats – una mica escàs! Per què passa això? Abans hem trobat més de dos-cents llibres!La raó és que per a coincidir amb la consulta, un resultat potencial (un llibre) ha de coincidir a totes les ternes demanades: ha de tenir un títol, un il·lustrador, un editor i una data de publicació. Només que falti una d'aquestes propietats, ja no coincidirà. I això no és el que volem, en aquest cas: primer volem una llista de tots els llibres i, si hi ha dades addicionals disponibles, les volem incloure, però en cap cas volem limitar la llista de resultats.La solució és dir-li al WDQS que aquelles ternes son opcionals: SELECT ?llibre ?titol ?illustradorLabel ?editorLabel ?publicat
WHERE
{
  ?llibre wdt:P50 wd:Q35610.
  OPTIONAL { ?llibre wdt:P1476 ?titol. }
  OPTIONAL { ?llibre wdt:P110  ?ilustrador. }
  OPTIONAL { ?llibre wdt:P123  ?editor. }
  OPTIONAL { ?llibre wdt:P577  ?publicat. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Això ens dona les variables addicionals (?titol, ?editor, etc.). Si l'element existeix, però no té les declaracions opcionals, no es descarta el resultat, si no que, senzillament, la variable queda buida.Nota: és molt important utilitzar clàusules OPTIONAL separades aquí. Si posem totes les ternes en una sola clàusula, com aquí – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – us adonareu que la majoria de resultats no inclouen cap informació extra. Això és per què una clàusula opcional amb diverses ternes només coincidirà si totes les ternes coincideixen. O sigui: si un llibre té títol, té il·lustrador, té editor i data de publicació, aleshores la clàusula opcional coincideix i aquests valors es passaran a la variable corresponent. Però, per exemple, si un llibre té títol però no té il·lustrador, falla tota la clàusula i el resultat no mostrarà cap de les quatre variables demanades. Expressions, FILTER i BIND Aquesta secció pot semblar més desorganitzada que les altres, per què cobreix un tema prou ampli i divers. El concepte bàsic és que volem fer alguna cosa amb els valors que, fins ara, només hem seleccionat i retornat sense més. I la forma de fer aquesta mena d'operacions sobre valors és amb «expressions». Hi ha molts tipus d'expressions i es poden fer un munt de coses amb elles però, abans de res, comencem amb el més bàsic: tipus de dades. Tipus de dades Cada valor és d'un tipus a SPARQL, el qual indica quina mena de valor és i què podem fer amb ell. Els tipus més importants, son: ítem, com wd:Q42 per a Douglas Adams (Q42). booleà, que té dos valors possibles cert i fals. Els valors booleans no es desen en declaracions, però moltes expressions retornen valors booleans, per ex. 2 < 3 (cert) o \"a\" = \"b\" (fals). cadena de text, un tros de text. Les cadenes de text que son literals s'escriuen entre dobles cometes. text monolingüe, una cadena de text associada a una etiqueta d'idioma. En un literal, hi podem afegir l'etiqueta de l'idioma després de la cadena amb un símbol @ , per ex. \"Douglas Adams\"@ca. nombres, tant enters (1) com decimals (1.23). dates. Els literals de dates es poden escriure afegint ^^xsd:dateTime (distingeix majúscules i minúscules – ^^xsd:datetime no funcionarà!) a una ISO 8601 cadena de data: \"2012-10-29\"^^xsd:dateTime.  Operadors També tenim disponibles els operadors matemàtics habituals: +, -, *, / per sumar, restar, multiplicar o dividir nombres, <, >, =, <=, >= per comparar-los. La prova de no-igualtat ≠ s'escriu !=. Altres tipus de dades també tenen definida la igualtat; per exemple, \"abc\" < \"abd\" és cert (comparació lèxica), com també ho fan \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime i wd:Q4653 != wd:Q283111. Les comparacions booleanes es poden combinar amb && (and lògic: a && b torna cert si ambdós both a and b son certs) i || (or lògic: a || b torna cert si qualsevol dels dos (o tots dos) de a i b son certs). FILTER Info Per a una versió alternativa i, a vegades, més ràpida que FILTER, podem utilitzar MINUS, vegeu l'exemple.FILTER(condition). és una clàusula que podem inserir a la nostra consulta d'SPARQL per a filtrar-ne els resultats. Dins del parèntesi hi podem posar qualsevol expressió de tipus booleà, i només mostrarà els valors que retornin cert a l'expressió.Per exemple, per a tenir una llista de tots els humans nascuts l'any 2015, primer llistem tots els humans per la data de naixement – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – i després ho filtrem a fi de que només ens torni els resultats dels quals la data de naixement sigui 2015. Hi ha dues formes de fer-ho: extraient l'any de la data amb la funció YEAR, i verificant que sigui 2015 – FILTER(YEAR(?dob) = 2015). – o revisant que la data estigui entre el primer de gener de 2015 (inclòs) i el primer de gener de 2016 (exclòs): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Probablement la primera opció sigui més clara, però resulta que la segona és molt més ràpida, o sigui que utilitzem-la: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Una altra possible utilitat de FILTER té relació amb les etiquetes. El servei d'etiquetes és molt útil si només volem mostrar l'etiqueta d'una variable. Però si volem operar amb l'etiqueta – per exemple: comprovar si comença amb “Sr. ” – veurem que no funciona: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! Aquesta consulta troba totes les instàncies de fictional human (Q15632617) i comprova si la seva etiqueta comença amb \"Sr. \" (STRSTARTS és la contracció (en anglès) de «la cadena comença amb»; també tenim STRENDS i CONTAINS). La raó per la qual això no funciona és per què el servei d'etiquetes afegeix les seves variables cap al final de l'avaluació de la consulta; en el punt en el qual intentem filtrar amb ?personLabel, el servei d'etiquetes encara no ha creat aquesta variable.Afortunadament, el servei d'etiquetes no és l'única forma d'obtenir l'etiqueta d'un ítem. Les etiquetes també es desen com a ternes normals, utilitzant el predicat rdfs:label. Per suposat, això és així amb totes les etiquetes, no només amb les que són en anglès; si només les volem en un idioma, haurem de filtrar per l'idioma de l'etiqueta: FILTER(LANG(?label) = \"en\"). La funció LANG retorna l'idioma d'una cadena de text monolingüe i aquí només seleccionem les etiquetes que sonen català. La consulta completa, és: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Sr. \")).
}
 Try it! Obtenim l'etiqueta amb la terna ?human rdfs:label ?label, ho restringim a les etiquetes en català i després verifiquem que comenci per «Sr. ».També es pot utilitzar FILTER amb una expressió regular. A l'exemple següent SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Si la restricció de format d'una ID és [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! És possible filtrar i eliminar elements específics com aquest FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) És possible filtrar i obtenir elements que siguin buits: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Aquestes tres característiques se solen utilitzar conjuntament, així que primer les explicarem les tres i després veurem alguns exemples.Una clàusula BIND(expressió AS ?variable). es pot utilitzar per a assignar el resultat d'una expressió a una variable (habitualment una variable nova, però també es pot sobreescriure el valor d'alguna preexistent).BOUND(?variable) comprova si una variable s'ha vinculat a un valor (retorna cert o fals). Sol ser útil per a variables que es posin en una clàusula OPTIONAL.IF(condició,aleshoresExpressió,altramentExpressió) avalua a aleshoresExpressió si condició avalua a cert, i a altramentExpressió si condició avalua a fals. O sigui, IF(cert, \"sí\", \"no\") avalua a \"sí\", i IF(fals, \"genial\", \"terrible\") avalua a \"terrible\".BIND es pot utilitzar per a vincular el resultat d'algun càlcul a una variable nova. Pot ser un resultat intermedi d'un càlcul més gran o un resultat directe d'una consulta. Per exemple, per obtenir l'edat de les víctimes de la pena de mort: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # o, com una expressió:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND també es pot utilitzar per a vincular valors constants a variables, a fi d'incrementar-ne la llegibilitat. Per exemple, una consulta que trobi tots els sacerdots que siguin dona: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! es pot reescriure com: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! La part significativa de la consulta, des de ?dona fins ?sacerdot., ara és probablement més llegible. Tot i això, el bloc gran BIND que té just abans és prou confús, així que aquesta tècnica s'ha d'utilitzar amb precaució. (A la interfície d'usuari de WDQS podem posar el punter damunt de qualsevol terme com wd:Q123 o wdt:P123 i veurem l'etiqueta i la descripció de l'entitat. Per tant, ?dona només és més llegible que wd:Q6581072 si obviem aquesta característica.)Les expressions IF s'utilitzen sovint amb condició-expressió fetes amb BOUND. Per exemple, suposem que volem una consulta que mostri alguns humans i que, en comptes de només mostrar-ne l'etiqueta, volem veure el seu pseudonym (P742) si en tenen, i només volem veure l'etiqueta si no tenen pseudònim. Per a això, seleccionem el pseudònim en una clàusula OPTIONAL (ha de ser opcional, no volem descartar resultats que no tinguin pseudònim), i després utilitzem BIND(IF(BOUND(… per seleccionar bé el pseudònim, bé l'etiqueta. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Altres propietats que es poden utilitzar d'una forma semblant, son nickname (P1449), posthumous name (P1786) i taxon common name (P1843) – qualsevol cosa on hi tingui sentit una alternativa.També podem combinar BOUND amb FILTER per a assegurar que com a mínim un dels molts blocs OPTIONAL rep informació. Per exemple, busquem tots els astronautes que han anat a la lluna, així com els membres de Apollo 13 (Q182252) (prou acurat, oi?). Aquesta restricció es pot expressar com una ruta d'una propietat única, així que necessitem una clàusula OPTIONAL per a membre d'alguna missió a la lluna i una altra per a membre de l'Apollo 13. Però només volem seleccionar els resultats que compleixin, com a mínim, una de les dues condicions. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE La funció COALESCE es pot utilitzar com a abreviació del patró BIND(IF(BOUND(?x), ?x, ?y) AS ?z). com a alternativa en cas de fallada pels casos esmentats abans: calen un grapat d'expressions i retorna el primer resultat que avalua sense error. Per exemple, l'alternativa en cas de fallada de més amunt per pseudònim BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). es pot escriure de forma més concisa com BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). també és senzill afegir una etiqueta alternativa en cas de fallada per si tampoc s'ha definit ?writerLabel: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  Agrupant Fins aquí, totes les consultes que hem vist trobaven resultats que complien algunes condicions. En alguns casos, també hi hem inclòs declaracions addicionals de l'ítem (pintures amb materials, llibres de l'Arthur Conan Doyle amb títol i il·lustrador).Però, sovint, no volem una llista de resultats gaire llarga. En canvi, podem fer preguntes com aquesta: Quantes pintures s'han fet sobre tela, fusta de pollancre, etc? Quina ciutat de cada país té més població? Quin és el total d'armes produïdes per fabricant? Qui publica, de mitjana, els llibres més llargs?  Població de ciutats Fem un cop d'ull a la segona pregunta. És prou senzill escriure una consulta que llisti totes les ciutats amb la seva població i nació, ordenades per nació: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Nota: aquesta consulta retorna un piló de resultats, el que us pot portar problemes al navegador. Podeu afegir-hi una clàusula LIMIT)Com que ho estem ordenant per nació, totes les ciutats de la mateixa formaran un bloc contigu de resultats. Per trobar la població més alta en aquest bloc, volem considerar-lo com un grup, i agregar tots els valors de població en un de sol: el màxim. Això es fa amb una clàusula GROUP BY sota del bloc WHERE i amb una funció d'agregació (MAX) a la clàusula SELECT. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! Hem reemplaçat ORDER BY amb un GROUP BY. L'efecte d'això és que els resultats amb el mateix ?country ara s'agrupen en un sol resultat. Això significa que també hem de canviar la clàusula SELECT. Si mantenim la clàusula anterior SELECT ?country ?city ?population, quins ?city i ?population retornarà? Recordeu, hi ha molts resultats dins d'aquest; tots tenen el mateix ?country, així que el podem seleccionar, però com que cadascun té un ?city i ?population diferents, li podem dir al WDQS quins d'aquests valors volem. Aquesta és la feina de la funció d'agregació. En aquest cas, utilitzem MAX: de tots els valors de ?population, seleccionem els màxims de cada grup agregat. (També li hem d'assignar un nom a aquest valor amb la construcció AS, però aquest és un detall menor).Aquesta és la pauta general per a escriure consultes agregades: escriure una consulta normal que retorna les dades que volem (no agrupades, amb molts resultats per cada grup), després afegim la clàusula GROUP BY i hi afegim una funció d'agregació a les variables no agrupades de la clàusula SELECT. Materials de pintura Provem-ho amb una altra pregunta: quantes pintures s'han fet amb cada material? Primer, escriurem una consulta que només retorni totes les pintures amb el seu material (Tingueu cura d'utilitzar només les declaracions made from material (P186) amb el qualificador applies to part (P518)painting support (Q861259) ). SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Seguidament, afegim una clàusula GROUP BY al ?material i, després, una funció d'agregació a l'altra variable seleccionada (?painting). En aquest cas, estem interessats en el nombre de pintures: la funció d'agregació per a això és COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! Un problema amb això és que no tenim l'etiqueta dels materials, així que els resultats no seran senzills d'interpretar. Si afegim la variable d'etiqueta, ens mostrarà aquest error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” és un missatge d'error que veurem sovint si treballem amb consultes agrupades; significa que li falta la funció d'agregació a alguna de les variables seleccionades, o que en té alguna variable que no n'hauria de tenir. En aquest cas, el WDQS interpreta que hi pot haver diverses ?etiquetaMaterial per a cada ?material (tot i que sabem que això no pot passar) i per això es queixa de que no estem especificant cap funció d'agregació per a aquella variable.Una solució és agrupar per diverses variables. Si llistem diverses variables a la clàusula GROUP BY, hi haurà un resultat per a cada combinació d'aquestes variables i podrem seleccionar-les sense cap funció d'agregació. En aquest cas, agruparem tant per ?material com per ?etiquetaMaterial. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! Gairebé ja estem d'aquesta consulta, només ens falta una altra millora: ens agradaria veure primer els materials més utilitzats. Per sort, podem utilitzar les variables d'agregació de la clàusula SELECT (aquí seria ?count) dins d'una clàusula ORDER BY, que és senzill de fer: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! Fem les altres consultes com a exercici. Armes per fabricant Quin és el total d'armes produïdes per cada fabricant? Suggeriment Els ítems i propietats rellevants, son: firearm (Q12796), manufacturer (P176), total produced (P1092). Solució d'exemple SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  Editorials per nombre de pàgines Quina és el nombre mitjà (function: AVG) de pàgines dels llibres per a cada editorial? Suggeriment Els ítems i propietats rellevants, son: publisher (P123), number of pages (P1104). Solució d'exemple SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING Un petit afegitó a aquesta consulta: si mirem els resultats, veurem que el resultat superior té una mitjana extremadament alta, de l'ordre de deu cops la del segon lloc. Una mica d'investigació revela que això és perquè aquell editor (UTET (Q4002388)) només ha publicat un llibre amb la declaració number of pages (P1104), Grande dizionario della lingua italiana (Q3775610), fet que esbiaixa una mica el resultat. Per a treure valors atípics com aquest, podem intentar seleccionar només editors que hagin editat com a mínim dos llibres amb la declaració number of pages (P1104) a Wikidata.Com ho fem això? Podem restringir els resultats amb la clàusula FILTER però, en aquest cas, volem restringir en funció de l'agrupació (el nombre de llibres), no per cap resultat individual. Així, ho farem amb la clàusula HAVING, la qual es pot posar just després de la clàusula GROUP BY i agafa una expressió tal i com fa FILTER: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  Resum de funcions d'agregació Aquest és un breu resum de les funcions d'agregació disponibles: COUNT: el nombre d'elements. També podem escriure COUNT(*) si només volem comptar els resultats. SUM, AVG: la suma o la mitjana de tots els elements, de forma respectiva. Si els elements no son nombres, obtindrem resultats estranys. MIN, MAX: els valors mínim o el màxim de tots els elements, de forma respectiva. Això funciona amb tota mena de tipus de dades. Els nombres s'ordenen de forma numèrica, les cadenes de text i altres tipus, de forma alfabètica. SAMPLE: qualsevol element. Això pot ser útil si sabem que només hi ha un resultat, o si no ens importa especialment quin se'ns retorna. GROUP_CONCAT: concatena tots els elements. Pot ser útil si, per exemple, només volem un resultat d'un ítem però hi volem incloure diverses declaracions d'aquest ítem, com les ocupacions d'una persona. Les diferents ocupacions es podran reagrupar o concatenar a fi de mostrar-les totes en una sola variable en comptes de en diverses línies de resultats. Si us interessa, ho podeu mirar a les especificacions d'SPARQL. De forma addicional, podem afegir un modificador DISTINCT per a qualsevol d'aquestes funcions per a eliminar-ne els duplicats dels resultats. Per exemple, si hi ha dos resultats però ambdós tenen el mateix valor a ?var, aleshores COUNT(?var) tornarà 2 però COUNT(DISTINCT ?var) només tornarà 1. Sovint hem d'utilitzar DISTINCT quan la nostra consulta pot tornar el mateix ítem diversos cops – això pot passar, per exemple, utilitzem ?item wdt:P31/wdt:P279* ?class, i hi ha diverses rutes des de ?item fins ?class: obtindrem un resultat nou per a cadascuna d'aquestes rutes, tot i que els valors dels diferents resultats seran idèntics. (Si no estem agrupant, també podrem eliminar aquests resultats duplicats començant la consulta amb un SELECT DISTINCT en comptes d'un SELECT.) wikibase: Etiquetes i agregacions Una consulta com la següent, que busca a Wikidata totes les persones acadèmiques amb ciutadania de més de dos països, no mostra el nom d'aquests països a la columna ?citizenships: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! Per mostrar la columna ?citizenships, indiqueu explícitament ?personLabel i ?citizenshipLabel a la crida del servei wikibase:label, d'aquesta manera: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidatas frågetjänst, är ett kraftfullt verktyg som erbjuder insyn i Wikidatas innehåll. Denna guide lär dig hur man använder den. Se även Wikimedia Israels interaktiva guide.Innan du skriver din egen SPRAQL-sökfråga, ta en titt på {{Item documentation}} eller någon annan generisk SPARQL-sökfrågemall och se om din sökfråga redan finns där. Contents 1 Innan vi börjar 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Datatyper 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Se även Innan vi börjar While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Chemical elements Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types.  Datatyper Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Information For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, der Wikidata Query Service, ist ein leistungsfähiges Werkzeug, das dir Einblick in die Inhalte von Wikidata verschafft. In diesem Tutorial lernst du, wie du den WDQS benutzen kannst. Siehe auch das interaktive Tutorial von Wikimedia Israel.Bevor du deine eigene SPARQL-Abfrage schreibst, schaue nach, ob deine Abfrage bereits in {{Item documentation}} oder den anderen SPARQL-Beispielvorlagen enthalten ist. Contents 1 Bevor wir beginnen 2 SPARQL-Basics 3 Unsere erste Abfrage 3.1 Autovervollständigung 4 Fortgeschrittene Tripelmuster 5 Instanzen und Klassen 5.1 Eigenschaftspfade 6 Qualifikatoren 7 ORDER und LIMIT 7.1 Übung 7.1.1 Bücher von Arthur Conan Doyle 7.1.2 Chemische Elemente 7.1.3 Flüsse, die in den Mississippi fließen 7.1.4 Flüsse, die in den Mississippi fließen II 8 OPTIONAL 9 Ausdrücke, FILTER und BIND 9.1 Datentypen 9.2 Operatoren 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Gruppierung 10.1 Einwohnerzahlen von Städten 10.2 Gemäldematerialien 10.3 Waffen nach Hersteller 10.4 Verlage nach Seitenanzahl 10.4.1 HAVING 10.5 Zusammenfassung der Aggregat-Funktionen 10.6 wikibase:Label und Aggregat 11 VALUES 12 Label in multiple languages 13 Und darüber hinaus… 14 Siehe auch Bevor wir beginnen Auch wenn dieser Leitfaden lang und einschüchternd wirkt, lass dich davon nicht abschrecken! Alleine mit den SPARQL-Grundlagen kommst du schon sehr weit. Wenn du nach #Unsere erste Abfrage aufhörst, wirst du schon genug wissen, um viele interessante Abfragen zu erstellen. Mit jedem weiteren Kapitel wirst du in der Lage sein, noch umfangreichere Abfragen zu schreiben.Du hast noch nie von Wikidata, SPARQL oder WDQS gehört? Hier eine kurze Erklärung dieser Begriffe: Wikidata ist eine Wissensdatenbank. Sie enthält Millionen von Aussagen wie zum Beispiel „Die Hauptstadt von Kanada ist Ottawa” oder „Die Mona Lisa wurde mit Ölfarbe auf Pappelholz gemalt” oder „Gold hat einen Schmelzpunkt von 1064,18 Grad Celsius”. SPARQL ist eine Sprache, um Abfragen (Queries) für Wissensdatenbanken zu formulieren. Mit der richtigen Datenbank kann eine SPARQL-Abfrage Fragen wie “Was ist die beliebteste Tonart in der Musik?” oder “Welche Rolle wurde von den meisten Schauspielern gespielt?” oder “Wie ist die Verteilung von Blutgruppen?” oder “Welche Werke von Autoren sind in diesem Jahr frei zugänglich geworden?” beantworten. WDQS, der Wikidata Query Service, bringt diese beiden Dinge zusammen: Du gibst eine SPARQL-Abfrage ein, sie durchsucht die Wikidata-Datensätze und zeigt dir das Resultat.  SPARQL-Basics Eine einfache SPARQL-Abfrage sieht so aus: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Unter SELECT werden die Variablen aufgeführt, die du als Ausgabe haben willst (Variablen beginnen mit einem Fragezeichen) und unter WHERE steht, worauf sie eingeschränkt werden sollen, meistens in Form von Tripeln. Alle Informationen in Wikidata (und ähnlichen Wissensdatenbanken) sind in Tripeln gespeichert. Wenn du die Abfrage durchführst, versucht der Query Service, die Variablen so mit tatsächlichen Werten zu füllen, dass der Tripel in der Wissensdatenbank vorkommt. Zurückgegeben wird dann ein Resultat für jede Kombination von Variablen, die gefunden wird.Ein Tripel kann man wie einen Satz lesen (deshalb endet es auch mit einem Punkt): Es hat ein „Subjekt“, ein „Prädikat“ und ein „Objekt“. Und er hört mit einem Punkt auf. SELECT ?frucht
WHERE
{
  ?frucht hatFarbe gelb.
  ?frucht schmeckt sauer.
} Das Resultat dieser Abfrage könnte zum Beispiel “Zitrone” enthalten. In Wikidata sind die meisten Eigenschaften “hat”-Eigenschaften; die Abfrage sieht somit folgendermaßen aus: SELECT ?frucht
WHERE
{
  ?frucht farbe gelb.
  ?frucht geschmack sauer.
} ... was sich folgendermaßen liest: “?frucht hat farbe ‘gelb’” (nicht “?frucht ist die Farbe von ‘gelb’”. Merk dir das für Eigenschafts-Paare wie “eltern”/“kind”!).Das ist jedoch kein gutes Beispiel für WDQS. Geschmack ist subjektiv, also hat Wikidata dafür keine Eigenschaft. Reden wir stattdessen über Eltern-/Kind-Beziehungen nachdenken, diese sind meistens eindeutig. Unsere erste Abfrage Angenommen wir möchten alle Kinder des Barock-Komponisten Johann Sebastian Bach auflisten. Wie würdest du diese Abfrage schreiben, wenn du Pseudo-Elemente wie im Beispiel oben verwendest?Es sollte etwas in dieser Art sein: SELECT ?kind
WHERE
{
  #  kind \"hat Elternteil\" Bach
  ?kind elternteil Bach
  # (Hinweis: alles nach einem „#“ ist ein Kommentar und wird vom WDQS ignoriert.)
} oder das: SELECT ?kind
WHERE
{
  # kind \"hat Vater\" Bach 
  ?kind vater Bach 
} oder das: SELECT ?kind
WHERE
{
  #  Bach \"hat Kind\" Kind
  Bach unterelement ?kind.
} Die ersten beiden Tripel sagen: ?kind muss den Elternteil/Vater Bach haben; das dritte sagt, dass Bach das Kind ?kind haben muss. Fangen wir erst einmal mit dem zweiten an:Was müssen wir also noch machen, um daraus eine richtige WDQS-Abfrage zu machen? In Wikidata sind Objekte und Eigenschaften nicht mit für Menschen verständlichen Namen wie “Vater” (Eigenschaft) oder “Bach” (Gegenstand) bezeichnet. (Aus gutem Grund: “Johann Sebastian Bach” ist auch der Name eines Deutschen Malers und “Bach” könnte auch ein Vorname, eine Französische Gemeinde, ein Krater auf dem Merkur usw. sein.) Stattdessen teilt Wikidata jedem Objekt und jeder Eigenschaft einen Identifikator zu. Um den Identifikator eines Objekts zu finden, suchen wir das Objekt und kopieren die Q-Nummer des Resultates, welches uns passend erscheint (zum Beispiel aufgrund der Beschreibung). Um den Identifikator für eine Eigenschaft zu finden, machen wir es genauso, suchen aber nach „P:Suchbegriff” statt nur „Suchbegriff”, was unsere Suche auf Eigenschaften beschränkt. Das sagt uns dann, dass der berühmte Komponist Johann Sebastian Bach Q1339 ist und die Eigenschaft, um den Vater eines Gegenstandes zu bestimmen, ist P:P22.Zum Schluss müssen wir noch Präfixe einbinden. Bei einfachen WDQS-Triples sollte Objekten das Präfix wd: und Eigenschaften das Präfix wdt: vorangestellt werden. (Das betrifft aber nur feste Werte, Variablen bekommen kein Präfix!)Zusammengenommen erhalten wir unsere erste richtige WDQS-Abfrage: SELECT ?kind
WHERE
{
# ?kind vater Bach
  ?kind wdt:P22 wd:Q1339.
}
 Try it! Klicke auf den Link „Versuche es” und dann „Abfrage ausführen” auf der WDQS-Seite. Was ist das Ergebnis? kind wd:Q57225 wd:Q76428 … Das Ergebnis ist enttäuschend: Du siehst nur die Identifikatoren der Ergebnisse. Du kannst auf diese Identifikatoren klicken und die dazugehörige Wikidata-Seite (mit verständlichen Beschriftungen) öffnen. Aber kann man die Ergebnisse nicht besser anzeigen?Nun, tatsächlich, das kannst du! (Sind rhetorische Fragen nicht großartig?) Indem du die Zauberworte SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } irgendwo innerhalb des WHERE-Abschnitts einfügst, erhältst du zusätzliche Variablen: Für jede Variable ?foo hast du jetzt eine Variable ?fooLabel, der die Bezeichnung für ?foo beinhaltet. Wenn Du also diese Variable dem SELECT-Abschnitt hinzufügst, wird auch die Bezeichnung angezeigt. SELECT ?kind ?kindLabel
WHERE
{
# ?kind vater Bach
  ?kind wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Probiere die Anfrage aus. Du solltest nun nicht nur die Objektnummern sehen, sondern auch die Namen der verschiedenen Kinder. kind kindLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autovervollständigung Dieses SERVICE-Snippet lässt sich jedoch schwer merken. Und beim Schreiben einer Abfrage die ganze Zeit in der Suchfunktion nachzuschlagen ist umständlich. Glücklicherweise bietet WDQS eine ausgezeichnete Lösung für dieses Problem: „Autovervollständigung”. Im query.wikidata.org Abfrage-Editor kannst du an jedem Punkt der Abfrage mit Strg+Leertaste (oder Alt+Eingabe oder Strg+Alt+Leertaste) Vorschläge für möglicherweise passenden Code angezeigt bekommen. Wähle den richtigen Vorschlag mit den Pfeiltasten nach oben/nach unten aus und bestätige mit der Enter-Taste.Beispielsweise kannst du, statt jedes Mal SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } zu schreiben, einfach SERV tippen, dann Ctrl+Leertaste betätigen. Der erste Vorschlag wird immer der gesamte Label-Service-Aufruf sein, bereit zum Einsatz! Betätige einfach Enter um den Vorschlag anzunehmen. (Die Formatierung wird ein bisschen anders sein, aber das macht nichts.)Die Autovervollständigung kann dir auch beim Suchen helfen. Wenn du eines der Wikidata-Präfixe eingibst, wie zum Beispiel wd: oder wdt:, und dann einfach Text hintendran schreibst, kannst du mit Ctrl+Leertaste eine Suche nach diesem Text in Wikidata veranlassen und dir Suchergebnisse zeigen lassen. wd: sucht nach Datenobjekten, wdt: nach Eigenschaften. Ein Beispiel: Statt nach den Objekten für Johann Sebastian Bach (Q1339) und father (P22)zu suchen, kannst du wd:Bach und wdt:Vat eingeben und dann einfach den richtigen Eintrag aus der Autovervollständigung wählen. (Das funktioniert auch mit Leerzeichen im Text, z. B. wd:Johann Sebastian Bach.) Fortgeschrittene Tripelmuster Jetzt haben wir also alle Kinder von Johann Sebastian Bach gesehen, genauer gesagt: alle Objekte mit dem Vater Johann Sebastian Bach. Aber Bach war zweimal verheiratet, und diese Objekte können verschiedene Mütter haben. Was ist, wenn wir nur die Kinder von Johann Sebastian Bach und seiner ersten Ehefrau, Maria Barbara Bach (Q57487), sehen möchten? Versuche diese Abfrage zu schreiben, basierend auf der von weiter oben.Fertig? OK, dann zur Lösung!Am einfachsten machst du es, indem du ein zweites Tripel mit dieser Beschränkung hinzufügst: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339.
  ?kind wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Übersetzt heißt das: Kind hat Vater Johann Sebastian Bach. Kind hat Mutter Maria Barbara Bach. Klingt ein bisschen umständlich, oder? In natürlicher Sprache würden wir das abkürzen: Kind hat Vater Johann Sebastian Bach und Mutter Maria Barbara Bach. Du kannst diese Abkürzung auch in SPARQL ausdrücken: Wenn du ein Tripel mit einem Semikolon (;) statt mit einem Punkt beendest, kannst du ein weiteres Eigenschaft-Objekt-Paar hinzufügen. Damit verkürzt sich die obige Abfrage zu: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Das ergibt dieselben Ergebnisse – ohne Wiederholungen in der Abfrage.Angenommen, von all diesen Ergebnissen interessieren uns nur die Kinder, die auch Komponisten und Pianisten waren. Die relevanten Eigenschaften und Objekte sind occupation (P106), composer (Q36834) und pianist (Q486748). Versuche, die vorige Abfrage anzupassen, um diese Beschränkung hinzuzufügen!Hier ist meine Lösung: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Diese Lösung verwendet die Abkürzung \";\" zwei weitere Male, um die zwei geforderten Berufe hinzuzufügen. Aber wie du vielleicht merkst, gibt es immer noch Wiederholungen. Es ist als ob wir sagen würden: Das Kind hat den Beruf Komponist und den Beruf Pianist. Das würden wir normalerweise so abkürzen: Das Kind hat die Berufe Komponist und Pianist. SPARQL hat auch hierfür die passende Syntax: Genauso wie ein ; es dir ermöglicht, einem Tripel ein Prädikat-Objekt-Paar hinzuzufügen (unter Wiederverwendung des Subjekts), erlaubt ein , es dir, einem Tripel ein weiteres Objekt hinzuzufügen (unter Wiederverwendung sowohl des Subjekts als auch des Prädikats). So kann die Abfrage wie folgt abgekürzt werden: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Beachte: Einzüge und Leerzeichen spielen keine Rolle, sie machen es nur leichter lesbar. Man könnte es auch so schreiben: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # beide Berufe in einer Zeile
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! oder, nicht so gut lesbar: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # ohne Einzüge. Das macht es schwierig, zwischen ; und , zu unterscheiden.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Glücklicherweise rückt der WDQS-Editor Zeilen automatisch ein, d. h. du musst dich normalerweise nicht darum kümmern.Gut, lasst uns hier mal zusammenfassen. Wir haben gesehen, dass Abfragen wie Text strukturiert sind. Jedes Tripel zu einem Subjekt wird mit einem Punkt beendet. Verschiedene Prädikate zum selben Subjekt werden getrennt durch Semikolons und verschiedene Objekte für dasselbe Subjekt und dasselbe Prädikat können getrennt durch Kommas aufgelistet werden. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Jetzt möchte ich dir eine weitere Abkürzung aus dem Repertoire von SPARQL vorstellen. Lass mich dazu wieder ein hypothetisches Szenario beschreiben.Gehen wir davon aus, dass uns Bachs Kinder nicht interessieren. (Wer weiß, vielleicht trifft das ja tatsächlich auf dich zu!). Aber seine Enkelkinder interessieren uns (hypothetisch). Hier wird es kompliziert: Ein Enkelkind kann mit Bach über seine Mutter oder über seinen Vater verwandt sein. Das sind zwei verschiedene Eigenschaften, was unpraktisch ist. Drehen wir lieber die Beziehung um: Wikidata hat auch eine „Kind“-Eigenschaft, P:P40, die vom Elternteil auf das Kind zeigt, und geschlechtsunabhängig ist. Kannst du mithilfe dieser Information eine Abfrage schreiben, die Bachs Enkelkinder ausgibt?Hier ist meine Lösung: SELECT ?enkelkind ?enkelkindLabel
WHERE
{
  wd:Q1339 wdt:P40 ?kind.
  ?kind wdt:P40 ?enkelkind.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Übersetzt heißt das: Bach hat das Kind ?kind. ?kind hat das Kind ?enkelkind. Wieder möchte ich vorschlagen, dass wir diesen Satz abkürzen, und dann möchte ich dir zeigen, wie SPARQL eine ähnliche Abkürzung unterstützt. Du siehst: das Kind ist uns eigentlich egal. Wir verwenden die Variable nur, um etwas über das Enkelkind auszusagen. Wir könnten den Satz also wie folgt abkürzen: Bach hat als Kind jemanden, der das Kind ?enkelkind hat. Statt zu sagen, wer Bachs Kind ist, sagen wir einfach „jemand“: Wer das ist, ist uns egal. Aber wir können auf diese Person verweisen, da wir gesagt haben „jemand der“: Hiermit wird ein Relativsatz angefangen, und innerhalb dieses Satzes können wir Aussagen machen über „jemanden“ (z. B. dass er oder sie „ein Kind ?enkelkind hat“). In gewisser Weise ist „jemand“ eine Variable, aber eine spezielle, die nur gültig ist innerhalb dieses Relativsatzes, und eine, auf die wir nicht explizit verweisen (wir sagen „jemand der dies ist und jenes macht“, nicht „jemand der dies ist und jemand der jenes macht“ - das wären zwei verschiedene Personen).In SPARQL kann dies wie folgt geschrieben werden: SELECT ?enkelkind ?enkelkindLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?enkelkind ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Statt einer Variable kannst du ein Klammernpaar ([]) verwenden, das sich wie eine anonyme Variable verhält. Innerhalb der Klammern kannst du Prädikat-Objekt-Paare spezifizieren, genau so wie nach einem ; nach einem normalem Tripel. Das implizite Subjekt ist in diesem Fall die anonyme Variable, wofür die Klammern stehen. (Anmerkung: genauso wie nach einem ; kannst du mehr Prädikat-Objekt-Paare mit Semikolons hinzufügen, oder mehr Objekte für dasselbe Prädikat mit Kommas.)Und das war’s auch schon mit den Tripelmustern! Es gibt in SPARQL noch mehr davon. Aber wir verlassen jetzt die Bereiche, die der gesprochenen Sprache sehr ähnlich sind. Ich fasse deshalb diesen Zusammenhang noch einmal zusammen: gesprochene Sprache Beispiel SPARQL Beispiel Satz Julia liebt Romeo. Punkt julia liebt romeo. Konjunktion (Klausel) Romeo liebt Julia und tötet sich selbst. Semikolon romeo liebt julia; tötet romeo. Konjunktion (Substantiv) Romeo tötet Tybalt und sich selbst. Komma romeo tötet tybalt, romeo. Relativsatz Julia liebt jemanden der tötet Tybalt. Klammern julia liebt [ tötet tybalt ].  Instanzen und Klassen Vorhin habe ich erzählt, dass die meisten Wikidata-Eigenschaften „hat“-Eigenschaften sind: „hat“ das Kind, „hat“ den Vater, „hat“ den Beruf. Aber manchmal (eher häufig) geht es auch mal um etwas, das „ist“. Tatsächlich gibt es in diesem Fall zwei verschiedene Arten der Beziehung: „Vom Winde verweht“ ist ein Film. Ein Film ist ein Kunstwerk. „Vom Winde verweht“ ist ein bestimmter Film. Er hat einen bestimmten Regisseur (Victor Fleming), eine bestimmte Dauer (238 Minuten), eine Reihe von Darstellern (Clark Gable, Vivien Leigh, …) und so weiter.„Film“ ist ein allgemeines Konzept. Filme können Regisseure, Längen und Darsteller haben, aber das Konzept „Film“ als solches hat keinen bestimmten Regisseur, keine bestimmte Dauer oder keinen bestimmten Darsteller. Und obwohl ein Film ein Kunstwerk ist, und ein Kunstwerk normalerweise einen Urheber hat, hat das Konzept „Film“ selber keinen Urheber – nur bestimmte „Instanzen“ dieses Konzeptes haben einen.Dieser Unterschied ist der Grund, warum es in Wikidata zwei Eigenschaften für „ist“ gibt : instance of (P31) und subclass of (P279). „Vom Winde verweht“ ist eine bestimmte Instanz der Klasse „Film“; die Klasse „Film“ ist eine Unterklasse (spezifischere Klasse; Spezialisierung) der mehr allgemeinen Klasse „Kunstwerk“.Um den Unterschied besser zu verstehen, kannst du zwei verschiedene Formulierungen ausprobieren: „ist ein“ und „ist eine Art von“. Wenn „ist eine Art von“ funktioniert (z.B. ein Film „ist eine Art von“ Kunstwerk), weist das darauf hin, dass du über eine Unterklasse redest – eine Spezialisierung einer größeren Klasse, und du solltest subclass of (P279) verwenden. Wenn „ist eine Art von“ nicht funktioniert (z.B. ergibt der Satz „‚Vom Winde verweht‘ ist eine Art von Film“ wenig Sinn), zeigt das an, dass du über eine bestimmte Instanz redest. Hier solltest du instance of (P31) verwenden.Was bedeutet das für uns, wenn wir SPARQL-Abfragen schreiben? Wenn wir „alle Kunstwerke“ suchen wollen, genügt es nicht, alle Datenobjekte, die unmittelbare Instanzen von „Kunstwerk“ sind, zu suchen: SELECT ?kunstwerk ?kunstwerkLabel
WHERE
{
  ?kunstwerk wdt:P31 wd:Q838948. # Instanz von Kunstwerk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Diese Abfrage ergibt zurzeit (Oktober 2016) 2815 Ergebnisse. Doch natürlich gibt es viel mehr Kunstwerke! Das Problem ist, dass die Abfrage Objekte wie „Vom Winde verweht“ nicht findet. Das Objekt ist eine Instanz von „Film“, nicht aber von „Kunstwerk“. „Film“ ist eine Unterklasse von „Kunstwerk“, aber wir müssen SPARQL sagen, dass das bei der Suche berücksichtigt werden muss.Eine mögliche Lösung hierfür ist die []-Syntax, von der wir gerade sprachen: Vom Winde verweht ist eine Instanz einer bestimmten Unterklasse von „Kunstwerk“. (Versuche diese Abfrage zu schreiben, als Übung!) Aber das verursacht immer noch Probleme: Wir verwenden nun keine Objekte mehr, die eine unmittelbare Instanz von „Kunstwerk“ sind. Objekte, die eine Instanz von Unterklassen von anderen Unterklassen sind, entgehen uns: So ist z.B. Schneewittchen und die sieben Zwerge ein Zeichentrickfilm, was ein Film ist, was ein Kunstwerk ist. In diesem Fall müssen zwei „Unterklasse von“-Aussagen folgen - aber es könnten auch drei, vier, fünf, oder beliebig mehr sein. Die Lösung: ?objekt wdt:P31/wdt:P279* ?klasse. Dies heißt, dass es eine \"Instanz von\" und dann eine beliebige Anzahl von \"Unterklassen von\" Aussagen zwischen dem Datenobjekt und der Klasse. SELECT ?kunstwerk ?kunstwerkLabel
WHERE
{
  ?kunstwerk wdt:P31/wdt:P279* wd:Q838948. # Instanz von einer beliebigen Unterklasse von Kunstwerk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Ich empfehle, diese Abfrage nicht auszuführen. WDQS kann damit (gerade so) umgehen, aber dein Browser könnte beim Versuch abstürzen, die Ergebnisse anzuzeigen, weil die Liste extrem lang ist.)Jetzt weißt du, wie man alle Kunstwerke suchen kann, oder alle Gebäude, oder alle menschlichen Siedlungen: verwende den magischen Aufruf wdt:P31/wdt:P279*, zusammen mit der passenden Klasse. Dies verwendet einige SPARQL-Merkmale die ich noch nicht erklärt habe, aber mal ganz ehrlich, dies ist fast der einzige relevante Gebrauch von diesen Merkmalen, also du \"brauchst\" nicht zu verstehen wie sie funktionieren um WDQS wirksam zu benutzen. Falls du es wissen möchtest: ich erkläre es etwas später, aber du kannst auch einfach den nächsten Abschnitt überspringen und dir wdt:P31/wdt:P279* merken oder es von hier aus kopieren und einfügen, wenn du es benötigst. Eigenschaftspfade Eigenschaftspfade sind eine Möglichkeit, einen Pfad von Eigenschaften zwischen zwei Objekten in sehr kurzer Form auszudrücken. Der einfachste Pfad ist eine einzige Eigenschaft, also ein gewöhnliches Tripel: ?item wdt:P31 ?class. Du kannst Pfadelemente mit einen Schrägstrich (/) hinzufügen. ?item wdt:P31/wdt:P279/wdt:P279 ?class. Dies entspricht einer der folgenden Varianten: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Übung: Schreibe die obige \"Enkelkinder von Bach\"-Abfrage mit dieser Syntax.Ein Sternchen (*) nach einem Pfad-Element bedeutet \"keines oder mehr von diesem Element\". ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> Wenn keine anderen Elemente in dem Pfad sind, bedeutet ?a irgendwas* ?b, dass ?b auch einfach nur direkt ?a sein kann, ohne Pfadelemente zwischen den beiden. Ein + ist ähnlich wie ein *, bedeutet aber \"mindestens eines von diesem Element\". Die folgende Abfrage findet alle Abkömmlinge von Bach: SELECT ?abkoemmling ?abkoemmlingLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?abkoemmling.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Wenn wir ein Sternchen statt des Plus verwendet hätten, würde die Abfrage auch Bach selbst enthalten.Ein Fragezeichen (?) ist ganz ähnlich wie das Sternchen oder das Plus, bedeutet aber \"keines oder genau eines dieses Elements\".Wenn man Pfadelemente mit einem Pipe-Symbol (|) statt des Schrägstrichs trennt, bedeutet dies \"entweder – oder\". Das heißt: der Pfad muss eine dieser Eigenschaften enthalten, es dürfen aber nicht beide gleichzeitig vorkommen. Ein Entweder-Oder-Pfad hat immer die Länge 1.Man kann Pfadelemente auch mit runden Klammern (()) gruppieren, und all diese Syntaxelemente frei kombinieren: /|*+?. Das bedeutet, dass folgendes auch eine Möglichkeit ist, alle Nachkommen von Bach zu finden: SELECT ?abkoemmling ?abkoemmlingLabel
WHERE
{
  ?abkoemmling (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Statt der Eigenschaft \"Kind\", mit der wir von Bach zu seinen Nachkommen gehen, verwenden wir die Eigenschaften \"Vater\" und \"Mutter\", um von den Nachkommen zu Bach zu finden. Der Pfad kann zwei Mütter und einen Vater enthalten, oder vier Väter, oder Vater – Mutter – Mutter – Vater oder jede beliebige andere Kombination (außer natürlich, dass Bach selbst immer ein Vater ist und keine Mutter). Qualifikatoren (Zuerst die gute Nachricht: In diesem Abschnitt wird keine neue SPARQL-Syntax eingeführt – juhu! Also zurücklehnen und genießen, das wird doch ein Kinderspiel, oder?)Bisher haben wir nur einfache Aussagen behandelt: Subjekt, Eigenschaft, Objekt. Aber Wikidata-Aussagen sind mehr: Sie können auch Qualifikatoren und Referenzen enthalten. Zum Beispiel hat die Mona Lisa (Q12418) drei made from material (P186)-Aussagen: oil paint (Q296955), das Hauptmaterial; poplar wood (Q291034), mit dem Qualifikator applies to part (P518)painting support (Q861259) – das ist das Material, auf dem sie gemalt wurde; und wood (Q287), mit den Qualifikatoren applies to part (P518)stretcher (Q1737943) und start time (P580) 1951 – das ist ein Teil, der später hinzugefügt wurde. Wenn wir alle Gemälde mit ihrer Farbschicht finden wollen, also made from material (P186)-Aussagen mit einem Qualifikator applies to part (P518)painting support (Q861259) , wie stellen wir das an? Das ist mehr Information, als wir in einem einfachen Tripel ausdrücken können.Die Antwort ist: mehr Tripel! (Faustregel: Wikidatas Lösung für fast alles ist \"mehr davon\", und die passende WQDS-Regel ist \"mehr Tripel\". Referenzen, Werte mit Einheiten, Geokoordinaten usw., die wir hier alle nicht behandeln, funktionieren genauso.) Bisher haben wir das Präfix wdt: für unsere Tripel genommen, welches direkt auf das Objekt der Aussage verweist. Aber es gibt noch ein anderes Präfix: p:; dieses verweist nicht auf das Objekt, sondern auf einen \"Aussagenknoten\". Dieser Knoten ist dann wiederum das Subjekt weiterer Tripel: Das Präfix ps: (für property statement = Eigenschaftsaussage) verweist auf das Aussageobjekt, das Präfix pq: (property qualifier = Eigenschaftsqualifikator) auf Qualifikatoren und prov:wasDerivedFrom verweist auf Referenzknoten (welche wir hier erst einmal weglassen).Das war viel abstrakter Text. Hier ein konkretes Beispiel für die Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Wir können das deutlich abkürzen mit der []-Syntax, welche die Variable ?statement ersetzt: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Kannst du mit diesem Wissen eine Abfrage für alle Gemälde mit ihrer Farbschicht schreiben?Hier meine Lösung: SELECT ?gemaelde ?gemaeldeLabel ?material ?materialLabel
WHERE
{
  ?gemaelde wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Erst begrenzen wir ?painting auf alle Instanzen von painting (Q3305213) oder deren Unterklassen. Anschließend ziehen wir das Material aus dem Aussagenknoten p:P186, wobei wir die Aussagen auf diejenigen begrenzen, die einen Qualifikator applies to part (P518)painting support (Q861259) besitzen. ORDER und LIMIT Wir kehren nun zurück zu unserer geplanten Vorstellung weiterer SPARQL-Features.Bislang hatten wir nur Abfragen, bei denen wir an allen Ergebnissen interessiert waren. Oft jedoch interessieren uns nur Ergebnisse mit extremen Ausprägungen, zum Beispiel die ältesten, jüngsten, frühesten, spätesten, bevölkerungsreichsten usw. Diesen Abfragen ist gemein, dass die Ergebnisse in eine Rangfolge gebracht werden, und wir dann nur die obersten Ergebnisse dieser Rangfolge betrachten wollen.Dies erreichen wir mit zwei Schlüsselwörtern, die wir hinter dem WHERE {}-Block platzieren (hinter den geschweiften Klammern, nicht dazwischen!): ORDER BY und LIMIT.ORDER BY irgendwas sortiert die Ergebnisse nach irgendwas. Dabei kann irgendwas ein beliebiget Ausdruck sein – bislang kennen wir nur Variablen (?irgendwas) als Ausdrücke, aber es folgen später noch weitere. Dieser Ausdruck kann auch mit ASC() oder DESC() ergänzt werden, um die Ergebnisse aufsteigend (englisch ascending) bzw. absteigend (englisch descending) zu sortieren. (Ohne diese Angabe wird immer aufsteigend sortiert; daher ist ASC(irgendwas) gleichwertig zu irgendwas.)LIMIT anzahl schneidet die Ergebnisliste nach anzahl Ergebnissen ab; count ist dabei eine beliebige natürliche Zahl. LIMIT 10 zum Beispiel begrenzt das Ergebnis auf 10 Elemente. LIMIT 1 gibt nur das allererste Element aus.(Man kann LIMIT auch ohne ORDER BY verwenden. In diesem Fall ist die Gesamtergbnismenge aber nicht sortiert und damit das Ergebnis der Limitierung willkürlich. Das kann in Ordnung sein, wenn man einfach nur einige Ergebnisse haben möchte, egal welche. In jedem Fall kann LIMIT die Abfrage enorm beschleunigen, weil WDQS die Suche beendet, sobald das Limit erreicht wurde.)Zeit für eine Übung! Versuche eine Abfrage über die zehn bevölkerungsreichsten Länder der Erde zu schreiben. (Ein Land ist sovereign state (Q3624078) und die Eigenschaft für die Bevölkerungszahl P:P1082.) Du kannst zuerst nach den Ländern mit ihrer Bevölkerungszahl suchen und dann mit ORDER BY und LIMIT ergänzen.Hier meine Lösung: SELECT ?land ?landLabel ?einwohnerzahl
WHERE
{
  ?land wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?einwohnerzahl.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Beachte, dass wir die Rangfolge absteigend (DESC) setzen müssen, sodass die höchsten Zahlen zuerst kommen. Übung Jetzt haben wir einige Grundlagen gelegt – Zeit für ein paar Übungen. (Eilige können diese überspringen.) Bücher von Arthur Conan Doyle Schreibe eine Abfrage, die alle Bücher von Arthur Conan Doyle ausgibt. Tipp Die relevanten Objekte und Eigenschaften sind Arthur Conan Doyle (Q35610) und author (P50). Beispiellösung SELECT ?buch ?buchLabel
WHERE
{
  ?buch wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Chemische Elemente Schreibe eine Abfrage, die alle chemischen Elemente mit ihrem Elementsymbol und ihrer Ordnungszahl in der Reihenfolge der Ordnungszahl ausgibt. Tipp Die relevanten Objekte und Eigenschaften sind chemical element (Q11344) sowie element symbol (P246) und atomic number (P1086). Beispiellösung SELECT ?element ?elementLabel ?symbol ?ordnungszahl
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?ordnungszahl.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?ordnungszahl
 Try it!  Flüsse, die in den Mississippi fließen Schreibe eine Abfrage, die alle Flüsse ausgibt, die direkt in den Mississippi fließen. (Hauptschwierigkeit ist es, die richtige Eigenschaft zu finden…) Tipp Die relevanten Objekte und Eigenschaften sind: Mississippi River (Q1497), mouth of the watercourse (P403). Beispiellösung SELECT ?fluss ?flussLabel
WHERE
{
  ?fluss wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Flüsse, die in den Mississippi fließen II Schreibe eine Abfrage, die alle Flüsse ausgibt, die direkt oder indirekt in den Mississippi fließen. Tipp Diese Abfrage ist nahezu identisch mit der vorherigen. Der Unterschied liegt darin, dass du diese Mal einen Pfad statt eines Tripels benötigst. (Überspringe diese Aufgabe, wenn du den Abschnitt über Pfade übersprungen hast.) Beispiellösung SELECT ?fluss ?flussLabel
WHERE
{
  ?fluss wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL Bei den obigen Aufgaben hatten wir eine Abfrage für alle Bücher von Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Das ist jedoch etwas langweilig. Es gibt so viele mögliche Daten über Bücher und wir zeigen nur die Bezeichnung? Lass uns versuchen, eine Abfrage zu erstellen, die auch title (P1476), illustrator (P110), publisher (P123) und publication date (P577) enthält.Ein erster Versuch könnte so aussehen: SELECT ?buch ?titel ?illustratorLabel ?verlagLabel ?veröffentlicht
WHERE
{
  ?buch wdt:P50 wd:Q35610;
        wdt:P1476 ?titel;
        wdt:P110 ?illustrator;
        wdt:P123 ?verlag;
        wdt:P577 ?veröffentlicht.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Führe die Abfrage aus. Während ich dies schreibe, gibt es nur zwei Ergebnisse – ein bisschen mager! Warum ist das so? Wir haben zuvor über 100 Bücher gefunden!Der Grund ist, dass ein mögliches Ergebnis (ein Buch), um in diese Abfrage zu fallen, alle angegebenen Eigenschaften haben muss: Es muss einen Titel, einen Illustrator, einen Verlag und ein Veröffentlichungsdatum haben. Wenn es einige dieser Eigenschaften, jedoch nicht alle hat, erfüllt es nicht die Abfrage. Und das ist nicht das, was wir in diesem Fall möchten: Wir wollen primär eine Liste aller Bücher – wenn weitere Daten verfügbar sind, möchten wir diese mit einbeziehen, wir wollen unsere Ergebnisse jedoch nicht darauf beschränken.Die Lösung ist, WDQS zu sagen, dass diese Tripel optional sind: SELECT ?buch ?titel ?illustratorLabel ?verlagLabel ?veröffentlicht
WHERE
{
  ?buch wdt:P50 wd:Q35610.
  OPTIONAL { ?buch wdt:P1476 ?titel. }
  OPTIONAL { ?buch wdt:P110  ?illustrator. }
  OPTIONAL { ?buch wdt:P123  ?verlag. }
  OPTIONAL { ?buch wdt:P577  ?veröffentlicht. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Diese gibt uns zusätzliche Variablen (?titel, ?verlag etc.), wenn die angegebene Aussage existiert, wenn die Aussage hingegen nicht existiert, wird das Ergebnis nicht verworfen – die Variable wird einfach nicht gesetzt.Beachte: Es ist sehr wichtig, hier getrennte OPTIONAL-Klauseln zu verwenden. Wenn du alle Tripel in eine Klausel setzt, wie hier – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – wirst du feststellen, dass die meisten Ergebnisse keine zusätzlichen Informationen enthalten. Dies liegt daran, dass eine optionale Klausel mit mehreren Tripeln nur dann zutrifft, wenn alle Tripel erfüllt werden. Das bedeutet: Wenn ein Buch einen Titel, einen Illustrator, einen Verlag und ein Veröffentlichungsdatum hat, dann trifft die optionale Klausel zu und die Werte werden den entsprechenden Variablen zugeordnet. Wenn ein Buch jedoch zum Beispiel einen Titel, jedoch keinen Illustrator hat, trifft die gesamte optionale Klausel nicht zu und obwohl das Ergebnis nicht verworfen wird, bleiben alle vier Variablen leer. Ausdrücke, FILTER und BIND Dieser Abschnitt könnte etwas weniger organisiert wirken, als die anderen, da er ein weites Feld mit unterschiedlichen Themen abdeckt. Das Basiskonzept besteht darin, dass wir etwas mit Werten machen wollen, die wir bisher nur ausgewählt und wahllos zurückgegeben haben. Ausdrücke sind Möglichkeiten, diese Operationen für Werte auszudrücken. Es gibt unterschiedliche Arten von Ausdrücken und du kannst viele Dinge mit ihnen tun – lass uns zunächst jedoch mit den Grundlagen beginnen: Datentypen. Datentypen Jeder Wert in SPARQL hat einen Typ, der dir sagt, um welche Art von Wert es sich handelt und was du mit ihm machen kannst. Die wichtigsten Typen sind: Datenobjekt, wie wd:Q42 für Douglas Adams (Q42). Boolesche, mit den zwei möglichen Werten true und false. Boolesche Werte werden nicht in Aussagen gespeichert, viele Ausdrücke geben jedoch einen booleschen Wert aus, z. B. 2 < 3 (true) oder \"a\" = \"b\" (false). String, ein Stück Text. String-Literale werden in Zollzeichen gesetzt. Monolingualer Text, ein String mit angehängtem Sprachkürzel. In einem Literal kannst du die Sprachkürzel nach dem String mit einem @-Zeichen angeben, z. B. \"Douglas Adams\"@en. Nummern, entweder ganze Zahlen (1) oder Dezimalzahlen (1,23). Datum. Datums-Literale können können durch Hinzufügen von ^^xsd:dateTime (Groß- und Kleinschreibung beachten – ^^xsd:datetime funktioniert nicht!) zu einer ISO 8601-Datumszeichenfolge hinzugefügt werden: \"2012-10-29\"^^xsd:dateTime.  Operatoren Die üblichen mathematischen Operatoren sind verfügbar: +, -, *, / zum Addieren, Subtrahieren, Multiplizieren und Dividieren von Zahlen, <, >, =, <=, >= um sie miteinander zu vergleichen. Der Ungleichheitstest ≠ wird mit != geschrieben. Vergleiche sind auch für andere Typen definiert; zum Beispiel ist \"abc\" < \"abd\" (lexikalischer Vergleich) ebenso wahr, wie \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime und wd:Q4653 != wd:Q283111. Boolesche Bedingungen können mit && (logisches und: a && b ist wahr, wenn a und b wahr sind) und || (logisches oder: a || b ist wahr, wenn entweder a oder b (oder beide) wahr sind) kombiniert werden. FILTER Info Als gelegentlich schnellere Alternative zu FILTER kannst du dir auch MINUS ansehen, siehe Beispiel.FILTER(bedingung). ist eine Klausel, die du in deine SPARQL-Abfrage einsetzen kannst, um die Ergebnisse zu filtern. Innerhalb der Klammern kannst du jeden booleschen Ausdruck angeben und nur die Ergebnisse, bei denen als Ergebnis des Ausdrucks true angegeben wird, werden verwendet.Zum Beispiel müssen wir für eine Liste aller Menschen, die 2015 geboren wurden zunächst eine Liste aller Menschen mit ihrem Geburtsdatum erhalten – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – und dann so filtern, dass als Ergebnis nur diejenigen angezeigt werden, bei denen das Geburtsjahr das Jahr 2015 ist. Es gibt zwei Wege, dies zu tun: das Jahr mit der Funktion YEAR aus dem Datum extrahieren und zu testen, ob es das Jahr 2015 ist – FILTER(YEAR(?dob) = 2015). – oder prüfe, dass das Datum zwischen dem 1. Januar 2015 (inklusive) und dem 1. Januar 2016 (exklusive) liegt: FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Ich würde sagen, dass ersteres einfacher ist, es zeigt sich jedoch, dass zweiteres wesentlich schneller ist, weshalb wir das nutzen. SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Eine weitere mögliche Verwendung von FILTER bezieht sich auf Bezeichnungen. Der Bezeichnungs-Service ist sehr nützlich, wenn du dir nur die Bezeichnungen einer Variable ansehen möchtest. Wenn du jedoch etwas mit der Bezeichnung machen möchtest – zum Beispiel: prüfen, ob es mit “Mr. ” anfängt – wirst du herausfinden, dass es nicht funktioniert: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! Diese Abfrage findet alle Untereinheiten von fictional human (Q15632617) und prüft, ob ihre Bezeichnung mit \"Mr. \" beginnt (STRSTARTS und CONTAINS). Der Grund, warum dies nicht funktioniert, ist, dass der Bezeichnungs-Service seine Variablen erst sehr spät in die Abfrage gibt; an dem Punkt, an dem wir versuchen, nach ?humanLabel zu filtern, hat der Bezeichnungs-Service die Variable noch nicht erstellt.Glücklicherweise ist der Bezeichnungs-Service nicht die einzige Möglichkeit, um an die Bezeichnung eines Objektes zu kommen. Bezeichnungen werden auch als reguläre Tripel mit dem Prädikat rdfs:label gespeichert. Natürlich umfasst dies alle Bezeichnungen und nicht nur englische; wenn wir nur die englischen Bezeichnungen haben wollen, müssen wir nach der Sprache der Bezeichnung filtern: FILTER(LANG(?label) = \"en\"). Die LANG-Funktion gibt die Sprache einer monolingualen Zeichenkette aus und hier wählen wir nur die Bezeichnungen aus, die auf Englisch sind. Die vollständige Abfrage lautet: SELECT ?mensch ?label
WHERE
{
  ?mensch wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! Wir erhalten die Bezeichnung mit dem Tripel ?human rdfs:label ?label, begrenzt auf englischsprachige Bezeichnungen und dann überprüft, ob sie mit “Mr. ” beginnen.Man kann FILTER auch mit regulären Ausdrücken nutzen. Im folgenden Beispiel SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Wenn die Formateinschränkung für eine ID [A-Za-z][-.0-9A-Za-z]{1,} ist: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! Es ist möglich, bestimmte Elemente herauszufiltern: FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) Es ist möglich, zu filtern und Elemente zu haben, die leer sind: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Diese drei Funktionen werden häufig zusammen verwendet, weshalb ich zunächst alle drei erkläre und dann einige Beispiele zeige.Eine BIND(Ausdruck AS ?variable).-Klausel kann genutzt werden, um das Ergebnis eines Ausdrucks einer Variablen zuzuweisen (gewöhnlich eine neue Variable, du kannst aber auch bereits existierende überschreiben).BOUND(?variable) rüft, ob eine Variable an einen Wert gebunden wurde (gibt true oder false aus). Es ist insbesondere für Variablen, die mit einer OPTIONAL-Klausel eingeführt werden sinnvoll.IF(Bedingung,dannAusdruck,anderer Ausdruck) wird als dannAusdruck ausgewertet, wenn Bedingung als true ausgewertet wird, und als andererAusdruck, wenn Bedingung als false ausgewertet wird. Das bedeutet, dass IF(true, \"ja\", \"nein\") als \"ja\" und IF(false, \"groß\", \"schrecklich\") als \"schrecklich\" ausgewertet werden.BIND kann genutzt werden, um Ergebnisse von Berechnungen an eine neue Variable zu binden. Dies kann ein Zwischenergebnis einer größeren Berechnung oder einfach das direkte Ergebnis einer Abfrage sein. Zum Beispiel, um das Alter der Opfer der Todesstrafe zu erhalten: SELECT ?person ?personLabel ?alter
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?geboren;
          wdt:P570 ?gestorben;
          wdt:P1196 wd:Q8454.
  BIND(?gestorben - ?geboren AS ?alterInTagen).
  BIND(?alterInTagen/365.2425 AS ?alterInJahren).
  BIND(FLOOR(?alterInJahren) AS ?alter).
  # oder als ein Ausdruck:
  #BIND(FLOOR((?gestorben - ?geboren)/365.2425) AS ?alter).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND kann auch genutzt werden, um konstante Werte an Variablen zu binden, um die Lesbarkeit zu verbessern. Zum Beispiel eine Abfrage, die alle weiblichen Priester findet: SELECT ?frau ?frauLabel
WHERE
{
  ?frau wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! kann auch so geschrieben werden: SELECT ?frau ?frauLabel
WHERE
{
  BIND(wdt:P31 AS ?unterklasseVon).
  BIND(wd:Q5 AS ?mensch).
  BIND(wdt:P21 AS ?geschlecht).
  BIND(wd:Q6581072 AS ?weiblich).
  BIND(wdt:P106 AS ?beruf).
  BIND(wd:Q42603 AS ?priester).
  ?frau ?unterklasseVon ?mensch;
         ?geschlecht ?weiblich;
         ?beruf ?priester.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Der bedeutungsvolle Teil der Abfrage von ?frau bis ?priester. ist jetzt besser lesbar. Jedoch ist der große BIND-Block direkt davor ablenkend, weshalb diese Technik sparsam verwendet werden sollte. (Auf der WDQS-Benutzeroberfläche kannst du auch mit deiner Maus über jeden Satz wie wd:Q123 oder wdt:P123 fahren und die Bezeichnung und Beschreibung des Datensatzes lesen, weshalb ?weiblich nur dann besser lesbar als wd:Q6581072 ist, wenn du die Funktion ignorierst.)IF-Ausdrücke werden häufig zusammen mit Bedingungsausdrücken verwendet, die mit BOUND erstellt wurden. Stelle dir zum Beispiel eine Abfrage vor, die einige Menschen zeigt, von denen du dir jedoch statt der Bezeichnung das pseudonym (P742) anzeigen lassen möchtest, wenn sie eines haben und nur dann die Bezeichnung, wenn kein Pseudonym existiert. Dafür wählst du das Pseudonym als OPTIONAL-Klausel aus (es muss optional sein – du möchtest nicht, dass Ergebnisse verworfen werden, die kein Pseudonym haben) und nutzt dann BIND(IF(BOUND(… um entweder das Pseudonym oder die Bezeichnung auszuwählen. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Andere Eigenschaften, die auf diese Art genutzt werden können, sind nickname (P1449), posthumous name (P1786) und taxon common name (P1843) – alles, bei dem eine Art von “Zurückgreifen” Sinn macht.Du kannst auch BOUND mit FILTER kombinieren, um sicherzustellen, dass mindestens einer der OPTIONAL-Blöcke erfüllt wird. Lass uns zum Beispiel alle Astronauten erhalten, die auf dem Mond und Mitglieder von Apollo 13 (Q182252) waren (eng genug, oder?). Die Einschränkung kann nicht als einzelner Eigenschaftspfad ausgedrückt werden, weshalb wir eine OPTIONAL-Klausel für “Mitglied einer Mond-Mission” und eine andere für “Mitglied von Apollo 13” benötigen. Wir wollen jedoch nur die Ergebnisse auswählen, bei denen mindestens eine der Bedingungen wahr ist. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE Die COALESCE-Funktion kann als Abkürzung für das oben genannte Muster zum Zurückgreifen BIND(IF(BOUND(?x), ?x, ?y) AS ?z). verwendet werden: Sie verwendet eine Reihe von Ausdrücken und gibt den ersten aus, der ohne einen Fehler ausgewertet wird. Zum Beispiel das Zurückgreifen beim “Pseudonym” oben BIND(IF(BOUND(?pseudonym),?pseudonym,?autorLabel) AS ?label). kann prägnanter geschrieben werden als BIND(COALESCE(?pseudonym, ?autorLabel) AS ?label). und es ist auch einfach, ein weiteres Zurückgreifen für den Fall, dass ?autorLabel ebenfalls nicht definiert ist, hinzuzufügen: BIND(COALESCE(?pseudonym, ?autorLabel, \"<no label>\") AS ?label).  Gruppierung Bisher haben alle Abfragen, die wir gesehen haben alle Datenobjekte gefunden, die bestimmte Bedingungen erfüllen; in einigen Fällen haben wir zusätzlich Aussagen des Datenobjektes einbezogen (Gemälde mit Material, Bücher von Arthur Conan Doyle mit Titel und Illustrator).Häufig wollen wir jedoch keine lange Liste aller Ergebnisse. Stattdessen können wir Fragen stellen, wie: Wie viele Gemälde wurden auf Leinwand / Pappelholz / etc. gemalt? Was ist die höchste Einwohnerzahl der Städte jedes Landes? Wie hoch ist die Gesamtzahl aller Gewehre, die von jedem Hersteller produziert wurden? Wer hat durchschnittlich die längsten Bücher veröffentlicht?  Einwohnerzahlen von Städten Lass uns auf die zweite Frage schauen. Es ist ziemlich einfach, eine Abfrage zu schreiben, die alle Städte mit Einwohnerzahl und Staat, geordnet nach Staaten, ausgibt: SELECT ?land ?stadt ?einwohnerzahl
WHERE
{
  ?stadt wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?land;
        wdt:P1082 ?einwohnerzahl.
}
ORDER BY ?land
 Try it! (Anmerkung: Die Abfrage gibt viele Ergebnisse aus, was deinem Browser Probleme bereiten kann. Möglicherweise möchtest du eine LIMIT-Klausel ergänzen.)Da wir die Ergebnisse nach Ländern sortieren, werden alle Städte, die zu einem Land gehören, in einem zusammenhängenden Block angezeigt. Um die höchste Einwohnerzahl dieses Blocks zu finden, wollen wir den Block als Gruppe betrachten und aus den individuellen Werten für Einwohnerzahlen eines Blocks einen Wert aggregieren: das Maximum. Dies kann mit einer GROUP BY-Klausel unter dem WHERE-Block und einer Aggregat-Funktion (MAX) in der SELECT-Klausel erreicht werden. SELECT ?land (MAX(?einwohnerzahl) AS ?maxEinwohnerzahl)
WHERE
{
  ?stadt wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?land;
        wdt:P1082 ?einwohnerzahl.
}
GROUP BY ?land
 Try it! Wir haben das ORDER BY durch GROUP BY ersetzt. Der Effekt ist, dass alle Ergebnisse mit dem gleichen ?land zu einem einzelnen Ergebnis gruppiert werden. Das bedeutet, dass wir die SELECT-Klausel ebenfalls ändern müssen. Welche ?stadt und ?einwohnerzahl würden zurückgegeben werden, wenn wir die alte Klausel SELECT ?land ?stadt ?einwohnerzahl behalten hätten? Bedenke, dass es hier viele Ergebnisse gibt, die das gleiche ?land haben, sodass wir diese auswählen können, jedoch alle eine unterschiedliche ?stadt und ?einwohnerzahl haben, weshalb wir WDQS sagen müssen, welche Werte ausgewählt werden sollen. Das ist die Aufgabe der Aggregat-Funktion. In diesem Fall haben wir MAX genutzt: Von allen ?einwohnerzahl-Werten wählen wir das Maximum jeder Gruppe aus. (Wir geben dem Wert außerdem durch die AS-Funktion einen neuen Namen, was jedoch nur ein kleines Detail ist.)Dies ist das allgemeine Muster zum Schreiben von Gruppen-Abfragen: schreibe eine normale Abfrage, die die Daten ausgibt, die du haben möchtest (nicht gruppiert, mit vielen Ergebnissen je “Gruppe”), ergänze dann eine GROUP BY-Klausel und eine Aggregat-Funktion für alle nicht gruppierten Variablen in der SELECT-Klausel. Gemäldematerialien Lass es uns mit einer anderen Frage ausprobieren: Wie viele Gemälde wurden auf dem jeweiligen Material gemalt? Schreibe zunächst eine Abfrage, die alle Gemälde zusammen mit ihrem Gemäldematerial ausgibt. (Stellesicher, nur die made from material (P186)-Aussagen mit einem applies to part (P518)painting support (Q861259) -Qualifikator zu nutzen.) SELECT ?material ?gemaelde
WHERE
{
  ?gemaelde wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Ergänze als nächstes eine GROUP BY-Klausel für das ?material und dann eine Aggregat-Funktion für die andere ausgewählte Variable (?gemaelde). In diesem Fall sind wir an der Anzahl von Gemälden interessiert; die Aggregat-Funktion dafür ist COUNT. SELECT ?material (COUNT(?gemaelde) AS ?menge)
WHERE
{
  ?gemaelde wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! Ein Problem dabei ist, dass wir nicht die Bezeichnungen für die Materialien haben, weshalb die Ergebnisse etwas unkonventionell zu interpretieren sind. Wenn wir einfach eine Variable für die Bezeichnung angeben, erhalten wir eine Fehlermeldung: SELECT ?material ?materialLabel (COUNT(?gemaelde) AS ?menge)
WHERE
{
  ?gemaelde wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” ist eine Fehlermeldung, die du häufig sehen wirst, wenn du mit Gruppen-Abfragen arbeitest; es bedeutet, dass eine der ausgewählten Variablen eine Aggregat-Funktion benötigt, jedoch keine hat oder, dass sie eine Aggregat-Funktion hat, aber keine haben sollte. In diesem Fall denkt WDQS, dass es mehrere ?materialLabels je ?material geben könnte (obwohl wir wissen, dass dies nicht passieren kann) und beschwert sich darüber, dass wir für die Variable keine Aggregat-Funktion angeben.Eine Lösung ist, mehrere Variablen zu gruppieren. Wenn du in der GROUP BY-Klausel mehrere Variablen aufführst, gibt es für jede Kombination dieser Variablen ein Ergebnis und du kannst alle Variablen ohne Aggregat-Funktion auswählen. In diesem Fall gruppieren wir ?material und ?materialLabel. SELECT ?material ?materialLabel (COUNT(?gemaelde) AS ?menge)
WHERE
{
  ?gemaelde wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! Wir sind mit der Abfrage fast fertig – nur noch eine weitere Verbesserung: wir möchten als erstes die am häufigsten genutzten Materialien sehen. Glücklicherweise können wir die neuen aggregierten Variablen aus der SELECT-Klausel (hier ?count) in einer ORDER BY-Klausel nutzen, wodurch dies sehr einfach ist: SELECT ?material ?materialLabel (COUNT(?gemaelde) AS ?menge)
WHERE
{
  ?gemaelde wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?menge)
 Try it! Lass uns als Übung auch die anderen Abfragen machen. Waffen nach Hersteller Wie hoch ist die Gesamtzahl der produzierten Waffen jedes Herstellers? Tipp Die relevanten Objekte und Eigenschaften sind: firearm (Q12796), manufacturer (P176), total produced (P1092). Beispiellösung SELECT ?hersteller ?herstellerLabel (SUM(?produziert) AS ?gesamtProduziert)
WHERE
{
  ?modell wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?hersteller;
         wdt:P1092 ?produziert.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?hersteller ?herstellerLabel
ORDER BY DESC(?produziert)
 Try it!  Verlage nach Seitenanzahl Wie hoch ist die durchschnittliche (Funktion: AVG) Seitenanzahl der Bücher jedes Verlags? Tipp Die relevanten Objekte und Eigenschaften sind: publisher (P123), number of pages (P1104). Beispiellösung SELECT ?verlag ?verlagLabel (AVG(?seiten) AS ?avgSeiten)
WHERE
{
  ?buch wdt:P123 ?verlag;
        wdt:P1104 ?seiten.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?verlag ?verlagLabel
ORDER BY DESC(?avgSeiten)
 Try it! HAVING Eine kleine Ergänzung zu unserer letzten Abfrage – wenn du dir die Ergebnisse ansiehst, bemerkst du vielleicht, dass das erste Ergebnis einen extrem hohen Durchschnittswert hat, mehr als zehn mal so hoch, wie der des zweiten Platzes. Etwas Nachforschung ergibt, dass dies daran liegt, dass der Verlag (UTET (Q4002388)) nur ein einziges Buch mit einer Aussage number of pages (P1104) veröffentlicht hat und zwar Grande dizionario della lingua italiana (Q3775610), was das Ergebnis verfälscht. Um solche Ausreißer zu entfernen, können wir versuchen, nur die Verlage auszuwählen, die mindestens zwei Bücher mit number of pages (P1104)-Aussagen in Wikidata veröffentlicht haben.Wie machen wir das? Normalerweise grenzen wir Ergebnisse durch eine FILTER-Klausel ein, in diesem Fall wollen wir jedoch basierend auf der Gruppe (Anzahl der Bücher) eingrenzen und nicht ein einzelnes Ergebnis. Dies wird mit einer HAVING-Klausel erreicht, die direkt nach einer GROUP BY-Klausel gesetzt werden kann und einen Ausdruck wie FILTER liefert: SELECT ?verlag ?verlagLabel (AVG(?seiten) AS ?avgSeiten)
WHERE
{
  ?buch wdt:P123 ?verlag;
        wdt:P1104 ?seiten.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?verlag ?verlagLabel
HAVING(COUNT(?buch) > 1)
ORDER BY DESC(?avgSeiten)
 Try it!  Zusammenfassung der Aggregat-Funktionen Hier ist ein kurzer Überblick über die verfügbaren Aggregat-Funktionen: COUNT: die Anzahl der Elemente. Du kannst auch COUNT(*) schreiben, um alle Ergebnisse zu zählen. SUM, AVG: die Summe, beziehungsweise der Durchschnitt aller Elemente. Wenn die Elemente keine Zahlen sind, erhältst du seltsame Ergebnisse. MIN, MAX: der Minimal-, beziehungsweise Maximalwert aller Elemente. Die funktioniert für alle Wert-Typen; Zahlen werden numerisch sortiert, Zeichenketten und andere Typen lexikalisch. SAMPLE: irgendein Element. Dies ist gelegentlich sinnvoll, wenn du weißt, dass es nur ein Ergebnis gibt oder dir egal ist, welches ausgegeben wird. GROUP_CONCAT: verkettet alle Elemente. Zum Beispiel nützlich, wenn du nur ein Ergebnis je Objekt erhalten möchtest, du jedoch Informationen einer Eigenschaft einbeziehen möchtest, die mehrere Aussagen für dieses Objekt haben kann, wie Berufe einer Person. Die unterschiedlichen Berufe können gruppiert und verkettet werden, um in nur einer Variable aufzutauchen, anstatt in mehreren Zeilen der Ergebnisse. Wenn du neugierig bist, kannst du dies in der SPARQL-Spezifikation nachlesen. Außerdem kannst du einen DISTINCT-Modifikator zu jeder dieser Funktionen hinzufügen, um doppelte Ergebnisse zu entfernen. Wenn du zum Beispiel zwei Ergebnisse hast, die den selben Wert in ?var haben, dann wird COUNT(?var) 2 ausgeben, COUNT(DISTINCT ?var) jedoch nur 1. Du musst häufig DISTINCT nutzen, wenn deine Abfrage das gleiche Objekt mehrfach ausgeben kann – dies kann beispielsweise passieren, wenn du ?item wdt:P31/wdt:P279* ?class nutzt und es mehrere Pfade von ?item nach ?class gibt: du wirst für jeden dieser Pfade ein Ergebnis erhalten, obwohl die Werte all dieser Ergebnisse gleich sind. (Wenn du nicht gruppierst, kannst du diese Duplikate entfernen, indem du die Abfrage mit SELECT DISTINCT anstatt SELECT beginnst.) wikibase:Label und Aggregat Eine Abfrage, wie die folgende, die alle Akademiker in Wikidata mit mehr als zwei Staatsangehörigkeiten sucht, gibt die Namen dieser Länder in der ?citizenships-Spalte nicht aus: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! Um die ?citizenships-Spalte anzuzeigen, müssen ?personLabel und ?citizenshipLabel in der wikibase:label-Funktion explizit benannt werden, wie hier: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 Сервис запросов Викиданных (WDQS, Wikidata Query Service) – мощный инструмент, позволяющий работать с содержимым Викиданных. Данное руководство расскажет, как работать с этим сервисом. См. также интерактивное руководство от Wikimedia Israel.Перед тем как написать свой собственный запрос SPARQL, посмотрите на шаблон {{Item documentation}} или любой другой шаблон запроса SPARQL и посмотрите, не включён ли уже туда ваш запрос. Contents 1 Перед началом 1.1 Основы SPARQL 2 Ваш первый запрос 2.1 Автозаполнение 3 Advanced triple patterns 4 Частные случаи и классы 4.1 Property paths 5 Квалификаторы 6 ORDER and LIMIT 6.1 Упражнение 6.1.1 Книги Артура Конан Дойля 6.1.2 Химические элементы 6.1.3 Реки, впадающие в Миссисипи 6.1.4 Rivers that flow into the Mississippi II 7 OPTIONAL 8 Expressions, FILTER and BIND 8.1 Типы данных 8.2 Операторы 8.3 FILTER 8.4 BIND, BOUND, IF 8.5 COALESCE 9 Группирование 9.1 Население города 9.2 Painting materials 9.3 Guns by manufacturer 9.4 Publishers by number of pages 9.4.1 HAVING 9.5 Aggregate functions summary 9.6 wikibase:Label and aggregations 10 VALUES 11 Label in multiple languages 12 И далее… 13 См. также Перед началом Хотя это руководство может показаться очень длинным и пугающим, не позвольте этому вас отпугнуть! Простое изучение основ SPARQL поможет вам пройти долгий путь — даже если вы перестанете читать после вашего первого запроса, вы уже будете понимать достаточно, чтобы построить много интересных запросов. Каждый раздел этого руководства даст вам возможность писать еще более мощные запросы.Если вы никогда прежде не слышали о Викиданных, SPARQL или WDQS, вот краткое описание этих понятий: Викиданные — это база знаний. Она содержит миллионы таких утверждений, как, например, «столицей Канады является Оттава», «„Мона Лиза“ написана масляными красками по тополю» или «золото имеет температуру плавления 1064,18 градусов Цельсия». SPARQL — это язык формулировки вопросов (запросов) к базам знаний. При обращении к подходящей базе запрос SPAQRL может дать ответы на такие вопросы, как «Какая самая распространённая музыкальная тональность?», «Какого персонажа играло наибольшее количество актёров?», «Каково распределение групп крови?» или «Произведения каких авторов перешли в общественное достояние в этом году?». WDQS, Wikidata Query Service (Сервис запросов Викиданных), совмещает их: вы вводите запрос SPARQL, сервис обращается с ним к содержимому Викиданных и показывает вам результат.  Основы SPARQL Простой SPARQL-запрос выглядит следующим образом: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} В секции SELECT перечислены переменные, которые вы хотите получить в результате запроса (переменные начинаются со знака вопроса). В секции WHERE содержатся условия, уточняющие их, в основном в виде троек. Вся информация в Викиданных (и аналогичных базах данных знаний) хранится в виде троек; когда вы запускаете запрос, служба запроса пытается заполнить переменные фактическими значениями, чтобы получаемые тройки присутствовали в базе данных знаний, и возвращает один результат для каждой комбинации переменных, которую она находит. Тройку можно рассматривать как предложение (поэтому она заканчивается точкой), содержащее \"субъект\", \"предикат\" и \"объект\": SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Результаты этого запроса могут включать, например, «лимон». В Викиданных большинство свойств подразумевают «имеет», так что запрос можно прочитать так: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} который читается как \"?fruit\" имеет цвет \"жёлтый\" (но не \"?fruit\" есть цвета \"желтого\" - имейте это в виду, пары свойств похожи как сотношение \"родители\"/\"дети\"!).Однако это не хороший пример для WDQS. Вкус субъективен, поэтому Викиданные не имеют такого свойства. Вместо этого, давайте подумаем об отношениях родители/дети, которые в основном однозначны. Ваш первый запрос Предположим, мы хотим получить список всех детей композитора эпохи барокко Иоганна Себастьяна Баха. При использовании псевдоэлементов, как в запросах выше, как бы вы составили такой запрос?Надеемся у вас получилось что-то вроде этого: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (Примечание: текст после символа \"#\" - это комментарий и игнорируется WDQS.)
} или этого: SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} или этого: SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} Первые два триплета говорят, что у ?child должен быть родитель/отец Бах; третий говорит, что у Баха должен быть ребенок ?child. Давайте присмотримся ко второму.Итак, что еще нужно сделать, чтобы превратить это в правильный запрос WDQS? На Викиданных элементы и свойства не обозначаются человекочитаемыми именами, такими как \"отец\" (свойство) или \"Бах\" (элемент). (по уважительной причине: \"Иоганн Себастьян Бах\" это и имя немецкого художника, и фамилия, и французская коммуна, и кратер Меркурия и т. д.) Вместо этого, элементам и свойствам в Викиданных присваивается идентификатор. Чтобы найти идентификатор для элемента мы ищем элемент и копируем Q-номер результата, описание которого походит на элемент, который мы ищем. Чтобы найти идентификатор для свойства, мы делаем то же самое, но ищем \"P:search term\" вместо просто \"search term\" (соответственно, \"P:отец\" и \"Бах\"), что ограничивает поиск именно поиском в свойствах. В результате узнаём, что знаменитый композитор Иоганн Себастьян Бах имеет код Q1339, а свойство для обозначения отца предмета - это P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Автозаполнение That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! По-русски это читается так: У рёбёнка есть отец Иоганн Себастьян Бах. У ребёнка есть мать Мария Барбара Бах. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: У ребёнка есть отец Иоганн Себастьян Бах и мать Мария Барбара Бах. На самом деле возможно произвести такое сокращение и в SPARQL: если вы завершаете тройку точкой с запятой (;) вместо точки, вы можете добавить ещё пару предикат-объект. Это позволяет сократить запрос выше до такого: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! что позволяет получить те же результаты, но с меньшими повторениями внутри запроса. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! или, чуть хуже читаемо: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! К счастью, редактор WDQS делает отступы строчек автоматически, так что обычно вам не нужно беспокоиться об этом. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). На языке SPARQL это может быть записано следующим образом: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language пример SPARQL пример sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. квадратные скобки juliet loves [ kills tybalt ].  Частные случаи и классы Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: «Унесённые ветром» является фильмом. Фильм является произведением искусства. «Унесённые ветром» — это один конкретный фильм. У него есть определённый режиссёр (Виктор Флеминг), определённая длительность (238 минут), актёрская труппа (Кларк Гейбл, Вивьен Ли, …) и так далее.Фильм — это более общее понятие. У фильмов есть режиссёры, длительность, актёры, но у самого по себе понятия «фильм» нет конкретных режиссёра, длительности или актёров. И хотя фильм является произведением искусства, а у произведения искусства обычно есть создатель, само понятие «фильм» не имеет создателя — лишь его частные случаи имеют такового.Из-за этого различия в Викиданных есть два свойства для «является»: instance of (P31) и subclass of (P279). «Унесённые ветром» — это конкретный, частный случай класса «фильм»; класс «фильм», в свою очередь, — это подкласс (более узкий класс) более общего класса «произведение искусства». To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). Так что это означает для нас при написании запросов SPARQL? Когда мы хотим найти «все произведения искусства», недостаточно искать все элементы, которые являются непосредственно частным случаем «произведения искусства»: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Квалификаторы (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values.  Упражнение We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.)  Книги Артура Конан Дойля Напишите запрос, который выдаёт все книги Артура Конан Дойля. Совет The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Пример решения SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Химические элементы Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Совет The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Пример решения SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  Реки, впадающие в Миссисипи Напишите запрос, который выдаёт все реки, впадающие непосредственно в Миссисипи (основная сложность здесь — найти правильное свойство…). Совет The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Пример решения SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Совет This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Пример решения SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types.  Типы данных Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime.  Операторы The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Информация For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  Группирование So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books?  Население города Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Совет The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Пример решения SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service (Служба запитів Вікіданих) – це потужний інструмент для надання інформації про вміст Вікіданих. Цей підручник навчить вас, як користуватися WDQS. Див. також інтерактивний підручник від Wikimedia Israel.Перш ніж писати свій власний запит SPARQL, подивіться {{Item documentation}} або будь-який інший типовий шаблон запиту SPARQL і подивіться, чи ваш запит уже включено. Contents 1 Перед тим, як почати 2 Основи SPARQL 3 Наш перший запит 3.1 Автозавершення 4 Удосконалені схеми триплетів 5 Екземпляри й класи 5.1 Шляхи властивостей 6 Кваліфікатори 7 ORDER і LIMIT 7.1 Вправа 7.1.1 Книги Артура Конана Дойла 7.1.2 Хімічні елементи 7.1.3 Річки, що впадають у Міссісіпі 7.1.4 Річки, що впадають у Міссісіпі II 8 OPTIONAL 9 Вирази, FILTER і BIND 9.1 Типи даних 9.2 Оператори 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Групування 10.1 Міське населення 10.2 Матеріал для картин 10.3 Вогнепальна зброя за виробником 10.4 Видавці за кількістю сторінок 10.4.1 HAVING 10.5 Огляд агрегатних функцій 10.6 wikibase:Назви й агрегації 11 VALUES 12 Label in multiple languages 13 А далі… 14 Див. також Перед тим, як почати Хоча цей посібник може виглядати дуже довгим і складним, будь ласка, не дозволяйте цьому лякати вас! Просто вивчивши основи SPARQL, ви пройдете довгий шлях - навіть якщо ви перестанете читати після нашого першого запиту, ви вже зрозумієте достатньо, щоб створити багато цікавих запитів. Кожен розділ цього підручника дозволить вам писати ще потужніші запити.Якщо ви ніколи раніше не чули про Вікідані, SPARQL або WDQS, ось коротке пояснення цих термінів: Вікідані – це база даних знань. Вона містить мільйони тверджень, наприклад, «столиця Канади — Оттава», «Мона Ліза намальована олійною фарбою на дереві тополі», або «золото має температуру плавлення 1064,18 градуса за Цельсієм». SPARQL – це мова для формулювання питань (запитів) до баз даних знань. Для правильної бази даних запит SPARQL міг би відповісти на такі запитання, як \"яка найпопулярніша тональність у музиці?\" або \"який персонаж був зображений більшістю акторів?\" або \"який розподіл груп крові?\" або \"роботи яких авторів перейшли у суспільне надбання цього року?\". WDQS, служба запитів Вікіданих, об’єднує їх разом: ви вводите запит SPARQL, служба запускає його з набором даних Вікіданих та показує вам результат.  Основи SPARQL Простий запит SPARQL виглядає так: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Пункт SELECT перераховує змінні, які ви хочете повернути (змінні починаються із знака питання), а пункт WHERE містить обмеження на них, переважно у формі триплетів. Уся інформація у Вікіданих (і аналогічних базах даних знань) зберігається у вигляді триплетів; коли ви запускаєте запит, служба запитів намагається заповнити змінні фактичними значеннями, так, як отримані триплети з'являються в базі знань, і повертає один результат для кожної комбінації змінних, які вона знаходить.Триплет можна розглядати як дві вершини (псевдоніми — два вузли, два ресурси), з’єднані ребром (дугою, властивістю) всередині величезного орієнтованого (спрямованого) мультиграфа властивостей, який утворює Вікідані. Його можна читати як речення (тому він закінчується крапкою), з суб'єктом (підметом, subject), предикатом (присудком, predicate) і об'єктом (додатком, object): SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Результати для цього запиту можуть включати, наприклад, «лимон». У Вікіданих більшість властивостей є властивостями типу «має» («has»), тому запит можна читати навпаки: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} який читається як «?fruit має колір 'yellow'» (не «?fruit є колір 'yellow'» – майте це на увазі для таких пар властивостей, як «батько»/«дитина»!).Однак це не дуже хороший приклад для WDQS. Смак суб’єктивний, тому Вікідані не мають властивостей для нього. Натомість давайте подумаємо про відношення між батьками та дітьми, які переважно однозначні. Наш перший запит Припустимо, ми хочемо скласти список усіх дітей барокового композитора Йоганна Себастьяна Баха. Використовуючи псевдоелементи, як у запитах вище, як би ви написали цей запит?Сподіваємось, у вас є щось на зразок цього: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (примітка: все після ‘#’ є коментарем й ігнорується у WDQS.)
} або цього SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} або цього SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Натисніть посилання \"Виконати!\", потім \"Виконати запит\" на сторінці WDQS. Що ви отримуєте? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Автозавершення That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.)  Удосконалені схеми триплетів Отже, тепер ми побачили всіх дітей Йогана Себастьяна Баха - конкретніше: усі елементи з батьком Йоганном Себастьяном Бахом. Але Бах мав двох дружин, і тому в цих елементах є дві різні матері: що, якщо ми хочемо бачити дітей Йогана Себастьяна Баха зі своєю першою дружиною, Марією Барбарою Бах (Q57487)? Спробуйте записати цей запит, виходячи із зазначеного вище.Зробили це? Добре, тоді до рішення! Найпростіший спосіб зробити це - додати другий триплет з цим обмеженням: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ].  Екземпляри й класи Раніше я сказав, що більшість властивостей Wikidata відношення \"має\": \"має\" дитину, \"має\" батька, \"має\" професію. Але іноді (насправді, часто), вам також потрібно поговорити про те, що \"є\". Але існують фактично два види відношень: Звіяні вітром є фільмом. Фільм є мистецьким твором. Звіяні вітром - це один конкретний фільм. Він має конкретного режисера (Віктор Флемінг), певну тривалість (238 хвилин), список акторів (Кларк Гейбл, Вів'єн Лі, ...) тощо.\"Фільм\" - це загальне поняття. Фільми можуть мати режисерів, тривалості й акторів, але поняття \"фільм\" як таке не має жодного конкретного режисера, тривалості або акторів. І хоча фільм є мистецьким твором, а мистецький твір зазвичай має творця, у самому понятті \"фільм\" немає творця - його мають лише окремі \"екземпляри\" (\"instances\") цього поняття.Ця різниця полягає в тому, що у Вікіданих є дві властивості для \"є\": instance of (P31) і subclass of (P279). Звіяні вітром - це окремий примірник класу \"фільм\"; клас \"фільм\" - це підклас (більш специфічний клас, спеціалізація) більш загального класу \"витвір мистецтва\".Щоб допомогти вам зрозуміти різницю, ви можете спробувати використовувати два різних дієслова: \"є\" і \"є свого роду\". Якщо \"є свого роду\" твір (наприклад, фільм - це \"є свого роду\" \"витвір мистецтва\"), це означає, що ви говорите про підклас, спеціалізацію ширшого класу, і ви повинні використовувати subclass of (P279). Якщо \"є свого роду\" не працює (наприклад, вислів \"Звіяні вітром \"є свого роду\" фільмом\" не має сенсу), це означає, що ви говорите про конкретний екземпляр, і ви повинні використовувати instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it.  Шляхи властивостей Загалом, шлях, що з'єднує вузол-джерело (суб'єкт) з цільовим вузлом (об'єктом) через граф, не завжди є прямим: може знадобитися об'єднати нуль, одну або багато ланок (сегментів, тобто елементів шляху) в ланцюг; і таких шляхів (маршрутів) може бути кілька. Об'єкт елемента шляху в ланцюгу стає суб'єктом наступного елемента. У SPARQL Шляхи властивостей — це спосіб дуже стисло записати такий шлях властивостей між двома елементами. Найпростішим шляхом є лише одна властивість, що формує звичайний триплет: ?item wdt:P31 ?class. Ви можете додати елементи шляху, використовуючи косу риску (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Це еквівалентно одному з таких записів: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Вправа: перепишіть попередній запит \"онуки Баха\" з використанням цього синтаксису.Зірочка (*) після елемента шляху означає “нуль або більше цих елементів\". ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. Знак питання (?) подібний на зірочку або плюс, але означає \"нуль або один цей елемент\". You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Кваліфікатори (Спочатку гарна новина: у цьому розділі не вводиться додатковий синтаксис SPARQL - ура! Дихайте спокійно і розслабтеся, це має бути простіше простого, правильно?)Наразі ми говорили лише про прості твердження: суб'єкт, властивість, об'єкт. Але твердження Вікіданих є чимось більшим: вони можуть також мати кваліфікатори та посилання. Наприклад, Мона Ліза (Q12418) має три твердження made from material (P186): oil paint (Q296955), основний матеріал; poplar wood (Q291034), з кваліфікатором applies to part (P518)painting support (Q861259) - це матеріал, на якому Мона Ліза була намальована; wood (Q287), з кваліфікаторами applies to part (P518)stretcher (Q1737943) та start time (P580) 1951 - це частина, яка пізніше була додана до картини. Припустимо, ми хочемо знайти всі картини з їхньою поверхнею для малювання, тобто ті твердження made from material (P186) з кваліфікатором applies to part (P518)painting support (Q861259) . Як ми це зробимо? Тут більше інформації, ніж можна представити в одному триплеті.Відповідь: більше триплетів! (Практичне правило: Рішенням Вікіданих майже для всього є \"більше елементів\", а відповідним правилом WDQS є \"більше триплетів\". Посилання, точність чисел, значення з одиницями вимірювання, геокоординати тощо, все, що ми тут пропускаємо, також працює так само.) Досі ми використовували префікс wdt: для наших триплетів тверджень, який вказує безпосередньо на об'єкт твердження. Але є ще один префікс p:, який вказує не на об'єкт, а на вузол твердження (statement node). Тоді цей вузол є суб'єктом інших триплетів: префікс ps: (для property statement, твердження властивості) вказує на об'єкт твердження, префікс pq: (property qualifier, кваліфікатор властивості) - на кваліфікатори, а prov:wasDerivedFrom вказує на вузли посилань (які ми наразі проігноруємо).Це було багато абстрактного тексту. Ось конкретний приклад для Мони Лізи: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) Ми можемо це скоротити з допомогою синтаксису [], замінивши змінні ?statement: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Чи можете ви використати ці знання, щоб написати запит для всіх картин з їхньою поверхнею для малювання?Це мій розв'язок: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Спершу ми обмежуємо ?painting всіма екземплярами painting (Q3305213) або її підкласів. Потім ми витягуємо матеріал з вузла твердження p:P186, обмежуючи твердження до тих, що мають кваліфікатор applies to part (P518)painting support (Q861259) . ORDER і LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values.  Вправа We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.)  Книги Артура Конана Дойла Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Хімічні елементи Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it!  Річки, що впадають у Міссісіпі Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Річки, що впадають у Міссісіпі II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty.  Вирази, FILTER і BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types.  Типи даних Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime.  Оператори Доступні знайомі математичні оператори: +, -, *, / для додавання, віднімання, множення або ділення чисел, <, >, =, <=, >= для їхнього порівняння. Перевірка нерівності ≠ записується так !=. Порівняння також визначено для інших типів; наприклад, \"abc\" < \"abd\" є істинним (лексичне порівняння), як і \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime та wd:Q4653 != wd:Q283111. Логічні умови можна комбінувати з && (логічне \"і\": a && b є істинним, якщо і a, і b є істинними) та || (логічне \"або\": a || b є істинним, якщо одна з умов (або обидві) a та b є істинними). FILTER Інформація Іноді швидшою альтернативою для FILTER є MINUS, див. приклад.FILTER(condition). - це пункт, який ви можете вставити у свій SPARQL-запит, щоб фільтрувати результати. У круглих дужках ви можете помістити будь-який вираз булевого типу, і використовувати лише ті результати, в яких вираз повертає true. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Інше можливе використання FILTER пов'язане з назвами. Служба назв дуже корисна, якщо ви просто хочете відобразити назву змінної. Але якщо ви хочете робити щось із назвою - наприклад: перевірити, чи починається вона з \"Mr. \" - ви виявите, що це не працює: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). Функція LANG повертає мову одномовного рядка, і тут ми вибираємо лише ті назви, які задані англійською. Повний запит: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Ці три функції часто використовуються спільно, тому я спочатку поясню їх, а потім покажу вам декілька прикладів.Твердження BIND(expression AS ?variable). може бути використане для присвоєння результату виразу змінній (зазвичай новій змінній, але також можна переписати наявну).BOUND(?variable) тестує, чи змінній задано значення і вона пов'язана з ним (повертає true or false). Це в основному корисно для змінних, які вводяться в пункті OPTIONAL.IF(condition,thenExpression,elseExpression) вираховує thenExpression, якщо condition дорівнює true і elseExpression, якщо condition дорівнює false. Тобто IF(true, \"так\", \"ні\") вираховує \"так\", а IF(false, \"великий\", \"лячний\") вираховує \"лячний\".BIND можна використовувати для прив'язки результатів деякого розрахунку до нової змінної. Вона може бути проміжним результатом більшого розрахунку або просто безпосередньо результатом запиту. Наприклад, щоб отримати вік жертв смертної кари: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # або, як один вираз:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND також можна використовувати для простої прив'язки постійних значень до змінних для покращення читабельності запиту. Наприклад, запит, який знаходить усіх священиків-жінок: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! можна переписати так: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Значна частина запиту, від ?woman до ?priest., тепер, ймовірно, читабельніша. Однак, великий блок BIND перед нею суттєво відволікає, тому цю техніку слід використовувати раціонально. (У користувацькому інтерфейсі WDQS ви також можете навести курсор миші на будь-який термін, наприклад, wd:Q123 або wdt:P123 і побачити назву й опис сутності, тому ?female є читабельнішим, ніж wd:Q6581072, якщо ви ігноруєте цю можливість.)Вирази IF часто використовуються в BOUND як вираз. Наприклад, припустімо, що у вас є запит, який показує деяких людей, і замість того, щоб просто показати їхню назву, ви хочете показати їхній pseudonym (P742), якщо він є, та використати лише назву, якщо псевдонім не існує. Для цього ви виберете псевдонім у пункті OPTIONAL (він повинен бути необов'язковим - ви не бажаєте викидати результати, які не мають псевдоніма), а потім використаєте BIND(IF(BOUND(…, щоб вибрати псевдонім або назву. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Інші властивості, які можуть бути використані таким способом, включають nickname (P1449), posthumous name (P1786), і taxon common name (P1843) - все, що має сенс деякого роду «резервного» (“fallback”).Ви також можете поєднати BOUND з FILTER, щоб переконатися, що принаймні один із декількох блоків OPTIONAL був виконаний. Наприклад, отримаймо всіх космонавтів, які літали на Місяць, а також членів Apollo 13 (Q182252) (досить близько, вірно?). Це обмеження не може бути виражене як єдиний шлях властивості, тому нам потрібна одна умова OPTIONAL для \"учасника деякої місячної місії\", а інша для \"члена Apollo 13\". Але ми хочемо вибрати лише ті результати, в яких принаймні одна з цих умов є істинною. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE Функцію COALESCE можна використовувати як скорочення для шаблону BIND(IF(BOUND(?x), ?x, ?y) AS ?z). для псевдонімів, що згадані вище: вона бере ряд виразів і повертає перший, який оцінює як \"без помилки\". Наприклад, вищезгаданий резервний \"pseudonym\" BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). можна записати стисліше так BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). а також легко додати ще одну резервну назву, якщо ?writerLabel також не задано: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label).  Групування So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books?  Міське населення Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause.  Матеріал для картин Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate \"Bad aggregate\" - це повідомлення про помилку, яке ви, ймовірно, побачите під час роботи з груповими запитами; воно означає, що для однієї з вибраних змінних потрібна агрегатна функція, але її немає, або вона має агрегатну функцію, але не повинна мати її. У цьому разі WDQS вважає, що можуть бути декілька ?materialLabel для ?material (хоча ми знаємо, що це не може статися), і тому він скаржиться на те, що ви не вказали агрегатну функцію для цієї змінної.Одним із рішень є групування за декількома змінними. Якщо ви вкажете декілька змінних у пункті GROUP BY, для кожної комбінації цих змінних є один результат, і ви можете вибрати всі ці змінні без агрегатної функції. У цьому разі ми будемо групувати як ?material, так і ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! Ми майже завершили із запитами - ще лиш одне вдосконалення: ми хочемо побачити спершу найчастіше використовувані матеріали. На щастя, нам дозволяється використовувати нові, агреговані змінні у пункті SELECT (тут ?count) у пункті ORDER BY, так що це дуже просто зробити: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! Як вправу, зробімо також інші запити. Вогнепальна зброя за виробником Яка загальна кількість зброї, виробленої кожним виробником? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it!  Видавці за кількістю сторінок What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING Невелике доповнення до останнього запиту – якщо ви глянете на результати, то можете зауважити, що верхній результат має надзвичайно великий середній показник, що перевищує в десять разів показник другого місця. Трохи досліджень показує, що це тому, що видавець (UTET (Q4002388)) опублікував лише одну книгу з твердженням number of pages (P1104), Grande dizionario della lingua italiana (Q3775610), що трохи спотворює результати. Щоб видалити такі відхилення, ми можемо спробувати вибрати лише тих видавців, які опублікували принаймні дві книги з твердженнями number of pages (P1104) на Вікіданих.Як ми це робимо? Зазвичай ми обмежуємо результати за допомогою пункту FILTER, але в цьому разі ми хочемо обмежитися групою (кількістю книг), а не окремим результатом. Це робиться за допомогою пункту HAVING, який може бути розміщений безпосередньо після пункту GROUP BY і приймає вираз так само, як FILTER: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it!  Огляд агрегатних функцій Ось короткий огляд доступних агрегатних функцій: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Крім того, ви можете додати модифікатор DISTINCT для будь-якої з цих функцій, щоб виключити повторювані результати. Наприклад, якщо є два результати, але вони мають однакові значення в ?var, то COUNT(?var) поверне 2, але COUNT(DISTINCT ?var) поверне лише 1. Вам часто доведеться використовувати DISTINCT, коли ваш запит може повернути ту ж саму групу декілька разів - це може статися, якщо, наприклад, ви використовуєте ?item wdt:P31/wdt:P279* ?class, і існує декілька шляхів від ?item до ?class: ви отримаєте новий результат для кожного з цих шляхів, навіть якщо всі значення в результаті ідентичні. (Якщо ви не групуєте, ви також можете виключити ці дубльовані результати, запустивши запит за допомогою SELECT DISTINCT, а не просто SELECT.) wikibase:Назви й агрегації Запит, подібний до наведеного нижче, який шукає у Вікіданих усіх науковців із більш ніж двома країнами громадянства, не показує назви цих країн у стовпці ?citizenships: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! Щоб показати ?citizenships, явно вкажіть ?personLabel і ?citizenshipLabel у виклику служби wikibase:label так: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Zanim zaczniemy 2 Podstawy SPARQL 3 Our first query 3.1 Autouzupełnianie 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Kwalifikatory 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Pierwiastki chemiczne 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Typy danych 9.2 Operatory 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Zobacz też Zanim zaczniemy While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result.  Podstawy SPARQL A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?owoc
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?owoc
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?dziecko
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?dziecko
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?dziecko
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?dziecko
WHERE
{
# ?child  father   Bach
  ?dziecko wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? dziecko wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?dziecko wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. dziecko childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autouzupełnianie That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339.
  ?dziecko wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?dziecko.
  ?dziecko wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language przykład SPARQL przykład zdanie Juliet loves Romeo. kropka juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. średnik romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. przecinek romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">means:</span>
?item wdt:P31 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or</span>
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">or ...</span> In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b. A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself. A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”. You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.) You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.)  Kwalifikatory (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?) So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple. The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now). That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface? Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features. So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank). This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT. ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.) LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result. (You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.) Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses. Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?kraj wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?populacja.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Przykładowe rozwiązanie SELECT ?book ?bookLabel
WHERE
{
  ?książka wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Pierwiastki chemiczne Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint Odpowiednie elementy i właściwości to: chemical element (Q11344), element symbol (P246), atomic number (P1086). Przykładowe rozwiązanie SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?numer.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?numer
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Przykładowe rozwiązanie SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Przykładowe rozwiązanie SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577). A first attempt might look like this: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?książka wdt:P50 wd:Q35610;
        wdt:P1476 ?tytuł;
        wdt:P110 ?ilustrator;
        wdt:P123 ?wydawca;
        wdt:P577 ?opublikowane.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier! The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results. The solution is to tell WDQS that those triples are optional: SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?książka wdt:P50 wd:Q35610.
  OPTIONAL { ?książka wdt:P1476 ?tytuł. }
  OPTIONAL { ?książka wdt:P110  ?ilustrator. }
  OPTIONAL { ?książka wdt:P123  ?wydawca. }
  OPTIONAL { ?książka wdt:P577  ?opublikowane. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set. Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT <span lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\">?book ?title ?illustratorLabel ?publisherLabel ?published</span>
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types.  Typy danych Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime.  Operatory The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example. FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used. For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?osoba wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet. Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?człowiek ?etykieta
WHERE
{
  ?człowiek wdt:P31 wd:Q15632617;
         rdfs:label ?etykieta.
  FILTER(LANG(?etykieta) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?etykieta, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”. One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples. A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones). BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause. IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\". BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?osoba wdt:P31 wd:Q5;
          wdt:P569 ?urodzony;
          wdt:P570 ?zmarły;
          wdt:P1196 wd:Q8454.
  BIND(?zmarły - ?urodzony AS ?wiekWDniach).
  BIND(?wiekWDniach/365.2425 AS ?wiekWLatach).
  BIND(FLOOR(?wiekWLatach) AS ?wiek).
  # or, as one expression:
  #BIND(FLOOR((?zmarły - ?urodzony)/365.2425) AS ?wiek).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.) IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense. You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronauta wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronauta wdt:P450 ?misja.
    ?misja wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronauta wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?misja).
  }
  FILTER(BOUND(?misja)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonim),?pseudonim,?writerLabel) AS ?etykieta). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?etykieta). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?etykieta). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator). But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?miasto wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?kraj;
        wdt:P1082 ?populacja.
}
ORDER BY ?kraj
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.) Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?kraj (MAX(?populacja) AS ?maxPopulation)
WHERE
{
  ?miasto wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?kraj;
        wdt:P1082 ?populacja.
}
GROUP BY ?kraj
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.) This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?malarstwo wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiał; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?materiał (COUNT(?malarstwo) AS ?count)
WHERE
{
  ?malarstwo wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiał; pq:P518 wd:Q861259 ].
}
GROUP BY ?materiał
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?malarstwo) AS ?count)
WHERE
{
  ?malarstwo wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiał; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?materiał
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable. One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?malarstwo) AS ?count)
WHERE
{
  ?malarstwo wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiał; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?malarstwo) AS ?count)
WHERE
{
  ?malarstwo wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?materiał; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Przykładowe rozwiązanie SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint Odpowiednie elementy i właściwości to: publisher (P123), number of pages (P1104). Przykładowe rozwiązanie SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata. How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds.A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it.For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.)And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above.Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query.Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions!Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this.Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario…Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren?Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s).In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.)And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on.Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do.This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”.To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31).So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching.One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.)Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax.An asterisk (*) after a path element means “zero or more of this element”. ?item wdt:P31/wdt:P279* ?class.
# means:
?item wdt:P31 ?class
# or
?item wdt:P31/wdt:P279 ?class
# or
?item wdt:P31/wdt:P279/wdt:P279 ?class
# or
?item wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?class
# or ... In the special case where there is zero property in a path (no specific arc of relation: a NULL, \"universal\" property), then the subject node is directly connected to the object node in the graph, whatever the object node is, including itself. So that there is always a match. Thus, in SPARQL, for instance in the case \"zero something\", ?a something* ?b reduces to ?a ?b, with no path between them, and ?a takes directly the value of ?b.A plus (+) is similar to an asterisk, but means “one or more of this element”. The following query finds all descendants of Bach: SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! If we used an asterisk instead of a plus here, the query results would include Bach himself.A question mark (?) is similar to an asterisk or a plus, but means “zero or one of this element”.You can separate path elements with a vertical bar (|) instead of a forward slash; this means “either-or”: the path might use either of those properties. (But not combined – an either-or path segment always matches a path of length one.)You can also group path elements with parentheses (()), and freely combine all these syntax elements (/|*+?). This means that another way to find all descendants of Bach is: SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Instead of using the “child” property to go from Bach to his descendants, we use the “father” and “mother” properties to go from the descendants to Bach. The path might include two mothers and one father, or four fathers, or father-mother-mother-father, or any other combination. (Though, of course, Bach can’t be the mother of someone, so the last element will always be father.) Qualifiers (Good news first: this section introduces no additional SPARQL syntax – yay! Take a quick breath and relax, this should be a piece of cake. Right?)So far, we’ve only talked about simple statements: subject, property, object. But Wikidata statements are more than that: they can also have qualifiers and references. For example, the Mona Lisa (Q12418) has three made from material (P186) statements: oil paint (Q296955), the main material; poplar wood (Q291034), with the qualifier applies to part (P518)painting support (Q861259) – this is the material that the Mona Lisa was painted on; and wood (Q287), with the qualifiers applies to part (P518)stretcher (Q1737943) and start time (P580) 1951 – this is a part that was added to the painting later. Suppose we want to find all paintings with their painting surface, that is, those made from material (P186) statements with a qualifier applies to part (P518)painting support (Q861259) . How do we do that? That’s more information than can be represented in a single triple.The answer is: more triples! (Rule of thumb: Wikidata’s solution for almost everything is “more items”, and the corresponding WDQS rule is “more triples”. References, numeric precision, values with units, geocoordinates, etc., all of which we’re skipping here, also work like this.) So far, we’ve used the wdt: prefix for our statement triples, which points directly to the object of the statement. But there’s also another prefix: p:, which points not to the object, but to a statement node. This node then is the subject of other triples: the prefix ps: (for property statement) points to the statement object, the prefix pq: (property qualifier) to qualifiers, and prov:wasDerivedFrom points to reference nodes (which we’ll ignore for now).That was a lot of abstract text. Here’s a concrete example for the Mona Lisa: wd:Q12418 p:P186 ?statement1.    # Mona Lisa: material used: ?statement1
?statement1 ps:P186 wd:Q296955.  # value: oil paint

wd:Q12418 p:P186 ?statement2.    # Mona Lisa: material used: ?statement2
?statement2 ps:P186 wd:Q291034.  # value: poplar wood
?statement2 pq:P518 wd:Q861259.  # qualifier: applies to part: painting surface

wd:Q12418 p:P186 ?statement3.    # Mona Lisa: material used: ?statement3
?statement3 ps:P186 wd:Q287.     # value: wood
?statement3 pq:P518 wd:Q1737943. # qualifier: applies to part: stretcher bar
?statement3 pq:P580 1951.        # qualifier: start time: 1951 (pseudo-syntax) We can abbreviate this a lot with the [] syntax, replacing the ?statement variables: wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Can you use this knowledge to write a query for all paintings with their painting surface?Here’s my solution: SELECT ?painting ?paintingLabel ?material ?materialLabel
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! First, we limit ?painting to all instances of painting (Q3305213) or a subclass thereof. Then, we extract the material from the p:P186 statement node, limiting the statements to those that have an applies to part (P518)painting support (Q861259) qualifier. ORDER and LIMIT We return to our regular scheduled program of more SPARQL features.So far, we’ve only had queries where we were interested in all results. But it’s quite common to care only about a few results: those that are most extreme in some way – oldest, youngest, earliest, latest, highest population, lowest melting point, most children, most materials used, and so on. The common factor here is that the results are ranked in some way, and then we care about the first few results (those with the best rank).This is controlled by two clauses, which are appended to the WHERE {} block (after the braces, not inside!): ORDER BY and LIMIT.ORDER BY something sorts the results by something. something can be any expression – for now, the only kind of expression we know are simple variables (?something), but we’ll see some other kinds later. This expression can also be wrapped in either ASC() or DESC() to specify the sorting order (ascending or descending). (If you don’t specify either, the default is ascending sort, so ASC(something) is equivalent to just something.)LIMIT count cuts off the result list at count results, where count is any natural number. For example, LIMIT 10 limits the query to ten results. LIMIT 1 only returns a single result.(You can also use LIMIT without ORDER BY. In this case, the results aren’t sorted, so you don’t have any guarantee which results you’ll get. Which is fine if you happen to know that there’s only a certain number of results, or you’re just interested in some result, but don’t care about which one. In either case, adding the LIMIT can significantly speed up the query, since WDQS can stop searching for results as soon as it’s found enough to fill the limit.)Exercise time! Try to write a query that returns the ten most populous countries. (A country is a sovereign state (Q3624078), and the property for population is P:P1082.) You can start by searching for countries with their population, and then add the ORDER BY and LIMIT clauses.Here’s my solution: SELECT ?country ?countryLabel ?population
WHERE
{
  ?country wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Note that if we want the most populous countries, we have to order by descending population, so that the first results will be the ones with the highest values. Exercise We’ve covered a lot of ground so far – I think it’s time for some exercises. (You can skip this section if you’re in a hurry.) Arthur Conan Doyle books Write a query that returns all books by Sir Arthur Conan Doyle. Hint The relevant items and properties are: Arthur Conan Doyle (Q35610), author (P50). Example solution SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Chemical elements Write a query that returns all chemical elements with their element symbol and atomic number, in order of their atomic number. Hint The relevant items and properties are: chemical element (Q11344), element symbol (P246), atomic number (P1086). Example solution SELECT ?element ?elementLabel ?symbol ?number
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbol;
           wdt:P1086 ?number.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?number
 Try it! Rivers that flow into the Mississippi Write a query that returns all rivers that flow directly into the Mississippi River. (The main challenge is finding the correct property…) Hint The relevant items and properties are: Mississippi River (Q1497), mouth of the watercourse (P403). Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Rivers that flow into the Mississippi II Write a query that returns all rivers that flow into the Mississippi River, directly or indirectly. Hint This query is almost identical to the previous one. The difference is that this time you’ll need a path instead of a triple. (If you skipped the section about paths, skip this exercise too.) Example solution SELECT ?river ?riverLabel
WHERE
{
  ?river wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL In the exercises above, we had a query for all books by Sir Arthur Conan Doyle: SELECT ?book ?bookLabel
WHERE
{
  ?book wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! But that’s a bit boring. There’s so much potential data about books, and we only show the label? Let’s try to craft a query that also includes the title (P1476), illustrator (P110), publisher (P123) and publication date (P577).A first attempt might look like this: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610;
        wdt:P1476 ?title;
        wdt:P110 ?illustrator;
        wdt:P123 ?publisher;
        wdt:P577 ?published.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Run that query. As I’m writing this, it only returns two results – a bit meager! Why is that? We found over a hundred books earlier!The reason is that to match this query, a potential result (a book) must match all the triples we listed: it must have a title, and an illustrator, and a publisher, and a publication date. If it has some of those properties, but not all of them, it won’t match. And that’s not what we want in this case: we primarily want a list of all the books – if additional data is available, we’d like to include it, but we don’t want that to limit our list of results.The solution is to tell WDQS that those triples are optional: SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL { ?book wdt:P1476 ?title. }
  OPTIONAL { ?book wdt:P110  ?illustrator. }
  OPTIONAL { ?book wdt:P123  ?publisher. }
  OPTIONAL { ?book wdt:P577  ?published. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This gives us the additional variables (?title, ?publisher etc.) if the appropriate statement exists, but if the statement doesn’t exist, the result isn’t discarded – the variable simply isn’t set.Note: it’s very important to use separate OPTIONAL clauses here. If you put all the triples into a single clause, like here – SELECT ?book ?title ?illustratorLabel ?publisherLabel ?published
WHERE
{
  ?book wdt:P50 wd:Q35610.
  OPTIONAL {
    ?book wdt:P1476 ?title;
          wdt:P110 ?illustrator;
          wdt:P123 ?publisher;
          wdt:P577 ?published.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! – you’ll notice that most of the results don’t include any extra information. This is because an optional clause with multiple triples only matches when all those triples can be satisfied. That is: if a book has a title, an illustrator, a publisher, and a publication date, then the optional clause matches, and those values are assigned to the appropriate variables. But if a book has, for example, a title but no illustrator, the entire optional clause doesn’t match, and although the result isn’t discarded, all four variables remain empty. Expressions, FILTER and BIND This section might seem a bit less organized than the other ones, because it covers a fairly wide and diverse topic. The basic concept is that we would like to do something with the values that, so far, we’ve just selected and returned indiscriminately. And expressions are the way to express these operations on values. There are many kinds of expressions, and a lot of things you can do with them – but first, let’s start with the basics: data types. Data types Each value in SPARQL has a type, which tells you what kind of value it is and what you can do with it. The most important types are: item, like wd:Q42 for Douglas Adams (Q42). boolean, with the two possible values true and false. Boolean values aren’t stored in statements, but many expressions return a boolean value, e.g. 2 < 3 (true) or \"a\" = \"b\" (false). string, a piece of text. String literals are written in double quotes. monolingual text, a string with a language tag attached. In a literal, you can add the language tag after the string with an @ sign, e.g. \"Douglas Adams\"@en. numbers, either integers (1) or decimals (1.23). dates. Date literals can be written by adding ^^xsd:dateTime (case sensitive – ^^xsd:datetime won’t work!) to an ISO 8601 date string: \"2012-10-29\"^^xsd:dateTime. Operators The familiar mathematical operators are available: +, -, *, / to add, subtract, multiply or divide numbers, <, >, =, <=, >= to compare them. The inequality test ≠ is written !=. Comparison is also defined for other types; for example, \"abc\" < \"abd\" is true (lexical comparison), as is \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime and wd:Q4653 != wd:Q283111. And boolean conditions can be combined with && (logical and: a && b is true if both a and b are true) and || (logical or: a || b is true if either (or both) of a and b is true). FILTER Info For a sometimes faster alternative to FILTER, you might also look at MINUS, see example.FILTER(condition). is a clause you can insert into your SPARQL query to filter the results. Inside the parentheses, you can put any expression of boolean type, and only those results where the expression returns true are used.For example, to get a list of all humans born in 2015, we first get all humans with their date of birth – SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} – and then filter that to only return the results where the year of the date of birth is 2015. There are two ways to do that: extract the year of the date with the YEAR function, and test that it’s 2015 – FILTER(YEAR(?dob) = 2015). – or check that the date is between Jan. 1st (inclusive), 2015 and Jan. 1st, 2016 (exclusive): FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). I’d say that the first one is more straightforward, but it turns out the second one is much faster, so let’s use that: SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! Another possible use of FILTER is related to labels. The label service is very useful if you just want to display the label of a variable. But if you want to do stuff with the label – for example: check if it starts with “Mr. ” – you’ll find that it doesn’t work: SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! This query finds all instances of fictional human (Q15632617) and tests if their label starts with \"Mr. \" (STRSTARTS is short for “string starts [with]”; there’s also STRENDS and CONTAINS). The reason why this doesn’t work is that the label service adds its variables very late during query evaluation; at the point where we try to filter on ?humanLabel, the label service hasn’t created that variable yet.Fortunately, the label service isn’t the only way to get an item’s label. Labels are also stored as regular triples, using the predicate rdfs:label. Of course, this means all labels, not just English ones; if we only want English labels, we’ll have to filter on the language of the label: FILTER(LANG(?label) = \"en\"). The LANG function returns the language of a monolingual string, and here we only select those labels that are in English. The full query is: SELECT ?human ?label
WHERE
{
  ?human wdt:P31 wd:Q15632617;
         rdfs:label ?label.
  FILTER(LANG(?label) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?label, \"Mr. \")).
}
 Try it! We get the label with the ?human rdfs:label ?label triple, restrict it to English labels, and then check if it starts with “Mr. ”.One can also use FILTER with a regular expression. In the following example SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! If the format constraint for an ID is [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! It is possible to filter out specific elements like this FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) It is possible to filter and have elements that aren't filled: FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF These three features are often used in conjunction, so I’ll first explain all three of them and then show you some examples.A BIND(expression AS ?variable). clause can be used to assign the result of an expression to a variable (usually a new variable, but you can also overwrite existing ones).BOUND(?variable) tests if a variable has been bound to a value (returns true or false). It’s mostly useful on variables that are introduced in an OPTIONAL clause.IF(condition,thenExpression,elseExpression) evaluates to thenExpression if condition evaluates to true, and to elseExpression if condition evaluates to false. That is, IF(true, \"yes\", \"no\") evaluates to \"yes\", and IF(false, \"great\", \"terrible\") evaluates to \"terrible\".BIND can be used to bind the results of some calculation to a new variable. This can be an intermediate result of a larger calculation or just directly a result of the query. For example, to get the age of victims of capital punishment: SELECT ?person ?personLabel ?age
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?born;
          wdt:P570 ?died;
          wdt:P1196 wd:Q8454.
  BIND(?died - ?born AS ?ageInDays).
  BIND(?ageInDays/365.2425 AS ?ageInYears).
  BIND(FLOOR(?ageInYears) AS ?age).
  # or, as one expression:
  #BIND(FLOOR((?died - ?born)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND can also be used to simply bind constant values to variables in order to increase readability. For example, a query that finds all female priests: SELECT ?woman ?womanLabel
WHERE
{
  ?woman wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! can be rewritten like this: SELECT ?woman ?womanLabel
WHERE
{
  BIND(wdt:P31 AS ?instanceOf).
  BIND(wd:Q5 AS ?human).
  BIND(wdt:P21 AS ?sexOrGender).
  BIND(wd:Q6581072 AS ?female).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?priest).
  ?woman ?instanceOf ?human;
         ?sexOrGender ?female;
         ?occupation ?priest.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! The meaningful part of the query, from ?woman to ?priest., is now probably more readable. However, the large BIND block right in front of it is pretty distracting, so this technique should be used sparingly. (In the WDQS user interface, you can also hover your mouse over any term like wd:Q123 or wdt:P123 and see the label and description for the entity, so ?female is only more readable than wd:Q6581072 if you ignore that feature.)IF expressions are often used with condition-expressions built with BOUND. For example, suppose you have a query that shows some humans, and instead of just showing their label, you’d like to display their pseudonym (P742) if they have one, and only use the label if a pseudonym doesn’t exist. For this, you select the pseudonym in an OPTIONAL clause (it has to be optional – you don’t want to throw out results that don’t have a pseudonym), and then use BIND(IF(BOUND(… to select either the pseudonym or the label. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! Other properties that may be used in this way include nickname (P1449), posthumous name (P1786), and taxon common name (P1843) – anything where some sort of “fallback” makes sense.You can also combine BOUND with FILTER to ensure that at least one of several OPTIONAL blocks has been fulfilled. For example, let’s get all astronauts that went to the moon, as well as the members of Apollo 13 (Q182252) (close enough, right?). That restriction can’t be expressed as a single property path, so we need one OPTIONAL clause for “member of some moon mission” and another one for “member of Apollo 13”. But we only want to select those results where at least one of those conditions is true. SELECT ?astronaut ?astronautLabel
WHERE
{
  ?astronaut wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaut wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaut wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE The COALESCE function can be used as an abbreviation of the BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pattern for fallbacks mentioned above: it takes a number of expressions and returns the first one that evaluates without error. For example, the above “pseudonym” fallback BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label). can be written more concisely as BIND(COALESCE(?pseudonym, ?writerLabel) AS ?label). and it’s also easy to add another fallback label in case the ?writerLabel isn’t defined either: BIND(COALESCE(?pseudonym, ?writerLabel, \"<no label>\") AS ?label). Grouping So far, all the queries we’ve seen were queries that found all items satisfying some conditions; in some cases, we also included extra statements on the item (paintings with materials, Arthur Conan Doyle books with title and illustrator).But it’s very common that we don’t want a long list of all results. Instead, we might ask questions like this: How many paintings were painted on canvas / poplar wood / etc.? What is the highest population of each country’s cities? What is the total number of guns produced by each manufacturer? Who publishes, on average, the longest books? City populations Let’s look at the second question for now. It’s fairly simple to write a query that lists all cities along with their population and country, ordered by country: SELECT ?country ?city ?population
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
ORDER BY ?country
 Try it! (Note: that query returns a lot of results, which might cause trouble for your browser. You might want to add a LIMIT clause.)Since we’re ordering the results by country, all cities belonging to a country form one contiguous block in the results. To find the highest population within that block, we want to consider the block as a group, and aggregate all the individual population values into one value: the maximum. This is done with a GROUP BY clause below the WHERE block, and an aggregate function (MAX) in the SELECT clause. SELECT ?country (MAX(?population) AS ?maxPopulation)
WHERE
{
  ?city wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?country;
        wdt:P1082 ?population.
}
GROUP BY ?country
 Try it! We’ve replaced the ORDER BY with a GROUP BY. The effect of this is that all results with the same ?country are now grouped together into a single result. This means that we have to change the SELECT clause as well. If we kept the old clause SELECT ?country ?city ?population, which ?city and ?population would be returned? Remember, there are many results in this one result; they all have the same ?country, so we can select that, but since they can all have a different ?city and ?population, we have to tell WDQS which of those values to select. That’s the job of the aggregate function. In this case, we’ve used MAX: out of all the ?population values, we select the maximum one for the group result. (We also have to give that value a new name with the AS construct, but that’s just a minor detail.)This is the general pattern for writing group queries: write a normal query that returns the data you want (not grouped, with many results per “group”), then add a GROUP BY clause and add an aggregate function to all the non-grouped variables in the SELECT clause. Painting materials Let’s try it out with another question: How many paintings were painted on each material? First, write a query that just returns all paintings along with their painting material. (Take care to only use those made from material (P186) statements with an applies to part (P518)painting support (Q861259) qualifier.) SELECT ?material ?painting
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
 Try it! Next, add a GROUP BY clause on the ?material, and then an aggregate function on the other selected variable (?painting). In this case, we are interested in the number of paintings; the aggregate function for that is COUNT. SELECT ?material (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
}
GROUP BY ?material
 Try it! One problem with this is that we don’t have the label for the materials, so the results are a bit inconvenient to interpret. If we just add the label variable, we’ll get an error: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material
 Try it! Bad aggregate “Bad aggregate” is an error message you’ll probably see a lot when working with group queries; it means that one of the selected variables needs an aggregate function but doesn’t have one, or it has an aggregate function but isn’t supposed to have one. In this case, WDQS thinks that there might be multiple ?materialLabels per ?material (even though we know that can’t happen), and so it complains that you’re not specifying an aggregate function for that variable.One solution is to group over multiple variables. If you list multiple variables in the GROUP BY clause, there’s one result for each combination of those variables, and you can select all those variables without aggregate function. In this case, we’ll group over both ?material and ?materialLabel. SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
 Try it! We’re almost done with the query – just one more improvement: we’d like to see the most-used materials first. Fortunately, we’re allowed to use the new, aggregated variables from the SELECT clause (here, ?count) in an ORDER BY clause, so this is very simple: SELECT ?material ?materialLabel (COUNT(?painting) AS ?count)
WHERE
{
  ?painting wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?material; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?material ?materialLabel
ORDER BY DESC(?count)
 Try it! As an exercise, let’s do the other queries too. Guns by manufacturer What is the total number of guns produced by each manufacturer? Hint The relevant items and properties are: firearm (Q12796), manufacturer (P176), total produced (P1092). Example solution SELECT ?manufacturer ?manufacturerLabel (SUM(?produced) AS ?totalProduced)
WHERE
{
  ?model wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?manufacturer;
         wdt:P1092 ?produced.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?manufacturer ?manufacturerLabel
ORDER BY DESC(?produced)
 Try it! Publishers by number of pages What is the average (function: AVG) number of pages of books by each publisher? Hint The relevant items and properties are: publisher (P123), number of pages (P1104). Example solution SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
ORDER BY DESC(?avgPages)
 Try it! HAVING A small addendum to that last query – if you look at the results, you might notice that the top result has an outrageously large average, over ten times that of the second place. A bit of investigation reveals that this is because that publisher (UTET (Q4002388)) only published a single book with a number of pages (P1104) statement, Grande dizionario della lingua italiana (Q3775610), which skews the results a bit. To remove outliers like that, we could try to select only publishers that published at least two books with number of pages (P1104) statements on Wikidata.How do we do that? Normally, we restrict results with a FILTER clause, but in this case we want to restrict based on the group (the number of books), not any individual result. This is done with a HAVING clause, which can be placed right after a GROUP BY clause and takes an expression just like FILTER does: SELECT ?publisher ?publisherLabel (AVG(?pages) AS ?avgPages)
WHERE
{
  ?book wdt:P123 ?publisher;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?publisher ?publisherLabel
HAVING(COUNT(?book) > 1)
ORDER BY DESC(?avgPages)
 Try it! Aggregate functions summary Here’s a short summary of the available aggregate functions: COUNT: the number of elements. You can also write COUNT(*) to simply count all results. SUM, AVG: the sum or average of all elements, respectively. If the elements aren’t numbers, you’ll get weird results. MIN, MAX: the minimum or maximum value of all elements, respectively. This works for all value types; numbers are sorted numerically, strings and other types lexically. SAMPLE: any element. This is occasionally useful if you know there’s only one result, or if you don’t care which one is returned. GROUP_CONCAT: concatenates all elements. Useful for example if you want only one result for an item but you want to include informations for a property that may have several statements for this item, such as the occupations of a person. The different occupations may be regrouped and concatenated to appear all in only one variable instead of several lines in the results. If you’re curious, you can look it up in the SPARQL specification. Additionally, you can add a DISTINCT modifier for any of these functions to eliminate duplicate results. For example, if there are two results but they both have the same value in ?var, then COUNT(?var) will return 2 but COUNT(DISTINCT ?var) will only return 1. You often have to use DISTINCT when your query can return the same item multiple times – this can happen if, for example, you use ?item wdt:P31/wdt:P279* ?class, and there are multiple paths from ?item to ?class: you will get a new result for each of those paths, even though all the values in the result are identical. (If you’re not grouping, you can also eliminate those duplicate results by starting the query with SELECT DISTINCT instead of just SELECT.) wikibase:Label and aggregations A query such as the following, which searches all academic persons with more than two countries of citizenships in Wikidata, does not show the names of those countries in the ?citizenships column: select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! To show the ?citizenships, explicitly name the ?personLabel and ?citizenshipLabel in the wikibase:label service call like this: """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, le Wikidata Query Service (service de requête de Wikidata), est un outil puissant pour fournir un aperçu du contenu de Wikidata. Ce guide vous apprendra à l'utiliser. Voir aussi le tutoriel interactif par Wikimedia Israël.Avant de rédiger votre propre requête SPARQL, prenez le temps de regarder {{Item documentation}} ou toute autre requête générique avec modèle et voir si votre requête n'existe pas déjà. Contents 1 Avant de commencer 2 Les bases de SPARQL 3 Notre première requête 3.1 Auto-complétion 4 Motifs de triplets avancés 5 Classes et instances 5.1 Chemins de propriétés 6 Qualificatifs 7 ORDER et LIMIT 7.1 Exercice 7.1.1 Les livres d'Arthur Conan Doyle 7.1.2 Éléments chimiques 7.1.3 Les rivières qui se jettent dans le Mississippi 7.1.4 Les rivières qui se jettent dans le Mississippi II 8 OPTIONAL 9 Expressions, FILTER et BIND 9.1 Types de données 9.2 Opérateurs 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Groupement 10.1 Populations des villes 10.2 Matériaux de peinture 10.3 Fusils par fabricant 10.4 Editeurs par nombre de pages 10.4.1 HAVING 10.5 Sommaire des fonctions d’agrégation 10.6 wikibase:Label et agrégations 11 VALUES 12 Libellé en plusieurs langues 13 Et plus loin… 14 Voir aussi Avant de commencer Ce guide peut sembler très long et intimidant. Ne soyez pas effrayé ! Acquérir les bases de SPARQL va déjà vous permettre de faire pas mal de chemin — même si vous vous arrêter de lire après #Notre première requête, vous en saurez assez pour écrire de nombreuses requêtes intéressantes. Chaque section de cette page vous outille pour écrire encore plus de questions formidables.Si vous n'avez jamais entendu parler de Wikidata, SPARQL ou WDQS jusqu'à maintenant, voici une courte explication de ces mots : Wikidata est une base de connaissances. Cette base contient de nombreuses affirmations/déclarations, comme « la capitale du Canada est Ottawa » ou « la Joconde est peinte avec de la peinture à l'huile sur du bois de peuplier » ou encore « l'or a un point de fusion de 1 064,18 degrés Celsius ». SPARQL est un langage pour formuler des questions (requêtes) dans une base de connaissance. Avec la bonne base, une requête SPARQL peut répondre à des questions comme « quelle est la tonalité la plus populaire en musique? » ou « quel est le personnage qui a été le plus joué par des acteurs ou actrices ? » ou « quelle est la distribution des groupes sanguins? » or « quelles sont les œuvres d'auteur qui entrent dans le domaine public cette année? » WDQS, le service de requête Wikidata, joint les deux précédents : vous entrez une requête SPARQL, et elle s'exécute sur l'ensemble des données de Wikidata et vous montre le résultat.  Les bases de SPARQL Une requête SPARQL simple se présente ainsi : SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clause SELECT liste les variables que vous voulez renvoyer (les variables commencent avec un point d'interrogation) et la clause WHERE contient des restrictions sur ces variables, principalement sous la forme de triplets ; quand vous exécutez la requête, le service de requête essaye de combiner les variables avec les valeurs courantes de telle manière que les triplets résultant de ce remplissage soient présents dans la base de connaissances, et renvoie un résultat pour chaque combinaison de variables que le service trouve.Un triplet peut être vu comme représentant deux sommets (i.e. 2 noeuds, 2 ressources) connectés par une arête ou arc (une propriété) à l'intérieur du vaste multigraphe de propriétés orienté que constitue Wikidata. - Il peut être lu comme une phrase (qui se termine avec un point), avec un sujet, un prédicat et un objet. Les termes en anglais sont : subject, predicate, and object : SELECT ?fruit
WHERE
{
  ?fruit aCouleur jaune.
  ?fruit goût acide.
} Les résultats pour cette question peuvent inclure, par exemple, \"citron\". Dans Wikidata, la plupart des propriétés sont de type \"a le/la\" (en anglais : “has”-kind properties), ainsi la requête pourrait aussi être lue : SELECT ?fruit
WHERE
{
  ?fruit couleur jaune.
  ?fruit goût aigre.
} qui se lit comme “?fruit a la couleur ‘jaune’” (et non pas “?fruit est la couleur de ‘jaune’” – gardez cela en tête pour les paires de propriétés comme “parent”/“enfant”!).Cependant, ce n'est pas un bon exemple pour WDQS. Les goûts sont subjectifs, aussi Wikidata n'a pas de propriété pour cela. Laissons cela de côté, et intéressons-nous aux relations parent/enfant, qui sont généralement non-ambigües. Notre première requête Supposons que nous voulions la liste de tous les enfants du compositeur baroque Jean-Sébastien Bach. En utilisant les pseudo-éléments comme dans les requêtes ci-dessus, comment écririez-vous la requête ?Avec un peu de chance, vous obtenez quelque chose comme cela : SELECT ?enfant
WHERE
{
  #  enfant \"a pour parent\" Bach
  ?enfant parent Bach.
  # (note : tout ce qui se trouve après un « # » est un commentaire de code et est ignoré par WDQS.)
} ou ceci, SELECT ?enfant
WHERE
{
  # enfant \"a pour père\" Bach 
  ?enfant père Bach. 
} ou ceci, SELECT ?enfant
WHERE
{
  #  Bach \"a pour enfant\" enfant
  Bach enfant ?enfant.
} Les deux premiers triplets disent que la variable ?enfant doit avoir le 'parent/père' Bach ; le troisième triplet dit que Bach doit avoir un enfant avec une variable ?enfant. Allons-y avec le deuxième pour l'instant.Que reste-t-il à faire pour transformer cela en une requête WDQS correcte ? Dans Wikidata, les éléments et les propriétés ne sont pas identifiés par des noms lisibles par des humains tel que \"père\" (propriété) ou \"Bach\" (élément). (Pour de bonnes raisons : \"Johann Sebastian Bach\" est aussi le nom d'un peintre allemand et \"Bach\" peut aussi faire référence au nom de famille, à la commune française, au cratère sur Mercure, etc.) Au lieu de cela, éléments et propriétés de Wikidata sont affectés à un identifiant. Pour trouver l'identifiant d'un élément, nous cherchons cet élément et nous copions le Q-nombre qui semble être celui de l'élément que nous cherchons (en nous basant sur la description, par exemple). Pour trouver l'identifiant d'une propriété, nous faisons la même chose mais en cherchant “P:terme cherché” au lieu de “terme cherché”, ce qui limite la recherche aux propriétés. Ceci nous apprend que le fameux compositeur Jean-Sébastien Bach est Q1339 et que la propriété pour désigner le père d'un élément est P:P22.Enfin, nous avons besoin d'inclure les préfixes. Pour des triplets WDQS de base, les éléments doivent être préfixés avec wd: et les propriétés avec wdt:. (Mais ceci ne s'applique qu'aux valeurs - les variables n'ont pas de préfixe !)En mettant tout cela ensemble, nous arrivons à notre première requête WDQS correcte : SELECT ?enfant
WHERE
{
# ?enfant père Bach
  ?enfant wdt:P22 wd:Q1339.
}
 Try it! Cliquez sur le lien « Essayez ! » puis « lancez » la requête sur la page WDQS. Qu'obtenez-vous ? enfant wd:Q57225 wd:Q76428 … Bon c'est décevant. Vous ne voyez que les identifiants. Vous pouvez cliquer dessus pour voir leur page Wikidata (incluant un libellé lisible par les humains), mais n'y a-t-il pas une meilleure manière de voir les résultats ?Et bien, comme nous allons le voir, c'est possible ! (N'est-ce pas que c'est génial de se poser des questions rhétoriques ?) Si vous incluez le texte magique SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } quelque part à l'intérieur de la clause WHERE, vous obtenez des variables additionnelles : pour chaque variable ?foo, vous avez maintenant une variable ?fooLabel qui contient le libellé de l'élément correspondant à ?foo. Si vous ajoutez ceci à la clause SELECT, vous obtenez l'élément et aussi le libellé SELECT ?enfant ?enfantLabel
WHERE
{
# ?enfant père Bach
  ?enfant wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Essayez d'exécuter la requête — vous devriez voir non seulement les numéros des éléments, mais aussi les noms des différents enfants. enfant enfantLibellé wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Auto-complétion Le bout de code SERVICE est difficile à retenir, n'est-ce pas ? Et parcourir la fonction de recherche pendant que vous écrivez la requête est aussi fastidieux. Heureusement, WDQS offre une bonne solution à ceci : l'auto-complétion. Dans l'éditeur de requêtes query.data.org, vous pouvez appuyer sur Ctrl+Espace (ou Alt+Entrée ou Ctrl+Alt+Entrée) à n'importe quel point de la question et avoir des suggestions de code qui peuvent être appropriées ; sélectionnez la bonne suggestion avec les touches flèche haut et flèche bas, et appuyer sur Entrée pour la sélectionner.Par exemple, au lieu d'écrire SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } à chaque fois, vous pouvez saisir SERV, taper Ctrl+Espace, et la première suggestion sera l'incantation complète du label du service, prête à l'emploi ! Taper simplement Entrée pour l'accepter. (Le formatage sera un peu différent, mais ça n'a pas d'importance.)Et l'auto-complétion peut aussi chercher pour vous. Si vous tapez un des préfixes Wikidata, comme wd: ou wdt:, et que vous écrivez ensuite du texte juste après, Ctrl+Espace va faire une recherche avec ce texte dans Wikidata et suggérer des résultats. wd: cherche des éléments, wdt: des propriétés. Par exemple, au lieu de chercher les éléments pour Johann Sebastian Bach (Q1339) et father (P22), vous pouvez simplement taper wd:Bach et wdt:père et sélectionner la bonne entrée proposée par l'auto-complétion. (Ceci marche aussi avec des espaces dans le texte, par ex. wd:Johann Sebastian Bach.) Motifs de triplets avancés Jusqu'à maintenant nous avons vu tous les enfants de Johann Sebastian Bach - plus exactement : tous les éléments avec le père Johann Sebastian Bach. Mais Bach a eu deux épouses, et ces éléments ont donc deux mères différentes : que faire si nous voulons voir seulement les enfants de Johann Sebastian Bach avec sa première épouse, Maria Barbara Bach (Q57487)? Essayez d'écrire cette requête basée sur celle ci-dessous.C'est fait ? Ok, alors la solution. Le plus simple est d'ajouter un deuxième triplet avec cette restriction : SELECT ?enfant ?enfantLabel
WHERE
{
  ?enfant wdt:P22 wd:Q1339.
  ?enfant wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En langage naturel, cela se lit : Enfant a pour père Johann Sebastian Bach. Enfant a pour mère Maria Barbara Bach. Cela semble un peu difficile, n'est ce pas ? En langage naturel, nous abrégerions en : Enfant a pour père Johann Sebastian Bach et pour mère Maria Barbara Bach. En fait, il est possible d'exprimer la même version abrégée en SPARQL : si vous terminez un triplet avec un point-virgule (;) au lieu d'un point, vous pouvez ajouter une autre paire prédicat-objet. Ceci nous permet d'abréger la requête ci-dessus en : SELECT ?enfant ?enfantLabel
WHERE
{
  ?enfant wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ce qui donne le même résultat, mais avec moins de répétition dans la requête.Maintenant supposons que, parmi ces résultats, nous ne soyons intéressés que par les enfants qui sont compositeurs et pianistes. Les propriétés et les éléments correspondants sont occupation (P106), composer (Q36834) et pianist (Q486748). Essayez de mettre à jour la requête ci-dessus pour ajouter ces restrictions !Voici ma solution : SELECT ?enfant ?enfantLabel
WHERE
{
  ?enfant wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Cette solution utilise l'abrégé ; deux fois pour ajouter les deux professions. Mais comme vous pouvez le remarquer, il y a encore des répétitions. C'est comme si nous disions : Enfant a la profession compositeur et la profession pianiste. que nous abrégerions généralement en : Enfant a les professions de compositeur et de pianiste. Et SPARQL a aussi une syntaxe pour ça : de la même manière que ; vous permet d'ajouter une paire prédicat-objet à un triplet (en réutilisant le sujet), , vous permet d'ajouter un autre objet à un triplet (en réutilisant à la fois le sujet et le prédicat). Avec cela, la requête peut être abrégée en : SELECT ?enfant ?enfantLabel
WHERE
{
  ?enfant wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note : l’indentation et les autres espaces n'ont pas d'importance — ils rendent la lecture plus facile. Vous pouvez aussi l'écrire comme : SELECT ?enfant ?enfantLabel
WHERE
{
  ?enfant wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # les deux occupations sont sur une seule ligne
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ou, encore moins lisible : SELECT ?enfant ?enfantLabel
WHERE
{
  ?enfant wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # aucune indentation ; rend plus difficile la distinction entre ; et ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Heureusement, l'éditeur WDQS indente automatiquement les lignes, donc généralement vous n'avez pas à vous en occuper.Bien, résumons tout cela ici. Nous avons vu que les requêtes sont structurées comme du texte. Chaque triplet sur un sujet est terminé par un point. Des prédicats multiples sur le même sujet sont séparés par des points-virgule, et de multiples objets pour le même sujet et le même prédicat peuvent être écrits comme une liste séparée par des virgules. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Maintenant je veux introduire une autre abréviation qu'offre SPARQL. Vous me permettez un autre scénario hypothétique…Supposons que nous ne sommes pas tellement intéressés par les enfants de Bach (qui sait, c'est peut-être votre cas !). Mais nous nous intéressons à ses petits-enfants (de manière hypothétique). Il y a une complication ici: un petit-enfant peut être relié à Bach par son père ou par sa mère. Il y a deux propriétés différentes, ce qui n'est pas pratique. Au lieu de ça, sautons par-dessus le problème : Wikidata a une propriété « enfant », P:P40, qui pointe d'un parent à un enfant et indépendante du genre. Avec cette information, pouvez-vous écrire une requête qui renvoie les petits-enfants de Bach ?Voici ma solution : SELECT ?petitEnfant ?petitEnfantLabel
WHERE
{
  wd:Q1339 wdt:P40 ?enfant.
  ?enfant wdt:P40 ?petitEnfant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En langage naturel, cela se lit : Bach a un enfant ?enfant. ?enfant a un enfant ?petitEnfant. Encore une fois, je propose d'abréger cette phrase en langage naturel, et ainsi je veux vous montrer comment SPARQL fournit une telle abréviation. Observez comment nous ne nous soucions pas réellement de l'enfant : nous n'utilisons la variable ?enfant que pour atteindre le petit-enfant. Par conséquent, nous pouvons abréger la phrase en : Bach a un enfant quelconque qui a un enfant ?petitEnfant. Au lieu de dire de quel enfant de Bach il s'agit, nous disons juste un enfant « quelconque » : nous ne faisons pas attention à l'enfant. Mais nous pouvons y faire référence car nous avons dit un enfant « quelconque » « qui » : le « qui » démarre une clause relative (une proposition subordonnée) qui nous permet de dire des choses au sujet de cet enfant « quelconque » (e.g. que quelqu’un « a un enfant ?petitEnfant »). D’une certaine manière, « quelconque » est une variable, mais une variable un peu spéciale qui n'est valide que dans la clause relative, et à laquelle on ne veut pas se référer explicitement (nous disons « une quelconque personne qui est ceci et fait cela », et non pas « une quelconque personne qui est ceci et une quelconque personne qui fait cela » — ce sont deux « quelconques » qui sont des personnes différentes).En SPARQL, cela peut être écrit comme suit : SELECT ?petitEnfant ?petitEnfantLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?petitEnfant ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Vous pouvez utiliser une paire de crochets ([]) à la place d'une variable, ce qui a l'effet d'une variable anonyme. Dans les crochets, vous pouvez spécifier des paires prédicat-objet, comme après un ; qui suit un triplet normal; le sujet implicite est dans ce cas la variable anonyme que les crochets représentent. (Note: comme après un ;, vous pouvez ajouter plus de paires prédicat-objet avec plus de points-virgules, ou plus d'objets pour le même prédicat avec plus de virgules.)Et voilà pour les motifs de triplets ! Il y a plus dans SPARQL, mais comme nous allons quitter les parties qui sont fortement analogues avec le langage naturel, je voudrai résumer ces analogies encore une fois : langage naturel exemple SPARQL exemple phrase Juliette aime Roméo. point juliette aime roméo. conjonction (clause) Roméo aime Juliette et tue Roméo. point-virgule roméo aime juliette ; tue roméo. conjonction (noms) Roméo tue Tybalt et Roméo. virgule roméo tue tybalt, roméo. clause relative (proposition subordonnée) Juliette aime quelqu'un qui tue Tybalt. crochets juliette aime [ tue tybalt ].  Classes et instances Plus tôt, j'ai dit que la plupart des propriétés Wikidata sont des relations \" le / a la\" : a l'enfant, a le père, a la profession. Mais quelquefois (en réalité, fréquemment) vous avez aussi besoin de parler sur ce que quelque chose \"est\". En fait, il y a deux sortes de relations ici : Autant en emporte le vent est un film. Un film est une œuvre d'art. Autant en emporte le vent est un film en particulier. Il a son metteur en scène (Victor Fleming), une durée spécifique (238 minutes), une distribution d'acteurs (Clark Gable, Vivien Leigh, …), etc.Film est un concept général. Les films peuvent avoir des metteurs en scène, des durées, des distributions d'acteurs, mais le concept « film » ne fait référence à aucun metteur en scène, aucune durée, aucune distribution d'acteurs en particulier. Et bien qu'un film soit une œuvre d'art, et qu'une œuvre d'art ait généralement un créateur, le concept de « film » lui-même n'a pas de créateur - seules des instances particulières de ce concept en ont un (créateur).Cette différence explique pourquoi il y a deux propriétés pour « est » dans Wikidata : instance of (P31) et subclass of (P279). Autant en emporte le vent est une instance particulière de la classe « film » ; la classe « film » est une sous-classe (une classe plus spécifique ; une spécialisation) de la classe plus générale « œuvre d'art ».Pour vous aider à faire la différence, vous pouvez essayer d'utiliser deux verbes différents : « est » et « est une sorte de ». Si le verbe « est une sorte de » fonctionne (e.g. Un film « est une sorte de » œuvre d'art), ceci indique que vous énoncez un fait sur une sous-classe, une spécialisation d'une classe plus générale et vous devez utiliser subclass of (P279). Si « est une sorte de » ne fonctionne pas (par ex. la phrase Autant en emporte le vent « est une sorte de » film n'a pas de sens), cela indique que vous énoncez un fait sur une instance particulière et vous devez utiliser instance of (P31).Note pour le français : la traduction française choisie pour instance of est « nature de l'élément », ce qui diffère sensiblement des autres traductions qui veulent plus ou moins dire « est un » ou « instance de ». La justification donnée dans la page instance of (P31) est la suivante « Cet élément est un exemple spécifique de cette classe qui en précise la nature. »Donc qu'est ce que ça signifie pour nous lorsque nous écrivons des requêtes SPARQL ? Lorsque nous voulons chercher « toutes les œuvres d'art », ce n'est pas suffisant de chercher tous les éléments qui sont des instances directes de « œuvre d'art » : SELECT ?oeuvre ?oeuvreLabel
WHERE
{
  ?oeuvre wdt:P31 wd:Q838948. # instance d'une œuvre d'art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Lorsque j'ai écrit ceci (octobre 2016), cette requête retrouvait 2615 résultats - évidemment, il y a plus d’œuvres d'art que cela ! Le problème est qu'il manque des éléments comme \"Autant en emporte le vent\", qui est seulement une instance de \"film\" et non de \"œuvre d'art\". \"film\" est une sous-classe d'\"œuvre d'art\", mais nous devons dire à SPARQL de prendre cela en compte lors de la recherche.Une solution possible est la syntaxe [] dont nous avons déjà parlé : Autant en emporte le vent est l'instance d'une sous-classe quelconque de « œuvre d'art » (Pour vous exercer, essayez d'écrire cette requête !). Mais cela pose toujours des problèmes : Nous n'incluons plus maintenant des éléments qui sont des instances directes de \"œuvre d'art\". Nous manquons des éléments qui sont des instances de certaines sous-classes de certaines \"autres\" sous-classes de \"œuvre d'art\" - par exemple, \"Blanche-Neige et les sept nains\" est un dessin animé, qui est un film, qui est une œuvre d'art. Dans ce cas, nous avons besoin de deux propriétés \"sous-classe de\" - mais on pourrait en avoir besoin de trois, quatre, cinq, de n'importe quel nombre en réalité. La solution : ?element wdt:P31/wdt:P279* ?classe. Cela veut dire qu'il y a un chemin entre l'élément et la classe qui comporte une propriété « nature de l'élément » et n'importe quel nombre de fois la propriété « sous-classe de ». SELECT ?oeuvre ?oeuvreLabel
WHERE
{
  ?oeuvre wdt:P31/wdt:P279* wd:Q838948. # instance de n'importe quelle sous-classe d'une œuvre d'art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Je ne recommande pas d'exécuter cette requête. WDQS peut la gérer (tout juste), mais il est possible que votre navigateur se plante lors de l'affichage des résultats car ils sont très nombreux.)Maintenant vous savez chercher parmi toutes les œuvres d'art ou tous les bâtiments ou toutes les colonies humaines: l'incantation magique wdt:P31/wdt:P279* avec la classe appropriée. Ceci utilise certaines caractéristiques de SPARQL que je n'ai pas encore expliqué, mais honnêtement, on a là (presque) la seule utilisation pertinente de ces caractéristiques, ainsi vous n'avez pas \"besoin\" de comprendre comment ça fonctionne pour utiliser efficacement WDQS . Si vous voulez en savoir plus, je vais expliquer cela un petit peu, mais vous pouvez aussi sauter la prochaine section et mémoriser ou copier-coller wdt:P31/wdt:P279* à partir d'ici quand vous en avez besoin. Chemins de propriétés En général, le chemin qui permet de connecter le noeud-source (sujet) au noeud-cible (objet) dans le graphe n'est pas toujours direct: on peut avoir à concaténer un ou plusieurs maillons (segments) en une chaîne; et il peut aussi y avoir plusieurs tels chemins pour se rendre. Dans une chaîne donnée, l'objet d'un maillon devient le sujet du maillon qui suit. - Dans SPARQL, les chemins de propriétés sont une manière d'écrire sobrement une telle suite de propriétés entre deux éléments. Le chemin le plus simple est composé d'une seule propriété, ce qui forme un triplet ordinaire : ?élément wdt:P31 ?classe. On peut ajouter des maillons de chemins avec un slash droit (/). ?élément wdt:P31/wdt:P279/wdt:P279 ?classe. Ce qui est équivalent à l'une ou l'autre des formulations suivantes : ?élément wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?classe. ?élément wdt:P31 [ wdt:P279 [ wdt:P279 ?classe ] ]. Exercice : ré-écrivez la question précédente sur les \"petits-enfants\" de Bach, en utilisant cette syntaxe.Une astérisque (*) après un maillon de chemin signifie « zéro ou plus de ce maillon ». ?élément wdt:P31/wdt:P279* ?classe.
# signifie :
?élément wdt:P31 ?classe
# ou
?élément wdt:P31/wdt:P279 ?classe
# ou
?élément wdt:P31/wdt:P279/wdt:P279 ?classe
# ou
?élément wdt:P31/wdt:P279/wdt:P279/wdt:P279 ?classe
# ou ... Dans le cas spécial où il y a zéro propriété dans un chemin (aucun arc spécifique de relation, propriété NULLE, \"universelle\"), le noeud-sujet est alors directement connecté au noeud-objet dans le graphe, et ce, quel que soit l'objet, y compris lui-même. De sorte qu'il y a toujours une correspondance (\"match\"). - Ainsi, dans SPARQL, pour le cas par exemple où il y a \"zéro occurrence\" de \"quelqueChose\", ?a quelqueChose* ?b se réduit à ?a ?b, sans aucun maillon entre eux, et ?a prend alors directement la valeur de ?b.Un plus (+) est similaire à une astérisque, mais signifie \"un\" ou plus d'un maillon. La requête suivante trouve tous les descendants de Bach : SELECT ?descendant ?descendantLabel
WHERE
{
  wd:Q1339 wdt:P40+ ?descendant.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Si nous avions utilisé une astérisque au lieu d'un plus, les résultats de la requête auraient aussi inclus Bach lui-même.Un point d'interrogation (?) est similaire à une astérisque ou à un plus, mais a la signification \"zéro ou un de ce maillon\".Vous pouvez séparer des maillons de chemin avec une barre verticale (|) au lieu d'un slash avant; ceci signifie \"soit-soit\" (une alternative). Le chemin peut utiliser l'une ou l'autre des propriétés. (Mais pas les deux - un maillon \"soit-soit\" est toujours en correspondance avec un chemin d'une seule propriété.)Vous pouvez aussi grouper les maillons avec des parenthèses (()), et combiner librement toutes ces différentes syntaxes (/|*+?). Ceci signifie qu'une autre manière de trouver tous les descendants de Bach est : SELECT ?descendant ?descendantLabel
WHERE
{
  ?descendant (wdt:P22|wdt:P25)+ wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Au lieu d'utiliser la propriété \"enfant\" pour aller de Bach à ses descendants, nous utilisons la propriété \"mère\" et \"père\" pour aller des descendants jusqu'à Bach. Le chemin peut contenir deux mères et un père ou quatre pères ou père-mère-mère-père ou tout autre combinaison. (Bien que, évidemment, Bach ne peut être la mère de personne, donc le dernier maillon sera toujours père.) Qualificatifs Note pour la traduction française : Qualifiers ne font pas partie du SPARQL 1.1 https://www.w3.org/TR/sparql11-query/Wikidata emploie le terme de qualificatifs, c'est celui qu'on utilise.(D'abord, les bonnes nouvelles: cette section n'introduit pas de nouvelle syntaxe de SPARQL! Donc prends une petite respiration et relaxe-toi, ceci devrait être très simple.)Nous avons jusqu'à présent seulement parlé des déclarations simples: sujet, propriété, objet. Mais les déclarations de Wikidata sont plus que cela: une déclaration peut aussi avoir des qualificatifs et des références. Par exemple, la Joconde (Q12418) a trois déclarations pour made from material (P186): oil paint (Q296955), le matériau principal; poplar wood (Q291034), avec le qualificatifapplies to part (P518)painting support (Q861259) – c'est le matériau sur lequel a été peint le tableau; et wood (Q287), avec le qualificatif applies to part (P518)stretcher (Q1737943) et start time (P580) 1951 – c'est une partie qui a été ajoutée à la peinture plus tard. Supposons que nous voulions trouver toutes les peintures avec le matériau de leur support de peinture, c'est-à-dire ayant une déclaration made from material (P186) avec le qualificatif applies to part (P518)painting support (Q861259) . Comment faire ? C'est davantage d'informations que ce qu'on peut représenter avec un seul triplet.La réponse est : davantage de triplets ! (Règle d'or : La solution de Wikidata pour la plupart des choses est « plus d'éléments », et la règle correspondante pour WDQS est « plus de triplets ». Références, précision numérique, valeurs avec leurs unités, géolocalisation, etc. (dont nous n'allons pas parler ici) fonctionnent de cette façon). Nous avons jusqu'à présent utilisé le préfixe wdt: dans nos déclarations (triples), qui pointent directement vers l'objet d'une déclaration. Mais il existe aussi un autre préfixe p: qui ne pointe pas sur l'objet, mais sur le \"nœud de déclaration\". Ce nœud est alors le sujet d'autres triplets : le préfixe ps: (pour property -propriété- statement -déclaration-) pointe sur l'objet de la déclaration, le préfixe pq: (property -propriété- qualifier -alificatif-) sur les qualificatifs, et prov:wasDerivedFrom pointe sur les nœuds de références (que nous n'aborderons pas maintenant).Ceci a été très abstrait. Nous allons prendre un exemple plus concret avec la Joconde : wd:Q12418 p:P186 ?déclaration1.    # Mona Lisa : matériau utilisé : ?déclaration1
?déclaration1 ps:P186 wd:Q296955.  # valeur : peinture à l'huile

wd:Q12418 p:P186 ?déclaration2.    # Mona Lisa : matériau utilisé : ?déclaration2
?déclaration2 ps:P186 wd:Q291034.  # valeur : bois de peuplier
?déclaration2 pq:P518 wd:Q861259.  # qualificatif : s'applique à : support de peinture

wd:Q12418 p:P186 ?déclaration3.    # Mona Lisa : matériau utilisé : ?déclaration3
?déclaration3 ps:P186 wd:Q287.     # valeur : bois
?déclaration3 pq:P518 wd:Q1737943. # qualificatif : s'applique à : châssis
?déclaration3 pq:P580 1951.        # qualificatif : date de début: 1951 (pseudo-syntaxe) Nous pouvons abréger ceci si nous utilisons la syntaxe [], remplaçant les variables ?statement : wd:Q12418 p:P186 [ ps:P186 wd:Q296955 ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q291034;
            pq:P518 wd:Q861259
          ].

wd:Q12418 p:P186 [
            ps:P186 wd:Q287;
            pq:P518 wd:Q1737943;
            pq:P580 1951
          ]. Pouvez-vous utiliser cette connaissance pour écrire une requête pour toutes les peintures avec le matériau sur lequel elles ont été peintes?Voici ma solution : SELECT ?peinture ?peintureLabel ?matériau ?matériauLabel
WHERE
{
  ?peinture wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?matériau; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! D'abord, nous limitons ?peinture à toutes les instances de painting (Q3305213) ou de l'une de ses sous-classes. Après, nous obtenons le matériau du nœud de déclaration p:P186, en limitant les déclarations à celles qui ont un qualificatifapplies to part (P518)painting support (Q861259) . ORDER et LIMIT Nous revenons sur notre visite régulière des caractéristiques supplémentaires de SPARQL.Jusqu'à maintenant, nous avons écrit des requêtes dont l'ensemble des résultats nous intéressait. Cependant il est fréquent de se soucier seulement de certains résultats : ceux qui sont extrêmes d'une manière ou d'une autre - la plus vieille, la plus jeune, la plus ancienne, la plus récente, la plus élevée parmi une population, la température de fusion la plus basse, le plus d'enfants, le matériel le plus souvent utilisé, etc. Le facteur commun ici est que les résultats sont \"classés\" d'une certaine manière, et qu'ensuite nous nous intéressons seulement aux premiers résultats (ceux avec le meilleur classement).Ceci est contrôlé par deux clauses ajoutées au bloc WHERE {} (après les accolades, et non à l'intérieur!): ORDER BY et LIMIT.ORDER BY quelqueChosetrie les résultats selon quelqueChose. quelqueChose peut être n'importe quelle expression – pour l'instant, le seul type d'expression que nous connaissons sont les simples variables (?quelqueChose), mais nous en verrons d'autres plus tard. Cette expression peut être caractérisée avec soit ASC() soit DESC() pour préciser l'ordre de classement (ascendant ou descendant). (Si vous ne précisez aucun ordre, l'ordre par défaut est l'ordre ascendant, ainsi ASC(quelqueChose) est équivalent à quelqueChose.)LIMIT compte coupe la liste de résultats à compte résultats, où compte est un nombre entier naturel. Par exemple, LIMIT 10 limite la requête à dix résultats. LIMIT 1 ne revoie qu'un seul résultat.(Vous pouvez aussi utiliser LIMIT sans ORDER BY. Dans ce cas, les résultats ne sont pas triés, aussi vous n'avez aucune garantie sur les résultats que vous recevez. C'est bien s'il vous arrive de savoir qu'il n'y a qu'un certain nombre de résultats, ou bien que vous n'êtes intéressés que par \"quelques\" résultats, peu importe lesquels. Dans d'autres cas, ajouter LIMIT peut accélérer significativement le temps de traitement de la requête, puisque WDQS peut arrêter la recherche de résultats dès qu'il y en a assez pour la limite demandée.)C'est le temps des exercices ! Essayez d'écrire une requête qui renvoie les dix nations les plus peuplées. (Une nation est un sovereign state (Q3624078), et la propriété pour la population est P:P1082.) Vous pouvez commencer par chercher les nations avec leur population, puis ajouter les clauses ORDER BY et LIMIT.Voici ma solution : SELECT ?nation ?nationLabel ?population
WHERE
{
  ?nation wdt:P31/wdt:P279* wd:Q3624078;
           wdt:P1082 ?population.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
ORDER BY DESC(?population)
LIMIT 10
 Try it! Notez que si nous voulons les nations les \"plus\" peuplées, nous avons à les ordonner par population \"descendante\", afin que les premiers résultats soient ceux avec les valeurs les plus élevées. Exercice Nous avons couvert beaucoup de domaines jusqu'ici - je pense qu'il est temps de faire quelques exercices. (Vous pouvez sauter cette section si vous êtes pressé.) Les livres d'Arthur Conan Doyle Écrire une requête qui renvoie tous les livres de Sir Arthur Conan Doyle. Aide Les éléments et propriétés pertinents sont : Arthur Conan Doyle (Q35610), author (P50). Exemple de solution SELECT ?livre ?livreLabel
WHERE
{
  ?livre wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Éléments chimiques Écrire une requête qui renvoie tous les éléments chimiques avec leur symbole chimique et leur nombre atomique, dans l'ordre de leur nombre atomique. Aide Les éléments et propriétés pertinents sont : chemical element (Q11344), element symbol (P246), atomic number (P1086). Exemple de solution SELECT ?element ?elementLabel ?symbole ?nombre
WHERE
{
  ?element wdt:P31 wd:Q11344;
           wdt:P246 ?symbole;
           wdt:P1086 ?nombre.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
ORDER BY ?nombre
 Try it!  Les rivières qui se jettent dans le Mississippi Écrire une requête qui renvoie toutes les rivières qui se jettent directement dans le Mississippi (La plus grande difficulté est de trouver la bonne propriété…). Indice Les éléments et propriétés pertinents sont : Mississippi River (Q1497), mouth of the watercourse (P403). Exemple de solution SELECT ?riviere ?riviereLabel
WHERE
{
  ?riviere wdt:P403 wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it!  Les rivières qui se jettent dans le Mississippi II Écrire une requête qui renvoie toutes les rivières qui se jettent dans le Mississippi, directement ou indirectement. Indice Cette requête est presque identique à la requête précédente. La différence est que cette fois vous avez besoin d'un chemin de propriété au lieu d'un triplet. (Si vous avez sauté la section sur les chemins de propriétés, sautez aussi cet exercice.) Exemple de solution SELECT ?riviere ?riviereLabel
WHERE
{
  ?riviere wdt:P403+ wd:Q1497.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! OPTIONAL Dans les exercices ci-dessous, il y a une requête pour tous les livres de Sir Arthur Conan Doyle SELECT ?livre ?livreLabel
WHERE
{
  ?livre wdt:P50 wd:Q35610.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mais cela est un peu court. Il y a tellement plus de données disponibles sur livres et on montre seulement leur libellé ? Essayons de rédiger une requête qui inclut aussi les valeurs de title (P1476), illustrator (P110), publisher (P123) et publication date (P577).Un premier jet peut ressembler à ceci : SELECT ?livre ?titre ?illustrateurLabel ?éditeurLabel ?publié
WHERE
{
  ?livre wdt:P50 wd:Q35610;
        wdt:P1476 ?titre;
        wdt:P110 ?illustrateur;
        wdt:P123 ?éditeur;
        wdt:P577 ?publié.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Lancez cette requête. À l’heure ou ces lignes sont écrites, elle renvoie seulement deux résultats — un peu maigre ! Pourquoi donc alors que nous avons trouvé précédemment une centaine de livres ?La raison est que pour faire correspondre cette requête, un résultat potentiel (un livre) doit correspondre à tous les triplets listés : il doit avoir un titre, et un illustrateur, et un éditeur, et une date de publication. Si un des livres a quelques unes de ces propriétés, mais pas toutes, elles ne seront pas sélectionnées. Et ce n'est pas ce que nous voulons ici : nous voulons lister avant tout tous les livres. Si des données supplémentaires, sont disponibles, on aimerait les inclure sans pour autant limiter notre liste des résultats.La solution est de dire à WDQS que ces triplets sont optionnels (OPTIONAL) : SELECT ?livre ?titre ?illustrateurLabel ?éditeurLabel ?publié
WHERE
{
  ?livre wdt:P50 wd:Q35610.
  OPTIONAL { ?livre wdt:P1476 ?titre. }
  OPTIONAL { ?livre wdt:P110  ?illustrateur. }
  OPTIONAL { ?livre wdt:P123  ?éditeur. }
  OPTIONAL { ?livre wdt:P577  ?publié. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Cela nous donne des variables supplémentaires (?titre, ?editeur etc.) si l'instruction appropriée existe. Sinon, le résultat est ignoré et la variable n'est tout simplement pas définie.Note : ici, il est très important d'utiliser de manière séparée les clauses OPTIONAL. Si vous mettez tous les triplets dans une seule, comme ici — SELECT ?livre ?titre ?illustrateurLabel ?éditeurLabel ?publié
WHERE
{
  ?livre wdt:P50 wd:Q35610.
  OPTIONAL {
    ?livre wdt:P1476 ?titre;
          wdt:P110 ?illustrateur;
          wdt:P123 ?éditeur;
          wdt:P577 ?publié.
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
}
 Try it! — vous remarquerez que la plupart des informations n'inclue pas d'information supplémentaire. Ceci est dû au fait qu'une clause optionnelle avec des triplets multiples correspond uniquement quand ces trois triplets correspondent à l'objet choisi. C'est Si un livre a un titre, un illustrateur, un éditeur et une date de publication alors la clause optionnelle identifie le livre et ses valeurs sont assignées aux variables appropriées. Mais si un livre a, par exemple, un titre mais pas d'illustrateur, la clause entière ne correspondra pas au livre, et bien que le résultat ne soit pas ignoré, les quatre variables restent vides. Expressions, FILTER et BIND Cette section peut paraître un peu plus désorganisée que les autres parce qu'elle couvre un sujet large et divers. Le concept basique est qu'on aimerait maintenant faire quelque chose avec les valeurs qu'on avait, alors, juste sélectionnées et renvoyées sans distinction. \"Expressions\" est le moyen d'effectuer ces opérations sur des valeurs. Il existe de nombreux types d’expressions que vous pouvez utiliser, mais commençons par les notions de base : les types de données. Types de données Chaque valeur dans SPARQL a un type qui vous informe de la nature de la valeur et de ce que vous pouvez en faire. Les types les plus importants sont : item, comme wd:Q42 pour Douglas Adams (Q42). boolean (booléen) avec deux valeurs possibles true et false. Les booléens ne sont pas stockés dans les déclarations, mais beaucoup d'expressions renvoient un booléen comme 2 < 3 (qui renvoie true) ou \"a\" = \"b\" (false). string, une chaîne de caractères. Les chaînes sont écrites entre des guillemets doubles \". texte monolingue, une chaîne de caractères avec un tag informant la langue. Dans un littéral, vous pouvez ajouter le tag après la chaîne avec @ comme dans \"Douglas Adams\"@en. nombres entiers (1) ou décimaux (1.23). dates. Les littéraux de type date peuvent être écrits en ajoutant ^^xsd:dateTime (le code est sensible à la casse, ^^xsd:datetime ne marchera pas) à une date littérale ISO 8601 : \"2012-10-29T00:00:00Z\"^^xsd:dateTime.  Opérateurs Les opérateurs mathématiques habituels sont disponibles : +, -, *, / pour additionner, soustraire, multiplier ou diviser des nombres, <, >, =, <=, >= pour les comparer. L'opérateur d'inégalité ≠ s'écrit !=. Les comparaisons sont définies aussi sur d'autres types ; par exemple, \"abc\" < \"abd\" est vrai (comparaison lexicographique), de même que \"2016-01-01\"^^xsd:dateTime > \"2015-12-31\"^^xsd:dateTime et wd:Q4653 != wd:Q283111. Les conditions booléennes de type ET peuvent être combinées avec && (le ET logique: a && b est vrai si a et b sont vrais) et celles de type OU avec || (le OU logique: a || b est vrai si soit l'un soit l'autre soit les deux a et b sont vrai(s)). FILTER Info Pour une alternative à FILTER, parfois plus rapide, vous pouvez utiliser MINUS, voir cet exemple.FILTER(condition). est une clause qu'on peut insérer dans une requête SPARQL pour filtrer les résultats. Dans les parenthèses, on peut mettre n'importe quelle expression booléenne, et seuls les résultats où l'expression renvoie true sont utilisés.Par exemple, pour obtenir une liste de tous les êtres humains nés en 2015, nous cherchons d'abord tous les êtres humains avec leur date de naissance (« dob » : date of birthday). SELECT ?person ?personLabel ?dob
WHERE
{
  ?person wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } 
} - puis nous filtrons pour obtenir seulement les résultats où l'année de naissance est 2015. Il y a deux manières de faire : extraire l'année de la date avec la fonction YEAR et tester qu'elle vaut 2015 - FILTER(YEAR(?dob) = 2015). ou bien vérifier que la date est comprise entre le 1er janvier 2015 (inclus) et le 1er janvier 2016 (exclus) : FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime). Je dirais que la première manière est plus simple, mais il se trouve que la seconde est beaucoup plus rapide, donc nous allons l'utiliser : SELECT ?personne ?personneLabel ?dob
WHERE
{
  ?personne wdt:P31 wd:Q5;
          wdt:P569 ?dob.
  FILTER(\"2015-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"2016-01-01\"^^xsd:dateTime).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 
}
 Try it! FILTER est aussi applicable aux libellés (labels). Le service de libellés est très utile pour afficher le libellé d'une variable. Mais si on veut en faire quelque chose, par exemple vérifier s'il commence par « Mr. », vous verrez que ça ne fonctionne pas : SELECT ?human ?humanLabel
WHERE
{
  ?human wdt:P31 wd:Q15632617.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }
  #This FILTER does not work!
  FILTER(STRSTARTS(?humanLabel, \"Mr. \")).
}
 Try it! Cette requête trouve toutes les instances de fictional human (Q15632617) et teste si leur libellé commence par « Mr. » (STRSTARTS est l'abréviation de « string starts (with) » ; il existe aussi STRENDS - finit par - et CONTAINS - contient -). La raison pour laquelle cela ne fonctionne pas vient du fait que le service de libellés ajoute ses variables très tard pendant l'évaluation de la requête, et au moment où nous essayons de filtrer ?humanLabel, le service de libellés n'a pas encore créé cette variable.Heureusement, le service de libellés n'est pas l'unique moyen d'obtenir le libellé d'un item. Les libellés sont aussi stockés comme des triplets normaux, en utilisant la propriété rdfs:label. Bien sûr, cela est vrai pour tous les libellés, pas seulement ceux en anglais ; si nous voulons des libellés en anglais, nous devrons filtrer le langage de l'étiquette : FILTER(LANG(?label) = \"en\"). La fonction LANG renvoie la langue d'une chaîne de caractères monolingue, et ici nous sélectionnons les libellés qui sont en anglais. La requête complète est : SELECT ?humain ?humainLabel
WHERE
{
  ?humain wdt:P31 wd:Q15632617;
         rdfs:label ?humainLabel.
  FILTER(LANG(?humainLabel) = \"[AUTO_LANGUAGE]\").
  FILTER(STRSTARTS(?humainLabel, \"Mr. \")).
}
 Try it! Nous obtenons les libellés avec le triplet ?humain rdfs:label ?humainLabel, nous les restreignons aux libellés en anglais puis nous vérifions s'ils commencent par “Mr. \".On peut aussi utiliser FILTER avec une expression régulière. Exemple : SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"[\\\\.q]\")) 
}
 Try it! Si la contrainte de format pour un identifiant est [A-Za-z][-.0-9A-Za-z]{1,}: SELECT ?item ?itemLabel ?bblid
WHERE {  
    ?item wdt:P2580 ?bblid .
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" }  
    FILTER(!REGEX(STR(?bblid), \"^[A-Za-z][-.0-9A-Za-z]{1,}$\"))
}
 Try it! Il est possible d'exclure des éléments spécifiques comme ceci : FILTER ( ?item not in ( wd:Q4115189,wd:Q13406268,wd:Q15397819 ) ) Il est possible de filtrer pour n'obtenir que des propriétés non renseignées : FILTER ( NOT EXISTS { ?item  wdt:P21 [] } )  BIND, BOUND, IF Ces trois fonctionnalités sont souvent utilisées ensemble, par conséquent nous allons d’abord expliquer les trois, avant d’en montrer des exemples.Une clause BIND(expression AS ?variable). s’utilise pour assigner à une variable la valeur d’une expression (en général une nouvelle variable mais il est également possible de changer la valeur des variables existantes).BOUND(?variable) teste si une variable a effectivement une valeur assignée ou si elle est indéfinie. (la valeur de retour true (elle a une valeur) ou faux (elle n’est pas définie)). C’est principalement utile pour des variables introduites dans une clause OPTIONAL.IF(condition, expressionAlors, expressionSinon) s’évalue en expressionAlors si condition est vraie, et on expressionSinon si condition est fausse. Par exemple, IF(true, \"oui\", \"non\") s’évalue en oui, et IF(false, \"super\", \"terrible\") s’évalue en \"terrible\".BIND peut être utilisé pour assigner le résultat d’un calcul à une nouvelle variable. Il est possible de s’en servir comme résultat intermédiaire d’un calcul plus complexe ou directement dans le résultat de la requête. Par exemple, pour calculer l’âge des victimes de condamnation à mort : SELECT ?personne ?personneLabel ?age
WHERE
{
  ?personne wdt:P31 wd:Q5;
          wdt:P569 ?ne;
          wdt:P570 ?Mort;
          wdt:P1196 wd:Q8454.
  BIND(?Mort - ?ne AS ?ageEnJours).
  BIND(?ageEnJours/365.2425 AS ?ageEnAnnees).
  BIND(FLOOR(?ageEnAnnees) AS ?age).
  # ou, avec une seule expression
  #BIND(FLOOR((?Mort - ?ne)/365.2425) AS ?age).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! BIND peut également être utile pour assigner des valeurs particulières (constantes) à des variables pour aider à la clarté de la requête. Par exemple, dans une requête qui trouve toutes les femmes prêtres : SELECT ?femme ?femmeLabel
WHERE
{
  ?femme wdt:P31 wd:Q5;
         wdt:P21 wd:Q6581072;
         wdt:P106 wd:Q42603.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! peut être réécrit comme ceci: SELECT ?femme ?femmeLabel
WHERE
{
  BIND(wdt:P31 AS ?nature).
  BIND(wd:Q5 AS ?humain).
  BIND(wdt:P21 AS ?sexeOuGenre).
  BIND(wd:Q6581072 AS ?féminin).
  BIND(wdt:P106 AS ?occupation).
  BIND(wd:Q42603 AS ?prêtre).
  ?femme ?nature ?humain;
         ?sexeOuGenre ?féminin;
         ?occupation ?prêtre.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Le cœur de la requête, de ?femme à ?prêtre. est probablement raisonnablement lisible. En revanche le large bloc BIND en face de ce cœur est sans doute assez dérangeant, donc cette technique s’utilise avec modération. (Dans l’interface utilisateur WDQS, il est possible de passer la souris sur n’importe quel terme comme wd:Q123 ou wdt:P123 pour voir les libellés et descriptions des entités correspondantes, ce qui permet de se passer dans une certaine mesure de cette astuce.)Les expressions IF s’utilisent souvent avec des conditions construites avec BOUND. Supposons par exemple que nous ayons une requête d’humains, et qu’au lieu d’afficher leur libellé, nous souhaitions afficher leur pseudonym (P742) si leurs entités en sont pourvues, et le libellé si nous ne leur connaissons pas de pseudonyme. Nous pouvons alors chercher leur pseudonyme dans une clause « OPTIONAL » (car nous ne voulons pas les rejeter des résultats s'ils n’ont pas de pseudo), puis le code BIND(IF(BOUND(… pour sélectionner soit leur pseudonyme soit le libellé. SELECT ?writer ?label
WHERE
{
  # French writer born in the second half of the 18th century
  ?writer wdt:P31 wd:Q5;
          wdt:P27 wd:Q142;
          wdt:P106 wd:Q36180;
          wdt:P569 ?dob.
  FILTER(\"1751-01-01\"^^xsd:dateTime <= ?dob && ?dob < \"1801-01-01\"^^xsd:dateTime).
  # get the English label
  ?writer rdfs:label ?writerLabel.
  FILTER(LANG(?writerLabel) = \"en\").
  # get the pseudonym, if it exists
  OPTIONAL { ?writer wdt:P742 ?pseudonym. }
  # bind the pseudonym, or if it doesn’t exist the English label, as ?label
  BIND(IF(BOUND(?pseudonym),?pseudonym,?writerLabel) AS ?label).
}
 Try it! D’autres propriétés peuvent s’utiliser sur le même motif, comme nickname (P1449), posthumous name (P1786) et taxon common name (P1843) — dans toutes les situations où il est possible de se rabattre sur une alternative sensée en cas de défaut d’information ou d’information préférée à une autre, comme les dénominations.On peut aussi combiner BOUND et FILTER pour s’assurer qu’au minimum un des blocs OPTIONAL est satisfait. Par exemple, récupérons tous les astronautes ayant fait le voyage vers la Lune, ainsi que les membres de Apollo 13 (Q182252) (ils ne sont pas passés loin, pas vrai ?) Cette restriction ne peut s’exprimer comme un unique chemin de propriété, nous avons donc besoin d’une clause OPTIONAL pour les « membres d’une mission vers la Lune » et d’une autre pour les « membres d’Apollo 13 ». Mais nous voulons sélectionner uniquement ceux pour lesquels l’une de ces deux conditions est vraie. SELECT ?astronaute ?astronauteLabel
WHERE
{
  ?astronaute wdt:P31 wd:Q5;
             wdt:P106 wd:Q11631.
  OPTIONAL {
    ?astronaute wdt:P450 ?mission.
    ?mission wdt:P31 wd:Q495307.
  }
  OPTIONAL {
    ?astronaute wdt:P450 wd:Q182252.
    BIND(wd:Q182252 AS ?mission).
  }
  FILTER(BOUND(?mission)).
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! COALESCE La fonction COALESCE est utile comme abbréviation du motif BIND(IF(BOUND(?x), ?x, ?y) AS ?z). pour les solutions de repli fallbacks mentionnées ci-dessus : elle prend un certain nombre d’expressions et retourne la valeur de la première qui s’évalue sans erreur. En exemple, les replis pour l’exemple « pseudonyme » BIND(IF(BOUND(?pseudonyme),?pseudonyme,?ecrivainLabel) AS ?libelle). peut être écrit plus concisément avec BIND(COALESCE(?pseudonyme, ?ecrivainLabel) AS ?libelle). il est aussi facile d’ajouter un autre libellé de repli au cas où ?ecrivainLabel ne serait pas défini non plus : BIND(COALESCE(?pseudonyme, ?ecrivainLabel, \"<no label>\") AS ?libelle).  Groupement Jusqu’à présent toutes les requêtes que nous avons vues trouvaient l’ensemble des éléments qui satisfont des conditions ; dans certaines nous avons également ajouté des déclarations supplémentaires de ces éléments (tableaux avec leur matériau, les livres d’Arthur Conan Doyle avec leur titre et leur illustrateur).Mais il arrive souvent que l'on ne veuille pas une longue liste avec tous les résultats. À la place, nous pouvons poser des questions ainsi: Combien de tableaux sont peints sur toile / sur peuplier / etc. ? Quelle est la plus grande population parmi celle des différentes villes, pour chacun des pays ? Quel est le nombre total d’armes à feu produites par chaque fabricant ? Qui publie en moyenne les plus longs livres ?  Populations des villes Regardons maintenant la seconde question. Il est relativement simple d’écrire une requête qui liste toutes les villes avec leur population et leur pays, triées par pays : SELECT ?Pays ?Ville ?Population
WHERE
{
  ?Ville wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?Pays;
        wdt:P1082 ?Population.
}
ORDER BY ?Pays
 Try it! (Note: cette requête retourne \"beaucoup\" de résultats, ce qui peut poser des problèmes à votre navigateur. Vous voudrez peut-être ajouter une contrainte LIMIT.)Comme nous ordonnons les résultats par pays, toutes les villes d’un pays forment un bloc contigu dans les résultats. Pour trouver la plus grande population à l’intérieur de ce bloc, nous allons considérer ce bloc comme un « groupe » et agréger toutes les valeurs de population de ce groupe en une seule valeur : le maximum. C’est fait grâce à une clause GROUP BY au-dessous du bloc WHERE, et d’une fonction d’agrégation (MAX) dans la clause SELECT. SELECT ?pays (MAX(?population) AS ?PopulationMax)
WHERE
{
  ?ville wdt:P31/wdt:P279* wd:Q515;
        wdt:P17 ?pays;
        wdt:P1082 ?population.
}
GROUP BY ?pays
 Try it! Nous avons remplacé ORDER BY par GROUP BY. Ça a pour effet que tous les résultats avec la même valeur de ?pays sont regroupés dans un seul résultat. Nous devons en conséquence également changer la clause SELECT. Si nous avions conservé l’ancienne clause SELECT ?pays ?ville ?population, quelle ville et quelle population seraient choisies ? Rappelez vous que nous souhaitons regrouper plusieurs résultats en un unique résultat agrégé (on dira agrégat dans la suite), nous avons donc plusieurs valeurs différentes possibles dans un résultat regroupé ; tous les résultats regroupés ont le même pays, il n’y a donc pas de choix pour la valeur ?pays, mais pour ?ville et ?population, nous devons spécifier un choix de valeur. C’est le rôle des fonctions d’agrégation. Dans ce cas, nous avons utilisé MAX: de toutes les valeurs de ?population des résultats que nous regroupons, nous choisissons la valeur maximale pour le résultat de l’agrégat. (Nous devons également nommer la valeur calculée à partir des valeurs agrégées grâce à la construction AS, mais c’est un détail.)C’est une technique générale d’écriture de requêtes agrégées: d’abord écrire des requêtes non agrégées qui retournent les résultats que vous souhaitez, puis rajouter une clause GROUP BY pour désigner les variables de groupe, et ajouter dans la clause SELECT une fonction d’agrégation pour chacune des autres variables présentes. Matériaux de peinture Essayons ça sur un autre sujet : Combien de tableaux ont été peints en utilisant les différents matériaux ? D’abord, écrivons une requête pour trouver tous les tableaux et les matériaux desquels ils sont faits. (En faisant attention de ne choisir que les déclarations avec un qualificateur applies to part (P518)painting support (Q861259) .) SELECT ?matériau ?tableau
WHERE
{
  ?tableau wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?matériau; pq:P518 wd:Q861259 ].
}
 Try it! Ensuite, ajoutons une clause GROUP BY sur le ?matériau, puis une fonction d'agrégation sur l’autre variable choisie (?tableau). Dans ce cas, nous sommes intéressés par le nombre de tableaux ; la fonction nécessaire pour ceci est COUNT. SELECT ?matériau (COUNT(?peinture) AS ?décompte)
WHERE
{
  ?peinture wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?matériau; pq:P518 wd:Q861259 ].
}
GROUP BY ?matériau
 Try it! Ceci nous pose un problème car nous n'avons pas de label pour les matériaux, donc les résultats sont un peu difficiles à interpréter. Si nous ajoutons juste la variable de label, nous allons avoir une erreur: SELECT ?matériau ?matériauLabel (COUNT(?peinture) AS ?décompte)
WHERE
{
  ?peinture wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?matériau; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?matériau
 Try it! Bad aggregate “Bad aggregate”(mauvais agrégat) est un message d’erreur que vous rencontrerez probablement beaucoup en travaillant sur ce type de requêtes. Il signifie qu’une des variables dans la clause SELECT devrait être agrégée (au moyen d'une fonction d’agrégation) mais ne l'est pas, ou à l’inverse qu'elle est agrégée mais ne le devrait pas. Dans notre cas, WDQS pense qu’il pourrait y avoir plusieurs ?matériauLabels par ?matériau (même si nous savons que ça ne peut pas arriver), et se plaint donc que vous avez utilisé cette variable en dehors d’une fonction d’agrégation.Une solution est de regrouper à partir de plusieurs variables. Si vous listez plusieurs variables dans la clause GROUP BY, il y a un résultat pour chaque combinaison de valeurs de ces variables, et vous pouvez utiliser toutes ces variables dans une fonction d’agrégation. Dans notre cas, nous allons agréger en utilisant à la fois ?matériau et ?matériauLabel. SELECT ?matériau ?matériauLabel (COUNT(?peinture) AS ?décompte)
WHERE
{
  ?peinture wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?matériau; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?matériau ?matériauLabel
 Try it! Nous avons presque terminé la requête — une dernière amélioration en touche finale : nous souhaiterions voir les matériaux les plus utilisés en premier. Heureusement, nous pouvons utiliser les nouvelles variables agrégées de la clause SELECT (ici, ?décompte) dans une clause ORDER BY, c’est donc très simple : SELECT ?matériau ?matériauLabel (COUNT(?peinture) AS ?décompte)
WHERE
{
  ?peinture wdt:P31/wdt:P279* wd:Q3305213;
            p:P186 [ ps:P186 ?matériau; pq:P518 wd:Q861259 ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?matériau ?matériauLabel
ORDER BY DESC(?décompte)
 Try it! Écrivez également les autres requêtes en guise d’exercice. Fusils par fabricant Quel est le nombre total d'armes produites par chaque fabricant? Piste Les éléments et propriétés pertinents sont firearm (Q12796), manufacturer (P176), total produced (P1092). Exemple de solution SELECT ?fabricant ?fabricantLabel (SUM(?quantitéProduite) AS ?totalProduit)
WHERE
{
  ?modèle wdt:P31?/wdt:P279* wd:Q12796;
         wdt:P176 ?fabricant;
         wdt:P1092 ?quantitéProduite.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?fabricant ?fabricantLabel
ORDER BY DESC(?quantitéProduite)
 Try it!  Editeurs par nombre de pagesQuel est le nombre de pages moyen des livres des différents éditeurs ? (fonction: AVG, de l'anglaisaverage, moyenne).Piste Les éléments et propriétés pertinents sont : publisher (P123), number of pages (P1104). Exemple de solution SELECT ?éditeur ?éditeurLabel (AVG(?pages) AS ?moyennePages)
WHERE
{
  ?livre wdt:P123 ?éditeur;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?éditeur ?éditeurLabel
ORDER BY DESC(?moyennePages)
 Try it! HAVING Un petit addendum à la requête précédente — si vous regardez les résultats, vous remarquerez peut-être que le premier résultat a une valeur déraisonnablement grande, plus de 10 fois plus grande que pour le deuxième résultat. Une petite enquête révèle que c’est parce que cet éditeur a publié un unique livre dont l’élément a une déclaration number of pages (P1104), Grande dizionario della lingua italiana (Q3775610), ce qui biaise quelque peu les résultats. Pour supprimer ce style de valeurs aberrantes, nous pouvons tenter de sélectionner les éditeurs qui ont publié au moins deux livres munis de déclarations number of pages (P1104) sur Wikidata.Comment on fait ça ? En temps normal, nous filtrons les résultats à l’aide d’une clause FILTER, mais dans ce cas nous souhaitons filtrer en fonction d’une valeur agrégée (le nombre de livres), et pas d’un résultat unique. Nous pouvons le faire grâce à une clause HAVING, qui doit être placée juste après la clause GROUP BY qui lui correspond, et qui, comme FILTER, contient une expression (ici, une expression d'agrégation) : SELECT ?éditeur ?éditeurLabel (AVG(?pages) AS ?moyennePages)
WHERE
{
  ?livre wdt:P123 ?éditeur;
        wdt:P1104 ?pages.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
GROUP BY ?éditeur ?éditeurLabel
HAVING(COUNT(?livre) > 1)
ORDER BY DESC(?moyennePages)
 Try it!  Sommaire des fonctions d’agrégation Voici un court sommaire des fonctions d’agrégation disponibles : COUNT: le nombre de résultats agrégés. Vous pouvez également écrire COUNT(*) pour simplifier le décompte de tous les résultats. SUM, AVG: la somme et la moyenne, respectivement, de tous les résultats agrégés. Si certains résultats ne sont pas des nombres, vous obtiendrez des résultats étranges. MIN, MAX: respectivement les valeurs minimales et maximales de tous les résultats agrégés. Ces fonctions fonctionnent avec tous les types de données ; les nombres sont triés numériquement et les chaînes et autres types lexicographiquement. SAMPLE: un élément quelquonque. Parfois utile si vous êtes certain qu’il y a un unique résultat dans l’agrégat, ou que vous n’avez pas de préférence sur l’élément à choisir. GROUP_CONCAT: concatène tous les résultats de l’agrégation. Rarement utile, sinon lorsqu'on veut s'en tenir à un unique résultat pour chaque article, tout en voulant y inclure les différentes valeurs de l'une de ses propriétés (par exemple les différentes occupations d'une personne). Cela se fait en les rassemblant et concaténant dans une seule variable, de sorte qu'elles apparaîtront sur une seule ligne de résultats plutôt que sur plusieurs autrement. Si vous êtes curieux, vous pouvez en trouver la description dans la spécification SPARQL specification. Il est de plus possible d’ajouter un modificateur DISTINCT pour n’importe laquelle de ces fonctions d’agrégation afin d'éliminer les résultats dupliqués. Par exemple, si nous avons deux résultats qui ont tous les deux la même valeur de ?var dans un agrégat, alors COUNT(?var) retournera 2 mais COUNT(DISTINCT ?var) retournera plutôt 1. Il est souvent nécessaire d’utiliser DISTINCT quand la requête peut retourner le même élément plusieurs fois — ça peut arriver par exemple lorsque vous utilisez ?item wdt:P31/wdt:P279* ?class et qu’il y a plusieurs chemins de ?item vers ?class: vous aurez alors un résultat pour chacun de ces chemins, y compris si les valeurs sont identiques. Dans le cas où vous n’agrégez rien, il est possible d’éliminer ces résultats en doublons en démarrant la requête par SELECT DISTINCT à la place de simplement SELECT. wikibase:Label et agrégations Une requête telle que la suivante, qui recherche toutes les personnes académiques avec plus de deux pays de citoyenneté dans Wikidata, n'affiche pas les noms de ces pays dans la colonne ?citizenships : select ?person ?personLabel (group_concat(?citizenshipLabel;separator=\"/\") as ?citizenships) {
  # find all academics
  ?person wdt:P106 wd:Q3400985 ;   
          wdt:P27  ?citizenship .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} group by ?person ?personLabel having (count(?citizenship) > 2)
 Try it! Pour afficher la colonne ?citizenships, nommez explicitement le ?personLabel et ?citizenshipLabel dans l'appel au service wikibase:label, de la manière suivante: """@en;
  dcterms:isPartOf <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/lb>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/he>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/nl>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/szl>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/en-gb>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/zh>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/et>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/pt-br>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/hy>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/tr>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/id>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/da>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ar>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ja>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/es>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/it>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ca>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/sv>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/de>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ru>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/uk>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/pl>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/en>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/fr>;
  dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/>;
  sh:prefixes _:wikidata_prefixes, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-wikidata_prefixes,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-DD73A06A105F32C0EAE0AEB6FBA0A987, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-13A5828B94BB8AFB6BD8E089A39905DC,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-BB31DC1484493746D3E80A2B378167BF, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-1E1D7371B3C8974196BDEA74DD04D521,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-5E9058F9D391543F85C1F517536310B0, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-02E57391C9F8C1F5175C4695CCEC9530,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-DEA7DE3C7BBCAB80CF0844B02A0398EB, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-E36BE1C9AC1134989D31EE45FC899A1E,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-ADB7367E7C28F7B6E700917477488D6E, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-02146FBFB6A2ADFC5DFD92E297590653,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-38BF5451C468B9DEFA2F4720B52A4D59, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-639FCBB2B437B4680E0D0D7711CCD623,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-D4DCFBAF184EE615E3FB466F8A22B3A1, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-46C5A2D0F5AC0824262ABC63EF8259D6,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-2500768390AAC8F67CAD1229017DACE3, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-B9AF73FA58693DED76D2B97B8C282C57,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-716FD7D1FA3019F5B67340C8CD8FA2C6, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-2E50CCD616F3F3E37C0782BFF90D1467,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-8B78300F1743453A99241AA1B600386D, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-F9CB8C9C49663A85AB7749C356EECE0B,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-C9F7EC394AB06CE7AE22B67FFF1D2650, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-BECA47FB7FA4E6B00D1E7FE269088157,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-B65C003801AD228A25EA1F990F53CBF0, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126617-E5F58C716BB13D083E318FD9AEB79BA3;
  schema:target <https://query.wikidata.org/sparql/> .

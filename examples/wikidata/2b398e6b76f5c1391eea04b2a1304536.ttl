@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix schema: <https://schema.org/> .

<https://www.wikidata.org/#query-2b398e6b76f5c1391eea04b2a1304536> a sh:SPARQLExecutable;
  rdfs:comment """@Bouzinac: There is no modulo operator in SPARQL, but it is easy to calculate with normal division and the FLOOR (largest integer less or equal to the argument) or CEIL (smallest integer higher or equal to the argumnet) functions. In your code you could add e.g. BIND (?valeur/10 AS ?fraction)
  FILTER (?fraction = FLOOR(?fraction)) or FILTER (FLOOR(?valeur/10)*10 = ?valeur) This will work fine with all normal integers but some of the numbers in the query are too big to make accurate arithmetic calculations. To avoid calculations you can use that in a numeral system (Q122653) with radix (Q843684) b (10 in this case) the last digit of any number n is n modulo b to convert the number to a string and look at the last digit: """@en;
  dcterms:isPartOf <https://www.wikidata.org//wiki/Wikidata:Request_a_query/Archive/2020/04>;
  dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/>;
  sh:prefixes _:wikidata_prefixes;
  schema:target <https://query.wikidata.org/sparql/> .

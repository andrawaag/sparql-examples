@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix schema: <https://schema.org/> .

<https://www.wikidata.org/#query-b1adda7230356bbd238716bfb344d2c3> a sh:SPARQLExecutable;
  rdfs:comment """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, de Wikidata Query Service, is een krachtig hulpmiddel om inzicht te krijgen in de inhoud van Wikidata. Deze handleiding zal u leren hoe u het moet gebruiken. Zie ook de interactive tutorial gemaakt door Wikimedia Israël.Voordat u uw eigen SPARQL-query schrijft, kijk dan naar {{Item documentation}} of een andere generische SPARQL-query sjabloon en kijk of uw query al is toegevoegd. Contents 1 Voordat we beginnen 2 SPARQL basis 3 Onze eerste query 3.1 Automatisch aanvullen 4 Geavanceerde tripel patronen 5 Instanties en classes 5.1 Eigenschapspaden 6 Kwalificaties 7 ORDER en LIMIT 7.1 Oefening 7.1.1 Arthur Conan Doyle boeken 7.1.2 Chemische elementen 7.1.3 Rivers die in de Mississippi stromen 7.1.4 Rivers die in de Mississippi stromen II 8 OPTIONAL 9 Expressies, FILTER en BIND 9.1 Gegevenstypes 9.2 Operatoren 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Groeperen 10.1 Bevolking van steden 10.2 Schildersmaterialen 10.3 Wapens per fabrikant 10.4 Uitgevers per aantal pagina's 10.4.1 HAVING 10.5 Samenvatting van aggregatie functies 10.6 wikibase:Label en aggregaties 11 VALUES 12 Label in meerdere talen 13 En verder... 14 Zie ook Voordat we beginnen Hoewel deze tutorial misschien heel lang en intimiderend lijkt, laat u daar niet door afschrikken. Alleen het leren van de SPARQL-basis zal u ver op weg helpen - zelfs als u na #Onze eerste query stopt te lezen, zult u al meer begrijpen om veel interessante queries te bouwen. Elk deel van deze tutorial zal u in staat stellen die query nog krachtiger te maken.Als u nog nooit van Wikidata, SPARQL of WDQS hebt gehoord, is hier een korte uitleg van die termen: Wikidata is een kennisdatabase. Het bevat miljoenen verklaringen, zoals \"de hoofdstad van Canada is Ottawa\", of \"de Mona Lisa is in olieverf op populierenhout geschilderd\", of \"goud smelt op 1.064,18 graden Celsius\". SPARQL is een taal voor het formuleren van een query (of meerdere queries) voor kennisdatabases. Met de juiste database kan een SPARQL-navraag vragen beantwoorden als \"wat is de meest populaire toon in muziek?\" of \"welk personage werd door de meeste acteurs afgebeeld?\" of \"wat is de verdeling van bloedgroepen?\" of welke werken van auteurs zijn dit jaar in het publieke domein gekomen? WDQS, de Wikidata Query Service, brengt de twee samen: u voert een SPARQL-query in, het wordt uitgevoerd op de dataset van Wikidata en laat het resultaat zien.  SPARQL basis Een eenvoudige SPARQL-query kan er zo uitzien: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} De SELECT clause geeft de variabele aan die u wilt opvragen (elke variabele begint met een vraagteken), en de WHERE clause bevat de beperkingen, meestal in de vorm van tripels. Alle informatie in Wikidata (en vergelijkbare kennisdatabases) wordt opgeslagen in de vorm van tripels; Wanneer u de query uitvoert, probeert de queryservice de variabelen in te vullen met werkelijke waarden, zodat de resulterende triples worden weergegeven in de kennisdatabase en één resultaat retourneert voor elke combinatie van variabelen die wordt gevonden.Een tripel kan worden gezien als twee hoekpunten (alias 2 knooppunten, 2 bronnen) verbonden door een rand (een boog, een eigenschap) binnen de gerichte (georiënteerde) eigenschapsmultigraaf die Wikidata vormt. Het kan worden gelezen als een zin (daarom eindigt het met een punt), met een onderwerp, een predicaat en een object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Het resultaat van deze query kan bijvoorbeeld \"lemon\" bevatten. In Wikidata zijn de meeste eigenschappen eigenschappen van het soort \"has\", dus de query kan in plaats daarvan luiden: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} wat leest als “?fruit heeft kleur ‘geel’” (niet “?fruit is de kleur van ‘geel’” – denk hieraan voor eigenschapsparen als “parent”/“child”!)Dat is echter geen goed voorbeeld voor WDQS. Smaak is subjectief, dus Wikidata heeft er geen eigenschap voor. Laten we in plaats daarvan eens nadenken over parent/child-relaties, die meestal ondubbelzinnig zijn. Onze eerste query Stel dat we alle kinderen van de barokcomponist Johann Sebastian Bach willen opnemen. Met pseudo-elementen zoals in de vragen hierboven, hoe zou u die query schrijven?Hopelijk heeft u iets als dit: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (NB: alles na een '#' is een commentaar en wordt door WDQS genegeerd. )
} of dit, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} of dit, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} De eerste twee tripels zeggen dat het kind als ouder/vader Bach moet hebben; de derde zegt dat Bach het kind het kind moet hebben. Laten we nu de tweede nemen.Wat moet er dan nog gedaan worden om dit in een goede WDQS-vraag te veranderen? Op Wikidata worden items en eigenschappen niet geïdentificeerd door door menselijk leesbare namen zoals \"vader\" (eigendom) of \"Bach\" (item). (Met goede reden: \"Johann Sebastian Bach\" is ook de naam van een Duitse schilder, en \"Bach\" kan ook verwijzen naar de achternaam, de Franse commune, de Mercuriuskrater, enz. ) In plaats daarvan wordt aan Wikidata-artikelen en eigenschappen een identificatiecode toegewezen. de identificator voor een item we zoeken naar het item en kopiëren het Q-nummer van het resultaat dat klinkt alsof het het item is dat we zoeken (gebaseerd op de beschrijving, bijvoorbeeld). Om de identificatiecode voor een eigenschap te vinden, doen we hetzelfde, maar zoeken we naar \"P:zoekterm\" in plaats van gewoon \"zoekterm\", wat de zoekopdracht beperkt tot eigenschappen. Dit vertelt ons dat de beroemde componist Johann Sebastian Bach Q1339 is, en de eigenschap om de vader van een item te vinden P:P22 is.En last but not least, we moeten voorvoegsels toevoegen. Voor eenvoudige WDQS-tripels moeten de items worden voorafgegaan metwd:, en de eigenschappen met wdt:. (Maar dit geldt alleen voor vaste waarden - variabelen krijgen geen prefix!)Samengevat wordt onze eerste WDQS-query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Klik op de link Probeer het en vervolgens op Uitvoeren op de WDQS-pagina. Wat krijgt u als antwoord? child wd:Q57225 wd:Q76428 … Dat is teleurstellend. U ziet alleen de identificaties. U kunt op ze klikken om hun Wikidata-pagina te zien (inclusief een voor mensen leesbaar label), maar is er geen betere manier om de resultaten te zien?Die is er natuurlijk wel. (Zijn retorische vragen niet geweldig?) Als u de magische tekst toevoegt SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } in de WHERE-clausule wordt er nog een aantal variabelen opgehaald: voor elke variabele ?foo in de query is er nu ook een variabele ?fooLabel, die het label van het item achter ?foo bevat. Als u dit toevoegt aan de SELECT-clausule, krijgt u het item en zijn label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Probeer die query uit te voeren, u zou nu niet alleen de artikelnummers moeten zien, maar ook de namen van de verschillende kinderen. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Automatisch aanvullen Het stukje code SERVICE ziet er moeilijk uit om te onthouden, toch? En de hele tijd door de zoekfunctie gaan terwijl u de zoekopdracht schrijft, is ook vervelend. Gelukkig biedt WDQS hier een prima oplossing voor: autocompletion. In de query-editor query.wikidata.org kunt u op elk gewenst moment in de query op Ctrl+Space (of Alt+Enter of Ctrl+Alt+Enter) drukken en suggesties voor code krijgen die geschikt kunnen zijn. Selecteer de juiste suggestie met de pijltoetsen omhoog /omlaag en druk op Enter om deze te selecteren.Voorbeeld, in plaats van het uitschrijven van SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }, kunt u ook intikken SERV, vervolgens Ctrl+Space doen, en de eerste suggestie zal het automatisch aanvullen van het label zijn, klaar voor gebruik! Accepteer de suggestie met Enter. (De opmaak zal een beetje anders zijn, maar dat maakt niet uit.)Met automatisch aanvullen kunt u ook zoeken. Als u een van de Wikidata-voorvoegsels, zoals wd: of wdt:, tikt en vervolgens gewoon tekst schrijft, zal Ctrl+Space op Wikidata naar die tekst zoeken en suggesties tonen. wd: zoekopdrachten naar items, wdt: zoekopdracht naar eigenschappen. In plaats van bijvoorbeeld naar items voor Johann Sebastian Bach (Q1339) en father (P22) te zoeken, kunt u gewoon wd:Bach en wd:Bach typen en vervolgens gewoon de juiste suggestie selecteren. (Dit werkt zelfs met spaties in de tekst, bijvoorbeeld wd:Johann Sebastian Bach.) Geavanceerde tripel patronen We hebben nu alle kinderen van Johann Sebastian Bach opgezocht. Meer specifiek: alle items met de vader Johann Sebastian Bach. Maar Bach had twee vrouwen, en dus kunnen die personen verschillende moeders hebben: wat als we alleen de kinderen van Johann Sebastian Bach met zijn eerste vrouw willen zien, Maria Barbara Bach (Q57487)? Probeer die query te schrijven.Heeft u dat gedaan? Oké, dan op de oplossing! De eenvoudigste manier om dit te doen is om een tweede tripel toe te voegen met die beperking: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Er staat dan: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. Dat klinkt een beetje ongemakkelijk, nietwaar? In natuurlijke taal, zouden we dit afkorten tot: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In SPARQL is het zelfs mogelijk om dezelfde afkorting uit te drukken: Als u een tripel eindigt met een puntkomma (;) in plaats van een punt, kunt u een ander predikaat-objectpaar toevoegen. Hiermee kunnen we de bovenstaande query verkorten tot: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Dat geeft dezelfde resultaten, maar minder herhaling in de query.Stel dat we alleen maar belangstelling hebben voor kinderen die ook componisten en pianisten waren. De relevante eigenschappen en items zijn: occupation (P106), composer (Q36834) en pianist (Q486748). Probeer de bovenstaande query bij te werken om deze beperkingen toe te voegen!Dit is mijn oplossing: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Hierbij wordt ; twee keer meer gebruikt om de twee vereiste beroepen toe te voegen. Maar zoals u kunt zien, is er nog steeds een beetje herhaling. Het is alsof we zeggen: Kind heeft het beroep componist en het beroep pianist. We zeggen dan meestal: Kind heeft de beroepen componist en pianist. En SPARQL heeft daar ook een syntaxis voor: net als ; laat u toe een predikate-objectpaar aan een tripel toe te voegen (met hergebruik van het onderwerp), een , laat u toe om een ander object aan een tripel aan te voegen (met hergebruik van onderwerp en predikaat). Hiermee kan de query worden: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! NB: inspringing en andere witruimtes doen er eigenlijk niet toe, ze maken het alleen leesbaarder. U kunt dit ook schrijven als: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # beide beroepen op een regel
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! of, wat minder leesbaar: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # zonder inspringen of nieuwe regels wordt het moeilijker leesbaar of er nu een ';' staat of een ','
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Gelukkig springt de WDQS-editor automatisch in, dus u hoeft u hier meestal geen zorgen over te maken.Oké, laten we hier samenvatten. We hebben gezien dat queries zijn gestructureerd als tekst. Elk tripel over een onderwerp wordt afgesloten met een punt. Meerdere predicaten over hetzelfde onderwerp worden gescheiden door middel van puntkomma's, en meerdere objecten voor hetzelfde onderwerp en predicaat kunnen worden vermeld gescheiden door komma's. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Nu wil ik nog een afkorting introduceren die SPARQL biedt. Dus als u een hypothetisch scenario wilt laten maken...Stel dat we niet geïnteresseerd zijn in Bach's kinderen. Maar wij zijn geïnteresseerd in zijn \"kleinkinderen\". Er is hier één complicatie: een kleinkind kan verwant zijn aan Bach via de moeder of de vader. Dat zijn twee verschillende eigenschappen, wat ongemakkelijk is. Laten we de relatie omdraaien: Wikidata heeft ook een \"kind\" eigenschap, P:P40, die van ouder naar kind wijst en geslachtonafhankelijk is. Kunt u met deze informatie een query schrijven om naar Bachs kleinkinderen te zoeken?Dit is mijn oplossing: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natuurlijke taal is dat: Bach has a child ?child. ?child has a child ?grandChild. Opnieuw stel ik voor dat we deze Engelse zin verkorten, en dan wil ik u laten zien hoe SPARQL een vergelijkbare afkorting ondersteunt. Let op dat we eigenlijk niet om het kind geven: we gebruiken de variabele niet, behalve om te praten over het kleinkind. We kunnen de zin verkorten tot: Bach has as child someone who has a child ?grandChild. In plaats van te zeggen wie Bachs kind is, zeggen we gewoon \"iemand\": het maakt ons niet uit wie het is. Maar we kunnen terug naar hen, omdat we hebben gezegd \"iemand \"wie\": dit begint een relatieve clausule, en binnen die relatieve clausule kunnen we dingen zeggen over \"iemand\" (bijvoorbeeld dat ze \"een kind hebben ?grandChild\"). Op een bepaalde manier is \"iemand\" een variabele, maar een speciale die alleen geldig is binnen deze relatieve clausule, en een waar we niet expliciet naar verwijzen (we zeggen \"iemand die dit is en dat doet\", niet \"iemand dat dit is en iemand die dat doet\" - dat zijn twee verschillende \"iemanden\").In SPARQL kan dit worden geschreven als: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! We kunt een paar haakjes ([]) gebruiken in plaats van een variabele, die als een anonieme variabele fungeert. Binnen de koppels kunt u predicaat-objectparen vermelden, net als na een ; na een normale tripel; het impliciete onderwerp is in dit geval de anonieme variabele die de koppels vertegenwoordigen. (NB: ook net als na een ; kunt u meer predicaat-objectparen toevoegen met meer puntkomma's, of meer objecten voor hetzelfde predicaat met komma's.)En dat is het voor drievoudige patronen! Er is meer aan SPARQL, maar omdat we de delen ervan gaan verlaten die sterk vergelijkbaar zijn met natuurlijke taal, wil ik die relatie nog een keer samenvatten: natuurlijke taal voorbeeld SPARQL voorbeeld zin Juliet loves Romeo. punt juliet loves romeo. conjunctie (clause) Romeo loves Juliet and kills himself. puntkomma romeo loves juliet; kills romeo. conjunctie (zelfstandig naamwoord) Romeo kills Tybalt and himself. komma romeo kills tybalt, romeo. relatieve clausule Juliet loves someone who kills Tybalt. haakjes juliet loves [ kills tybalt ].  Instanties en classes Eerder zei ik dat de meeste Wikidata-eigenschappen \"has/heeft\" relaties zijn: \"heeft\" kind, \"heeft\" vader, \"heeft\" baan. Maar soms (in feite, vaak) moet u ook praten over wat iets \"is\". Maar er zijn eigenlijk twee soorten relaties: Gone with the Wind is een film. Een film is een kunstwerk. Gone with the Wind is een bepaalde film. Het heeft een bepaalde regisseur (Victor Fleming), een specifieke duur (238 minuten), een lijst van castleden (Clark Gable, Vivien Leigh,...), enzovoort.Film is een algemeen begrip. Films kunnen regisseurs, (speel)duur en castleden hebben, maar het concept \"film\" als zodanig heeft geen specifieke regisseur, duur of castleden. En hoewel een film een kunstwerk is, en een kunstwerk meestal een schepper heeft, heeft het concept van \"film\" zelf geen schepper - alleen specifieke instancties van dit concept wel.Dit verschil is de reden waarom er in Wikidata twee eigenschappen voor \"is\" zijn: instance of (P31) en subclass of (P279). \"Gone with the Wind\" is een bijzonder voorbeeld van de klasse \"film\"; de klasse \"film\" is een onderklasse (meer specifieke klasse; specialisatie) van de meer algemene klasse \"kunstwerk\".Om u te helpen het verschil te begrijpen, kunt u twee verschillende werkwoorden gebruiken: \"is een\" en \"is een soort van\". Als \"is een soort\" werkt (bijv. een film \"is een type\" kunstwerk), geeft het aan dat u het heeft over een subklasse, een specialisatie van een bredere klasse en moet u subclass of (P279) gebruiken. Als \"is een soort\" niet werkt (bijvoorbeeld de zin \"Gone with the wind \"is een type\" film\" is niet logisch), geeft het aan dat u praat over een bepaalde instantie en moet u instance of (P31) gebruiken.Wat betekent dit voor ons als we SPARQL-queries schrijven? Als we naar \"alle kunstwerken\" willen zoeken, is het niet genoeg om naar alle items te zoeken die direct voorbeelden zijn van \"kunstwerken\": SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instantie van kunstwerk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Terwijl ik dit schrijf (oktober 2016), geeft die query slechts 2.815 resultaten terug - natuurlijk zijn er meer kunstwerken dan dat! Het probleem is dat er hier items zoals \"Gone with the Wind\" missen, wat slechts een voorbeeld is van \"film\", niet van \"kunstwerk\". \"film\" is een onderklasse van \"kunstwerk\", maar we moeten SPARQL vertellen om daar rekening mee te houden bij het zoeken.Een mogelijke oplossing hiervoor is de syntaxis [] waarover we spraken: \"Gone with the Wind\" is een voorbeeld van sommige onderklasse van \"kunstwerk\". (Oefening: probeer die query te schrijven!) Maar dat heeft nog steeds problemen: We nemen niet langer items op die rechtstreeks voorbeelden van kunstwerken zijn. We missen nog steeds items die voorbeelden zijn van een bepaalde subklasse van een \"andere\" subklasse \"kunstwerk\" - bijvoorbeeld, \"Snow White and the Seven Dwarfs\" is een animatiefilm, dat een film is, dat een kunstwerk is. In dit geval moeten we twee \"subklasse van\" verklaringen volgen - maar het kan ook drie, vier, vijf zijn, elk aantal is mogelijk. De oplossing: ?item wdt:P31/wdt:P279* ?class. Dit betekent dat er één \"instantie van\" en dan een aantal \"subclass van\" verklaringen zijn tussen het item en de klasse. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # een instantie van een subklasse kunstwerken
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Ik raad u niet aan om die query te laten draaien. WDQS kan het (maar net aan), maar uw browser kan struikelen als u de resultaten probeert weer te geven omdat er zoveel van hen zijn.)Nu weet u hoe u moet zoeken naar alle kunstwerken, of alle gebouwen, of alle menselijke nederzettingen: de magische bezwering : wdt:P31/wdt:P279*, samen met de juiste klasse. Dit gebruikt wat meer SPARQL-functies die ik nog niet heb uitgelegd, maar eerlijk gezegd is dit bijna het enige relevante gebruik van die functies, dus hoeft u niet te moeten begrijpen hoe het werkt om WDQS effectief te gebruiken. Als u het wilt weten, zal ik het zo uitleggen, maar u kunt ook gewoon het volgende gedeelte overslaan en wdt:P31/wdt:P279* onthouden of kopiëren + plakken vanaf hier wanneer u het nodig hebt. Eigenschapspaden Over het algemeen is het pad dat het bronknooppunt (subject) verbindt met het doelknooppunt (object) door de grafiek niet altijd direct: het kan zijn dat men nul, één of meerdere schakels (segmenten, namelijk padelementen) moet samenvoegen tot een keten; En er kunnen meerdere van dergelijke paden (routes) zijn. Het object van een padelement in de keten wordt het onderwerp van het volgende element. In SPARQL, eigenschapspaden zijn een manier om heel strikt zo'n pad van eigenschappen tussen twee items op te schrijven. Het eenvoudigste pad is slechts een enkele eigenschap, die een gewone tripel vormt: ?item wdt:P31 ?class. U kunt pad-elementen toevoegen met een slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Dit is gelijk aan een van de volgende: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Oefening: schrijf de query \"kleinkinderen van Bach\" met gebruik van deze syntaxis.Een ster (*) na een pad betekent “nul of meer van deze elementen”. """@en;
  dcterms:isPartOf <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/nl>;
  dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/>;
  sh:prefixes _:wikidata_prefixes;
  schema:target <https://query.wikidata.org/sparql/> .

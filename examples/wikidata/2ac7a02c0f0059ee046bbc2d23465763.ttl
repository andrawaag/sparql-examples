@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix schema: <https://schema.org/> .

<https://www.wikidata.org/#query-2ac7a02c0f0059ee046bbc2d23465763> a sh:SPARQLExecutable;
  rdfs:comment """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start [edit] While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics [edit] A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds.A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query [edit] Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instanzen a Klassen 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercice 7.1.1 Arthur Conan Doyle books 7.1.2 Cheemesch Elementer 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, שירות התשאול של ויקינתונים, הוא כלי רב עוצמה להפקת תובנות לפי התוכן של ויקינתונים. המדריך הזה ילמד אותך איך להשתמש בו. ר׳ גם את המדריך האינטראקטיבי של ויקימדיה ישראל.לפני שנכתוב שאילתת SPARQL משלך, כדאי להסתכל על {{Item documentation}} או על כל תבנית שאילתת SPARQL כללית אחרת ולראות אם השאילתה הנחוצה לך כבר שם. Contents 1 לפני שנתחיל 2 יסודות SPARQL 3 השאילתה הראשונה שלנו 4 השלמה אוטומטית 5 תבניות שלישיות מתקדמות 6 מופעים ומחלקות 6.1 נתיבי מאפיינים 7 מבחינים 8 ORDER ו־LIMIT (סידור והגבלה) 8.1 תרגול 8.1.1 ספרים של ארתור קונאן דויל 8.1.2 יסודות כימיים 8.1.3 נחלים שזורמים לתוך נהר המיסיסיפי 8.1.4 נחלים שזורמים לתוך נהר המיסיסיפי 2 9 OPTIONAL (רשות) 10 ביטויים, FILTER ו־BIND (סינון ואיגוד) 10.1 טיפוסי נתונים 10.2 פעולות 10.3 FILTER (סינון) 10.4 BIND,‏ BOUND,‏ IF (איגוד, תיחום, ברירה) 10.5 COALESCE (החזרת הערך התקין מבין האפשרויות) 11 קיבוץ 11.1 אוכלוסיות עירוניות 11.2 חומרי ציור 11.3 אקדחים לפי יצרן 11.4 מוציאים לאור לפי מספר דפים 11.4.1 HAVING (שיש לו) 11.5 סיכום על פונקציות כינוס 11.6 wikibase:Label וכינוסים 12 VALUES (ערכים) 13 Label in multiple languages 14 ועוד הרבה מעבר… 15 ר׳ גם לפני שנתחיל למרות שהמדריך הזה נראה ארוך ומאיים, אין סיבה לחשוש! למידת היסודות של SPARQL תיקח אותך הרחק - אפילו אם בחרת להפסיק לקרוא אחרי #השאילת הראשונה שלנו, כבר תתגבש אצלך הבנה מספקת להרכבת מגוון רחב של שאילתות מעניינות. כל סעיף במדריך הזה יעשיר אותך בכתיבת שאילתות יותר ויותר מדויקות.אם מעולם לא שמעת על ויקינתונים, SPARQL או WQDS לפני כן, הנה הסבר קצר של המונחים האלה: ויקינתונים הוא מסד נתוני ידע. הוא מכיל מיליוני קביעות, כגון „עיר הבירה של קנדה היא אוטווה”, או „ציור המונה ליזה צויר בשמן על עץ צפצפה”, או „נקודת ההתכה של זהב היא 1,064.18 מעלות צלזיוס”. SPARQL היא שפה לביטוי נוסחאי של שאלות (שאילתות) במסדי נתוני ידע. עם מסד הנתונים הנכון, שאילתת SPARQL יכולה לענות על שאלות כמו „מה הטונליות הנפוצה ביותר במוזיקה?” או „איזו דמות שיחקו הכי הרבה שחקנים?” או „מה היא התפלגות סוגי הדם?” או „איזו יצירה של אומנים הונגשה לנחלת הכלל השנה?”. WDQS, שירות התשאול של ויקינתונים, מחבר בין השניים: כותבים שאילתת SPARQL, היא רצה כנגד סדרת הנתונים של ויקינתונים ומציגה לך את התוצאות.  יסודות SPARQL שאלת SPARQL פשוטה נראית ככה: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} הפסוקית SELECT כוללת את המשתנים שנרצה להחזיר (משתנים מתחילים בסימן שאלה), והפסוקית WHERE מכילה מגבלות עליהם, בעיקר בצורת שלישיות. כל המידע בוויקינתונים (ומסדי נתוני ידע דומים) מאוחסן בצורת שלישיות, כשמריצים את השאילתה, שירות התשאול ינסה למלא את המשתנים בערכים בפועל כדי שהשלישיות המתקבלות תופענה במסד נתוני הידע ותוחזרנה תוצאה אחת לכל צירוף משתנים שנמצאו. שלישייה יכולה להיות כמו משפט (לכן היא מסתיימת בנקודה) עם נושא (subject), נשוא (predicate) ועצם (object): SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} התוצאות לשאילתה הזאת יכולות לכלול, למשל, „לימון”. בוויקינתונים, רוב המאפיינים הם מסוג „יש” (has), לכן השאילתה יכולה להיראות כך: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} שיפורש בצורה ‎„?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’”)‎ ובעברית: ל?פרי יש את הצבע ‚צהוב’” (לא “?פרי הוא הצבע של ‚צהוב’”) - חשוב לזכור את זה לטובת צמדי מאפיינים מהצורה „הורה”/„צאצא”!.עם זאת, זאת לא דוגמה טובה ל־WQDS. טעם הוא סובייקטיבי, לכן לוויקינתונים אין מאפיין לזה. במקום, אפשר לחשוב על יחסי הורה/צאצא, שהם בדרך כלל חד־משמעיים. השאילתה הראשונה שלנו נניח שנרצה להציג את כל הצאצאים של המלחין מתקופת הבארוק יוהאן סבסטיאן באך. באמצעות רכיבים מדומים כמו בשאילתות להלן, איך כדאי לכתוב את השאילתה הזאת?אמור היה לצאת משהו כזה: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach (‏(ל)צאצא ''יש הורה'' באך)
  ?child parent Bach.
  # ‫(נא לשים לב: כל מה שנכתב אחרי ‚#’ נחשב הערה ו־WQDS יתעלם ממנו.)
} או ככה, SELECT ?child
WHERE
{
  # child \"has parent\" Bach (‏(ל)צאצא ''יש אבא'' באך) 
  ?child father Bach. 
} או ככה, SELECT ?child
WHERE
{
  #  Bach \"has child\" child (‏(ל)באך ''יש צאצא'' צאצא)
  Bach child ?child.
} שתי השלישיות הראשונות טוענות של־‎?child חייב להיות הורה/אבא בשם Bach, השלישית טוענת של־Bach יש את הצאצא ‎?child. בואו נמשיך עם האפשרות השנייה כרגע.אם כן, מה צריך לעשות כדי להפוך את זה לשאילתה תקפה של WQDS? בוויקינתונים פריטים ומאפיינים לא מזוהים בשם שמובן לבני אדם כמו „אבא” (מאפיין) או „באך” (פריט). (יש לכך סיבה טובה: „יוהאן סבסטיאן באך” הוא גם השם של צייר גרמני, ו„באך” יכול גם להיות שם משפחה, קהילה צרפתית, מכתש בכוכב חמה וכן הלאה). במקום, לפריטים ולמאפיינים בוויקינתונים מוקצים מזהים. כדי למצוא מזהה של פריט עלינו לחפש את הפריט ולהעתיק את מספר ה־Q של התוצאה שנשמעת כמו הפריט שאנחנו מחפשים (לפי התיאור למשל). כדי למצוא מזהה של מאפיין, נעשה את אותו הדבר, אך נחפש אחר „‪P:<ביטוי לחיפוש>‬” במקום רק „ביטוי לחיפוש”, מה שיגביל את החיפוש למאפיינים. כך נוכל למצוא שהמלחין המפורסם יוהאן סבסטיאן באך מיוצג על ידי Q1339, ושהמאפיין להקצאת הורה לפריט הוא P:P22.ואחרון חביב, צריך לכלול קידומות. לשלישיות פשוטות של WQDS, יש להוסיף קידומת wd:‎ לפריטים, ולמאפיינים את wdt:‎. (אך זה חל רק על ערכים קבועים - משתנים לא מקבלים קידומת!)אם נחבר הכול יחד, נגיע לשאילתת ה־WDQS הראויה הראשונה שלנו: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! נלחץ על הקישור „לנסות את זה”, לאחר מכן על „ביצוע שאילתה” בעמוד ה־WDQS. מה יוצא? child wd:Q57225 wd:Q76428 … קצת מאכזב. רואים רק את המזהים. אפשר ללחוץ עליהם כדי לראות את העמוד שלהם בוויקינתונים (כולל תווית שבני אדם יכולים להבין), אבל אין דרך טובה יותר לראות את התוצאות?נו, כמובן שיש! (שאלות רטוריות זה דבר נפלא, לא?) אם כוללים את מלל הקסם """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, de Wikidata Query Service, is een krachtig hulpmiddel om inzicht te krijgen in de inhoud van Wikidata. Deze handleiding zal u leren hoe u het moet gebruiken. Zie ook de interactive tutorial gemaakt door Wikimedia Israël.Voordat u uw eigen SPARQL-query schrijft, kijk dan naar {{Item documentation}} of een andere generische SPARQL-query sjabloon en kijk of uw query al is toegevoegd. Contents 1 Voordat we beginnen 2 SPARQL basis 3 Onze eerste query 3.1 Automatisch aanvullen 4 Geavanceerde tripel patronen 5 Instanties en classes 5.1 Eigenschapspaden 6 Kwalificaties 7 ORDER en LIMIT 7.1 Oefening 7.1.1 Arthur Conan Doyle boeken 7.1.2 Chemische elementen 7.1.3 Rivers die in de Mississippi stromen 7.1.4 Rivers die in de Mississippi stromen II 8 OPTIONAL 9 Expressies, FILTER en BIND 9.1 Gegevenstypes 9.2 Operatoren 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Groeperen 10.1 Bevolking van steden 10.2 Schildersmaterialen 10.3 Wapens per fabrikant 10.4 Uitgevers per aantal pagina's 10.4.1 HAVING 10.5 Samenvatting van aggregatie functies 10.6 wikibase:Label en aggregaties 11 VALUES 12 Label in meerdere talen 13 En verder... 14 Zie ook Voordat we beginnen Hoewel deze tutorial misschien heel lang en intimiderend lijkt, laat u daar niet door afschrikken. Alleen het leren van de SPARQL-basis zal u ver op weg helpen - zelfs als u na #Onze eerste query stopt te lezen, zult u al meer begrijpen om veel interessante queries te bouwen. Elk deel van deze tutorial zal u in staat stellen die query nog krachtiger te maken.Als u nog nooit van Wikidata, SPARQL of WDQS hebt gehoord, is hier een korte uitleg van die termen: Wikidata is een kennisdatabase. Het bevat miljoenen verklaringen, zoals \"de hoofdstad van Canada is Ottawa\", of \"de Mona Lisa is in olieverf op populierenhout geschilderd\", of \"goud smelt op 1.064,18 graden Celsius\". SPARQL is een taal voor het formuleren van een query (of meerdere queries) voor kennisdatabases. Met de juiste database kan een SPARQL-navraag vragen beantwoorden als \"wat is de meest populaire toon in muziek?\" of \"welk personage werd door de meeste acteurs afgebeeld?\" of \"wat is de verdeling van bloedgroepen?\" of welke werken van auteurs zijn dit jaar in het publieke domein gekomen? WDQS, de Wikidata Query Service, brengt de twee samen: u voert een SPARQL-query in, het wordt uitgevoerd op de dataset van Wikidata en laat het resultaat zien.  SPARQL basis Een eenvoudige SPARQL-query kan er zo uitzien: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} De SELECT clause geeft de variabele aan die u wilt opvragen (elke variabele begint met een vraagteken), en de WHERE clause bevat de beperkingen, meestal in de vorm van tripels. Alle informatie in Wikidata (en vergelijkbare kennisdatabases) wordt opgeslagen in de vorm van tripels; Wanneer u de query uitvoert, probeert de queryservice de variabelen in te vullen met werkelijke waarden, zodat de resulterende triples worden weergegeven in de kennisdatabase en één resultaat retourneert voor elke combinatie van variabelen die wordt gevonden.Een tripel kan worden gezien als twee hoekpunten (alias 2 knooppunten, 2 bronnen) verbonden door een rand (een boog, een eigenschap) binnen de gerichte (georiënteerde) eigenschapsmultigraaf die Wikidata vormt. Het kan worden gelezen als een zin (daarom eindigt het met een punt), met een onderwerp, een predicaat en een object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Het resultaat van deze query kan bijvoorbeeld \"lemon\" bevatten. In Wikidata zijn de meeste eigenschappen eigenschappen van het soort \"has\", dus de query kan in plaats daarvan luiden: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} wat leest als “?fruit heeft kleur ‘geel’” (niet “?fruit is de kleur van ‘geel’” – denk hieraan voor eigenschapsparen als “parent”/“child”!)Dat is echter geen goed voorbeeld voor WDQS. Smaak is subjectief, dus Wikidata heeft er geen eigenschap voor. Laten we in plaats daarvan eens nadenken over parent/child-relaties, die meestal ondubbelzinnig zijn. Onze eerste query Stel dat we alle kinderen van de barokcomponist Johann Sebastian Bach willen opnemen. Met pseudo-elementen zoals in de vragen hierboven, hoe zou u die query schrijven?Hopelijk heeft u iets als dit: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (NB: alles na een '#' is een commentaar en wordt door WDQS genegeerd. )
} of dit, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} of dit, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} De eerste twee tripels zeggen dat het kind als ouder/vader Bach moet hebben; de derde zegt dat Bach het kind het kind moet hebben. Laten we nu de tweede nemen.Wat moet er dan nog gedaan worden om dit in een goede WDQS-vraag te veranderen? Op Wikidata worden items en eigenschappen niet geïdentificeerd door door menselijk leesbare namen zoals \"vader\" (eigendom) of \"Bach\" (item). (Met goede reden: \"Johann Sebastian Bach\" is ook de naam van een Duitse schilder, en \"Bach\" kan ook verwijzen naar de achternaam, de Franse commune, de Mercuriuskrater, enz. ) In plaats daarvan wordt aan Wikidata-artikelen en eigenschappen een identificatiecode toegewezen. de identificator voor een item we zoeken naar het item en kopiëren het Q-nummer van het resultaat dat klinkt alsof het het item is dat we zoeken (gebaseerd op de beschrijving, bijvoorbeeld). Om de identificatiecode voor een eigenschap te vinden, doen we hetzelfde, maar zoeken we naar \"P:zoekterm\" in plaats van gewoon \"zoekterm\", wat de zoekopdracht beperkt tot eigenschappen. Dit vertelt ons dat de beroemde componist Johann Sebastian Bach Q1339 is, en de eigenschap om de vader van een item te vinden P:P22 is.En last but not least, we moeten voorvoegsels toevoegen. Voor eenvoudige WDQS-tripels moeten de items worden voorafgegaan metwd:, en de eigenschappen met wdt:. (Maar dit geldt alleen voor vaste waarden - variabelen krijgen geen prefix!)Samengevat wordt onze eerste WDQS-query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Klik op de link Probeer het en vervolgens op Uitvoeren op de WDQS-pagina. Wat krijgt u als antwoord? child wd:Q57225 wd:Q76428 … Dat is teleurstellend. U ziet alleen de identificaties. U kunt op ze klikken om hun Wikidata-pagina te zien (inclusief een voor mensen leesbaar label), maar is er geen betere manier om de resultaten te zien?Die is er natuurlijk wel. (Zijn retorische vragen niet geweldig?) Als u de magische tekst toevoegt """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Zobŏcz tyż Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations bug 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be read like a sentence (which is why it ends with a full stop), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColour yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit colour yellow.
  ?fruit taste sour.
} which reads like “?fruit has colour ‘yellow’” (not “?fruit is the colour of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you've got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 维基数据查询服务（WDQS）是洞察维基数据内容的一个强大工具。本指南将教您如何使用它。另可尝试维基媒体以色列提供的交互式教程。自行编写SPARQL查询前，查阅{{Item documentation}}和其他通用SPARQL查询模板，看看所需的查询是否已有人提供。 Contents 1 开始之前 2 SPARQL基础 3 迈向第一个查询 3.1 自动完成 4 高级三元模式 5 实例和类别 5.1 属性路径 6 限定符 7 顺序（ORDER）和限制（LIMIT） 7.1 练习 7.1.1 Conan Doyle写的书 7.1.2 化学元素 7.1.3 流入密西西比河的河流 7.1.4 流入密西西比河的河流（第二课） 8 可选（OPTIONAL） 9 表达式、筛选器和绑定 9.1 数据类型 9.2 运算符 9.3 筛选器 9.4 BIND、BOUND、IF 9.5 组合（COALESCE） 10 分组 10.1 城市人口 10.2 绘画材料 10.3 按制造商划分枪支 10.4 按页数排序出版商 10.4.1 HAVING（必须） 10.5 聚合函数简述 10.6 wikibase:标签和聚合的bug 11 VALUES 12 Label in multiple languages 13 未完待续… 14 参见 开始之前 虽然这本指南看起来非常长且令人生畏，但请壮起胆来。了解SPARQL的基础知识就能让你走得更远——即便你在读完#迈向第一个查询后就停止阅读，你也能了解到许多有趣的查询。本教程的每个章节都能使你有能力写出更多强大的查询。如果你以前从未听说过维基数据、SPARQL或WDQS，下方有关于这些术语的简短解释。 维基数据是一个知识数据库。它包含了数以百万计的陈述，如“加拿大的首都是渥太华”，或“蒙娜丽莎是用油彩画在杨木上的”，或“黄金的熔点是1064.18摄氏度”。 SPARQL是一种为知识数据库制定问题（查询）的语言。有了合适的数据库，SPARQL查询可以回答诸如“音乐中最流行的音调是什么？”或“哪个角色被最多的演员所描绘？”或“血型的分布是什么？”或“今年哪些作家的作品进入了公共领域？”这样的问题。 WDQS，即维基数据查询服务，将这两者结合起来。你输入一个SPARQL查询，它针对维基数据的数据集运行，并向你显示结果。  SPARQL基础 一个简单的SPARQL查询看起来像这样： SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT从句列出您希望返回的变量（变量以问号开头），WHERE从句包含相关限制，主要以三元组的形式。维基数据（以及类似的知识数据库）中的所有信息都是以三元组的形式存储；当你运行查询时，查询服务会尝试将实际的值填入变量，从而呈现知识数据库中的三元组，并在返回的一个结果中呈现找到的每个变量组合。 三元组可以像一个句子一样阅读（这就是为什么它以句号结束），有一个主语、一个谓语和一个宾语。 SELECT ?水果
WHERE
{
  ?水果 它的颜色 黄色.
  ?水果 味道 酸.
} 这个查询的结果可能包括如“柠檬”。在维基数据中，大多数属性都是“具有”类型的属性，因此查询通常为： SELECT ?水果
WHERE
{
  ?水果 颜色 黄色.
  ?水果 味道 酸.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). 但其实这不是WDQS的一个好例子。味道是主观的，所以维基数据没有为它设置属性。现在，让我们考虑一下“父与子”的关系，这种关系通常不存在歧义。 迈向第一个查询 假设我们想列出巴洛克作曲家Johann Sebastian Bach的所有孩子。像上面的查询一样使用“伪元素”，你会怎么写这个查询？你或许会写成这样： SELECT ?孩子
WHERE
{
  #  孩子 \"他的父母\" Bach
  ?孩子 父母 Bach.
  # （注：'#'后面的所有内容都是注释，WDQS会忽略。）
} 或者这样， SELECT ?孩子
WHERE
{
  # 孩子（变量） \"他的父亲\" Bach 
  ?孩子 父亲 Bach. 
} 或者这样， SELECT ?孩子
WHERE
{
  #  Bach \"的孩子\" 孩子（变量）
  Bach 孩子 ?孩子.
} 前两个三元组要求?孩子必须有父母/父亲“巴赫”；第三个要求“巴赫”必须有孩子?child。我们现在先用第二个。那么，如何将其变为一个合适的WDQS查询呢？在维基数据中，项目和属性不是由人类可读的名称来识别的，如“父亲”（属性）或 “巴赫”（项目）。有充分的理由：“约翰·塞巴斯蒂安·巴赫”也是一位德国画家的名字，而“巴赫”也可能指的是姓氏、法国公社、水星坑等等。要找到一个项目的标识符，我们要搜索该项目，并复制结果中像是我们要找的项目的Q号（例如根据描述判断）。找到一个属性的标识符的方法相同，但要搜索“P:关键词”而不是仅仅搜索“关键词”，这样就能搜索范围限制在属性上。如此做能告诉我们，著名作曲家约翰·塞巴斯蒂安·巴赫对应的是Q1339，而指定一个项目的父亲的属性是P:P22。最后，还有一点很重要，我们要加上前缀。对简单的WDQS三元组来说，项的前缀是wd:，属性的前缀是wdt:。以上仅适用于固定的值，变量不需要前缀。综上所述，我们得到了首个正确的WDQS查询： SELECT ?孩子
WHERE
{
# ?孩子 父亲 Bach.
  ?孩子 wdt:P22 wd:Q1339.
}
 Try it! 单击“试一试”链接，然后在WDQS页面上“运行”查询。你得到想要的结果了吗？ 孩子 wd:Q57225 wd:Q76428 … 也许令你失望了？你只能看到标识符，虽然你可以单击来查看其对应的维基数据页面（包含易读的文字标签），有更好的方法显示这些结果吗？别急，我们有，只需包含下列神奇的语句 """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS ehk Wikidata päringuteenus on võimas tööriist, mis võimaldab piiluda Wikidata telgitagustesse. See juhend õpetab päringukeskkonda kasutama. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Enne alustamist 2 SPARQL-i alused 3 Meie esimene päring 3.1 Automaatne täitmine 4 Keerulisemad kolmikud 5 Üksikjuht nähtusest ja klassid 5.1 Omaduste rajad 6 Täpsustajad 7 ORDER ja LIMIT 7.1 Harjutus 7.1.1 Arthur Conan Doyle'i raamatud 7.1.2 Keemilised elemendid 7.1.3 Jõed, mis suubuvad Mississippisse 7.1.4 Jõed, mis suubuvad Mississippisse II 8 OPTIONAL 9 Avaldised, FILTER ja BIND 9.1 Andmetüübid 9.2 Tehtemärgid 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Rühmitamine 10.1 Linnade rahvaarvud 10.2 Maalimisel kasutatud materjalid 10.3 Relvad tootja kaupa 10.4 Kirjastused lehekülgede arvu järgi 10.4.1 HAVING 10.5 Kokkuvõte agregeerivatest funktsioonidest 10.6 wikibase:Label ja agregeerimine 11 VALUES 12 Label in multiple languages 13 Ja nii edasi… 14 See also Enne alustamist See juhend võib tunduda pikk ja hirmutav, kuid ära ehmu! SPARQL-i aluste õppimine laob tugeva põhja. Isegi, kui lõpetad lugemise pärast meie esimest päringut, oskad juba piisavalt, et koostada palju põnevaid päringuid. Juhendi iga lõik võimaldab Sul kirjutada aina võimsamaid päringuid.Kui Sa ei ole kunagi kuulnud mõistetest Wikidata, SPARQL või WDQS, siis siin on lühiseletus: Wikidata on koondandmebaas. See sisaldab miljoneid sissekandeid, nagu “Kanada pealinn on Ottawa” või “Mona Lisa on maalitud paplile õlivärviga” või “kulla sulamistemperatuur on 1064,18 kraadi Celsiuse järgi”. SPARQL on keel, mille abil saab sõnastada küsimusi (päringuid) andmebaasidele. Sobivas andmebaas suudab SPARQL-i päring vastata küsimustele nagu “mis on muusikas enim levinud tonaalsus?” või “millist tegelaskuju on mänginud suurim arv näitlejaid?” või “mis on veregruppide jaotus?” või “milliste autorite tööd lisandusid sel aastal avalikku omandisse?”. WDQS (Wikidata Query Service) ehk Wikidata päringuteenus toob need kaks kokku: Sa sisestad SPARQL-i päringu, see käib läbi Wikidata andmete ning kuvab Sulle tulemuse.  SPARQL-i alused Lihtne SPARQL-i päring näeb välja selline: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT lause on nimekiri muutujatest, mida Sa tahad tagastada (muutujad algavad küsimärgiga), ja WHERE lause sisaldab nende muutujate kitsendusi, peamiselt kolmikute kujul. Wikidatas (ja sarnastes andmebaasides) hoitakse kogu infot kolmikutena. Kui Sa käivitad päringu, siis proovib päringuteenus täita muutujad päris väärtustega, et tulemusena tekkinud kolmikud ilmuksid andmebaasis. Seejärel tagastab ta ühe tulemuse iga leitud muutujate kombinatsiooni kohta. Kolmikut võib lugeda kui lauset (mistõttu ta lõppeb ka punktiga), milles on subjekt, predikaat ja objekt: SELECT ?puuvili
WHERE
{
  ?puuvili omabVärvi kollane.
  ?puuvili maitseb hapult.
} Selle päringu tulemused võiksid sisaldada näiteks sidrunit. Wikidatas on enamik omadusi \"omab\" tüüpi, seega päringut võiks lugeda hoopis selliselt: SELECT ?puuvili
WHERE
{
  ?puuvili värv kollane.
  ?puuvili maitse hapu.
} mida võib lugeda “?puuvili omab värvi kollane” (mitte “?puuvili on kollase värv” – pea seda meeles selliste omaduspaaride juures nagu “vanem”/“laps”!).See aga ei ole hea näide WDQSi jaoks. Maitse on subjektiivne, seega Wikidatas ei ole selle jaoks omadust (ingl property). Mõtleme selle asemel vanema/lapse suhetele, mis on enamasti üheti mõistetavad. Meie esimene päring Oletame, et me tahame nimekirja barokkajastu helilooja Johann Sebastian Bachi kõigist lastest. Kasutades pseudoelemente nagu ülaltoodud päringutes, kuidas Sa selle päringu kirja paneksid?Loodetavasti said midagi sellist: SELECT ?laps
WHERE
{
  #  lapsel \"on vanem\" Bach
  ?laps vanem Bach.
  # (pane tähele: kõik, mis järgneb trellidele (‘#’) on kommentaar ning WDQS ignoreerib seda.)
} või siis SELECT ?laps
WHERE
{
  # lapsel \"on vanem\" Bach 
  ?laps vanem Bach. 
} või siis SELECT ?laps
WHERE
{
  #  Bachil \"on laps\" laps
  Bach laps ?laps.
} Esimesed kaks kolmikud ütlevad, et ?laps peab omama vanemat/isa Bach; kolmas ütleb, et Bachil peab olema laps ?laps. Vaatame praegu teist varianti.Mida me peame veel tegema, et sellest korralik WDQS-i päring teha? Wikidatas ei tuvastata üksusi ja omadusi inimloetavate siltide järgi nagu \"isa\" (omadus) või \"Bach\" (üksus). (Seda põhjusega: “Johann Sebastian Bach” on ühtlasi saksa maalikunstniku nimi ja “Bach” võib tähendada hoopis perekonnanimi, Prantsuse kommuuni, Merkuuri kraatrit või muud.) Selle asemel määratakse Wikidatas üksustele ja omadustele identifikaator. Selleks, et leida kindla üksuse identifikaatorit, otsime üksust ja kopeerime Q-numbri sellelt tulemuselt, mis tundub kõige sarnasem selle üksusega, mida me otsime (otsustades näiteks kirjelduse põhjal). Omaduse identifikaatori leidmiseks teeme sama, aga otsime “otsingutermini” asemel “P:otsingutermin”, mis kitsendab tulemused omadustele. See ütleb meile, et kuulus helilooja Johann Sebastian Bach on Q1339 ja üksuse isa kirjeldamiseks kasutatav omadus on P:P22.Viimaseks peame lisama eesliited. Lihtsate WDQS-i kolmikute puhul on üksustel eesliide wd: ja omadustel wdt:. (See käib ainult fikseeritud väärtuste kohta – muutujatele ei panda eesliidet!)Pannes kokku saadud teadmised, jõuame oma esimese WDQS-i päringuni: SELECT ?laps
WHERE
{
# ?laps  isa   Bach
  ?laps wdt:P22 wd:Q1339.
}
 Try it! Kliki nupul \"Proovi järele\", siis vajuta WDQS-i lehel suurt sinist nuppu päringu jooksutamiseks. Mis tulemuse saad? laps wd:Q57225 wd:Q76428 … See on küll pettumus. Sa näed ainult identifikaatoreid. Neile klikkides jõuad vastavale Wikidata lehele (kus on ka inimkeelne silt), aga kas tulemuste kuvamiseks pole paremat viisi?On ikka! (Kas retoorilised küsimused pole mitte toredad?) Kui Sa lisad maagilise teksti """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, é uma ferramenta poderosa para proporcionar informação sobre o conteúdo do Wikidata. Esta guia lhe ensinará como usá-la. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Antes de começar 2 O básico de SPARQL 3 Nossa primeira busca 3.1 Autocompletar 4 Padrões avançados de triplas 5 Instancias e classes 5.1 Caminhos de propriedades 6 Qualificadores 7 ORDER e LIMIT 7.1 Exercício 7.1.1 Livros de Arthur Conan Doyle 7.1.2 Elementos químicos 7.1.3 Rios que desaguam no Rio Mississippi 7.1.4 Rios que desaguam no Mississippi II 8 OPTIONAL 9 Expressões, FILTER e BIND 9.1 Tipo de dados 9.2 Operadores 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupamento 10.1 População de cidades 10.2 Materiais de pintura 10.3 Armas por fabricante 11 = Editoras pelo número de páginas 11.1 HAVING 11.2 Resumo das funções agregativas 11.3 wikibase:Label e \"bugs\" de agregação 12 VALUES 13 Label in multiple languages 14 E além... 15 Veja também Antes de começar Esse guia pode parecer longo e intimidar, mas não se assuste! Só o básico de SPARQL já é suficiente para fazer muita coisa - mesmo que a única coisa que voce leia seja #Our first query voce já vai conseguir construir diversas buscas interessantes. Cada seção do tutorial vai te empoderar para escrever buscas cada vez mais poderosas.Se voce nunca ouviu falar de Wikidata, SPARQL, ou WDQS antes, aqui vai uma explicação breve desses termos: Wikidata é uma base de conhecimento. Ela contém milhões de declarações, como \"a capital do Canadá é Ottawa\", ou \"a Mona Lisa é pintada a óleo sobre madeira de álamo\", ou \"o ouro tem um ponto de fusão de 1.064,18 graus Celsius\". SPARQL é uma linguagem usada para fazer perguntas (buscas, \"queries\") para bases de conhecimento. Com a base correta, uma busca SPARQL pode responder perguntas como \"qual é a tonalidade mais popular da música?\" ou \"qual personagem foi representada por mais atores?\" ou \"qual é a distribuição de tipos sanguíneos?\" ou \"quais autores tiveram obras entrando em domínio público esse ano?\". WDQS, é o Wikidata Query Service, o serviço de buscas do Wikidata, e ele une ambos conceitos: Voce escreve uma busca SPARQL e ele usa o Wikidata para localizar os resultados.  O básico de SPARQL Uma busca SPARQL simples se parece com isso: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} A parte SELECT lista as variáveis que voce quer que sejam retornadas na busca (as variáveis começam com um ponto de interrogação), e o WHERE contém as restrições da busca, representadas em triplas (declarações com sujeito, propriedade e valor). Toda a informação no Wikidata (e bases similares) é guardada na forma de triplas; quando a busca é feita, o WDQS vai (tentar) preencher as variáveis com valores reais que estejam nas triplas da base. O programa retorna, então, um resultado para cada combinação que ele encontra. Uma tripla pode ser lida como uma frase (e por isso termina com um ponto) com um \"sujeito\", um \"predicado\" e um \"objeto\". SELECT ?fruta
WHERE
{
  ?fruta temCor amarelo.
 ?fruta temGosto azedo.
} Os resultados dessa busca podem incluir, por exemplo, \"Limão amarelo\". Em Wikidata, a maioria das propriedades são do tipo \"tem\", então a busca pode ser escrita mais como: SELECT ?fruta
WHERE
{
  ?fruta cor amarelo.
 ?fruta gosto azedo.
} que le-se “?fruta tem cor ‘amarelo’” (não “?fruta é da\" cor' ‘amarelo’” – guarde essa ideia para pares de propriedade como “pai”/“filho”!).Contudo, esse não é um bom exemplo pro WDQR. Gosto é subjetivo, então wikidata não tem uma propriedade para isso. Em vez disso, vamos pensar em relações de pai/filho, que não tem tanta ambiguidade. Nossa primeira busca Suponha que queremos listar toda a prole do compositor barroco Johann Sebastian Bach. Usando pseudo elementos como nos exemplos acima, como voce escreveria essa busca?Talvez voce tenha feito algo assim: SELECT ?criança
WHERE
{
  #  ?criança \"tem progenitor\" Bach
  ?criança progenitor Bach.
  # (note: tudo após um 'H' é um comentário que é ignorado pelo WDQS.)
} ou assim, SELECT ?criança
WHERE
{
  # ?criança \"tem pai\" Bach 
  ?criança pai Bach. 
} ou assim, SELECT ?criança
WHERE
{
  #  Bach \"tem filho\" criança
  Bach filho ?criança
} As primeiras duas triplas falam que a ?criança deve ter como progenitor/pai o Bach, a terceira fala que Bach deve ter o filho ?criança. Vamos usar a segunda opção por agora.Bem, o que precisamos fazer para converter isso numa busca do WDQS? No Wikidata, items e propriedades não são identificadas por termos de línguas humanas como \"pai\" (propriedade) ou \"Bach\" (item). (Há uma boa razão: “Johann Sebastian Bach” também é o nome de um Pintor alemão, e “Bach” pode também se referir ao sobrenome em si, a comuna francesa, a cratera de Mercúrio, etc.)Em vez disso, itens e propriedades no Wikidata recebem um identificador. Para encontrar o identificador para um item, fazemos uma busca pelo item e copiamos o Q-id do resultado que parece ser o que estamos procurando (pela descrição, por exemplo). Para encontrar o identificador para um propriedade, fazemos o mesmo, mas buscando por \"P:termo para busca\" em vez de \"termo para busca\". Fazendo isso, descobrimos que o identificador para o famoso compositor Johann Sebastian Bach é Q1339, e a propriedade para indica o pai de algum item é P:P22.E por fim, precisamos adicionar prefixos. Para triplas WDQS simples, cada item é prefixado com wd:, and properties with wdt:. (mas isso se aplica apenas a valores fixos, variáveis não ganham um prefixo!)Juntando tudo, chegamos ao código para nossa primeira busca WDQS propriamente dita: SELECT ?criança
WHERE
{
# ?criança pai Bach.
  ?criança wdt:P22 wd:Q1339.
}
 Try it! Clique no link dizendo \"Try it\" e depois clique em \"Run\" na página do WDQS. O que voce achou? criança wd:Q57225 wd:Q76428 … Hm, isso foi triste. Voce apenas viu os identificadores. Voce pode clicar neles para ver as páginas (com rótulos que humanos podem ler), mas não há algum jeito melhor de ver os resultados?Bem, tem, claro! (Perguntas retóricas não são o máximo?) Voce precisa incluir o texto mágico em ingles """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Վարժություն 7.1.1 Արթուր Կոնան Դոյլի գրքեր 7.1.2 Քիմիական տարրեր 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Ներկարարական նյութեր 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Տես նաև Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} կամ սա, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Vikiveri Sorgu Servisi, Vikiveri'nin içeriği hakkında fikir sahibi olmak için güçlü bir araçtır. Bu rehber size nasıl kullanılacağını öğretecektir. Ayrıca Wikimedia İsrail tarafından oluşturulmuş etkileşimli öğreticiye bakabilirsiniz.Kendi SPARQL sorgunuzu yazmadan önce, sorgunuzun zaten daha önce {{Item documentation}} ya da diğer genel SPARQL sorgu şablonlarına dâhil edilip edilmediğine bakın. Contents 1 Başlamadan önce 2 SPARQL temelleri 3 İlk sorgumuz 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Başlamadan önce Bu rehber çok uzun ve korkutucu görünmekle birlikte lütfen bunun sizi korkutmasına izin vermeyin! Sadece SPARQL temellerini öğrenmek bile uzun vadede işinize yarayacaktır. İlk sorgumuzdan sonra okumayı bıraksanız bile birçok ilginç sorgu oluşturacak kadar konuyu zaten anlayacaksınız. Bu eğitimin her bölümü daha güçlü sorgular yazmanızı sağlayacaktır.Daha önce Vikiveri, SPARQL veya WDQS'i hiç duymadıysanız bu terimlerin kısa bir açıklaması karşınızda: Vikiveri, bir bilgi veritabanıdır. \"Kanada'nın başkenti Ottawa'dır\" ya da \"Mona Lisa kavak ağacı üzerine yağlı boyayla boyanmıştır\" veya \"altın 1.064.18 santigrat derece erime noktasına sahiptir\" gibi milyonlarca cümle içerir. SPARQL, bilgi veritabanları için sorular (sorgular) formüle etmek için kullanılan bir dildir. Doğru veritabanıyla bir SPARQL sorgusu \"müzikte en popüler tonalite nedir?\", en çok hangi oyuncu hangi karakteri canlandırdı?, \"kan gruplarının dağılımı nedir?\" veya \"hangi yazarın eserleri bu yıl yayımlandı?\" gibi sorulara cevap verebilir. WDQS, Vikiveri Sorgu Hizmeti, şu ikisini bir araya getirir: Bir SPARQL sorgusu girince bunu Vikiveri veri kümesine karşı çalıştırır ve sonucu gösterir.  SPARQL temelleri Basit bir SPARQL sorgusu şöyle görünür: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT yan tümcesi, döndürülmesini istediğiniz değişkenleri listeler (değişkenler bir soru işareti ile başlar) ve WHERE yan tümcesi, çoğunlukla üçlü formda olan kısıtlamaları içerir. Vikiveri'deki tüm bilgiler (ve benzer bilgi veritabanları) üçlü şeklinde saklanır; sorguyu çalıştırdığınızda sorgu hizmeti değişkenleri gerçek değerlerle doldurmaya çalışır, böylece elde edilen üçlüler bilgi veritabanında görünür ve bulduğu değişkenlerin her birleşimi için bir sonuca çevirir. Üçlü, bir cümle gibi (bu nedenle bir nokta ile biter) bir özne, bir yüklem ve bir nesne ile okunabilir: SELECT ?meyve
WHERE
{
  ?meyve rengi sarı.
 ?meyve tadı ekşi.
} Bu sorgu için sonuçlar arasında örneğin “limon” yer alabilir. Vikiveri'de çoğu özellik sahiplik anlamı içerir, bu nedenle sorguyu bu şekilde okuyabiliriz: SELECT ?meyve
WHERE
{
  ?meyve rengi sarı.
 ?meyve tadı ekşi.
} yüklemlerin sahiplik özelliğini bu örnekte gözlemleyebiliriz. “‘sarı’ renge sahip ?meyve ” (“sarı renkte ki ?meyve ” değil – sahiplik özelliğine hiyerarşik yapıda ki Üçlü'ler arasında dikkat edin!)Bu örnek WDQS için iyi bir örnek değildir. Tat subjektif bir yüklem olduğu için Vikiveri tat yüklemini kullanmaz. Bunun yerine hiyerarşik bir düzene sahip kaynak/alt-öğe ilişkileri tercih edilir. İlk sorgumuz Barok dönem bestekarlarından Johann Sebastian Bach'ın bütün çocuklarını listeleyelim. Yukarıda gördüğümüz Üçlü elementleriyle nasıl sorgu oluşturabilirsiniz?Umarız aşağıdakine benzer bir sorgu oluşturdunuz: SELECT ?çocuk
WHERE
{
  #  çocuk \"ebeveyne sahip\" Bach
  ?çocuk ebeveyn Bach.
  # (not: '#' karakterinden sonra yazılanlar yorum olarak algılanır ve WDQS sorgusu için kullanılmaz.)
} ya da bu, SELECT ?çocuk
WHERE
{
  # çocuk \"babasına sahip\" Bach 
  ?çocuk baba Bach. 
} ya da bu, SELECT ?çocuk
WHERE
{
  #  Bach \"çocuğa sahip\" çocuk
  Bach çocuk ?çocuk.
} ilk iki Üçlü Bach isminde ebeveyni/babası olan ?çocuk aratırken, üçüncü Üçlü ?çocuk sahibi Bach aratmaktadır. İkinci örneği kullanarak devam edelim.Peki bunları düzgün bir WDQS sorgusuna çevirmek için ne yapmalıyız? Vikiveri'de özneler ve özellikler, ”baba” (özellik) ya da ”Bach” (özne) gibi insanlar tarafından okunabilir isimler tarafından tanımlanmazlar. (Bunun iyi bir nedeni var; ”Johann Sebastian Bach” Alman ressam'a, veya ”Bach” soyadı'na, Fransız komünü'ne, Merkür krateri'ne, vb) ait olabilir. Bu yüzden Vikiveri özne ve özelliklere bir tanımlama numarası atamaktadır. Bu tanımlama numaralarını bulmak için, ara'dan özneyi bulup, (detaylarını okuyup) doğru olduğunu düşündüğünüz sonucun Q-numarasını kopyalayın. Bir özelliğin tanımlama numarasını bulmak için aynı şeyi yapabiliriz, lakin bu sefer arama kriterini ”arama kriteri” yerine “P:arama kriteri” şeklinde düzenlemeniz gerekmektedir. Bu arama sonucu bize ünlü bestekar Johann Sebastian Bach'ın tanımlama numarasının Q1339 olduğunu, ve babasını tanımlayan özelliğin tanımlama numarasının P:P22 olduğunu gösterir. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, adalah perkakas hebat yang dapat memberikan wawasan konten yang ada di Wikidata. Panduan ini akan mengajarkanmu cara menggunakannya. Lihat pula tutorial interaktif oleh Wikimedia Israel.Sebelum menulis kueri SPARQL Anda sendiri, periksa {{Item documentation}} atau templat kueri SPARQL generik lainnya dan lihat apakah kueri Anda sudah ada. Contents 1 Sebelum kita mulai 2 Dasar-dasar SPARQL 3 Kueri pertama kita 3.1 Pelengkap otomatis 4 Pola tripel lanjut 5 Instans and kelas 5.1 Jejak atribut 6 Penjelas 7 ORDER dan LIMIT 7.1 Latihan 7.1.1 Buku-buku Arthur Conan Doyle 7.1.2 Unsur-unsur Kimia 7.1.3 Sungai-sungai yang mengalir ke Mississippi 7.1.4 Sungai yang mengalir ke Mississippi II 8 OPTIONAL 9 Ekspresi, FILTER dan BIND 9.1 Tipe-tipe data 9.2 Operator-operator 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Pengelompokkan 10.1 Populasi kota 10.2 Material lukisan 10.3 Senjata berdasarkan pembuat 10.4 Penerbit berdasarkan banyaknya halaman 10.4.1 HAVING 10.5 Rangkuman fungsi agregat 10.6 Kutu wikibase:Label dan agregasi 11 VALUES 12 Label in multiple languages 13 Dan seterusnya... 14 Lihat pula Sebelum kita mulai Meskipun panduan ini tampak panjang dan menakutkan, tolong jangan terusir! Pelajari saja dasar-dasar SPARQL sembari jalan – bahkan jika kamu berhenti membaca setelah kueri pertama kita, kamu akan sudah cukup paham bagaimana merakit kueri-kueri yang menarik. Setiap bab dari tutorial ini akan memberdayakanmu untuk menulis kueri yang lebih canggih.Kalau kamu belum pernah mendengar Wikidata, SPARQL atau WDQS sebelumnya, berikut ini penjelasan singkat istilah-istilah tersebut: Wikidata adalah basisdata pengetahuan. Ia mengandung jutaan pernyataan, seperti “Ibukota Kanada adalah Ottawa”, atau “Mona Lisa dilukis dengan cat minyak pada kayu poplar”, atau “emas memiliki titik lebur 1,064.18 derajat Celsius”. SPARQL adalah bahasa untuk memformulasi pertanyaan (kueri) pada basisdata pengetahuan. Pada basisdata yang tepat, kueri SPARQL dapat menjawab pertanyaan-pertanyaan seperti “apakah tonalitas di musik yang paling populer?” atau “karakter apa yang paling banyak diperankan oleh para aktor?” atau “bagaimana distribusi golongan darah?” atau “karya penulis apa saja yang jadi domain publik tahun ini?”. WDQS, Wikidata Query Service, menyambung kedua hal tersebut: Kamu memasukkan kueri SPARQL, WDQS menjalankannya terhadap dataset Wikidata dan memberikan hasilnya kepadamu.  Dasar-dasar SPARQL Kueri SPARQL sederhana tampak seperti ini: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Klausa SELECT mendaftarkan variabel yang kamu mau dapatkan (variabel diawali tanda tanya), dan klausa WHERE mengandung batasan-batasannya, umumnya dalam bentuk kumpulan tripel. Semua informasi di Wikidata (dan basisdata pengetahuan sejenisnya) disimpan dalam bentuk kumpulan tripel; tiap kali kamu menjalankan kueri, layanan kueri mencoba mengisikan variabel-variabel dengan nilai yang sesuai dengan tripel-tripel yang ada di basisdata pengetahuan, dan mengembalikan satu hasil untuk setiap kombinasi variabel-variabel yang ditemukan. Sebuah tripel dapat dibaca seperti layaknya kalimat (itulah sebabnya diakhiri tanda titik) yang terdiri dari \"subjek\", \"predikat\", dan \"objek\". SELECT ?buah
WHERE
{
  ?buah berwarna kuning.
  ?buah berasa asam.
} Hasil dari kueri ini dapat mencakup, misalnya \"jeruk nipis\". Di Wikidata, kebanyakan atribut adalah atribut \"ber-\" sehingga kueri juga dapat dibaca: SELECT ?buah
WHERE
{
  ?buah warna kuning.
  ?buah warna asam.
} yang dibaca sebagai “?buah ber warna ‘kuning’” (bukan “?buah adalah warna ‘kuning’” – ingatlah bahwa pasangan atribut seperti “orangtua”/“anak”!).Bagaimanapun, itu bukan contoh yang baik untuk WDQS. Rasa adalah hal yang subjektif sehingga Wikidata tidak memiliki atribut seperti itu. Lebih baik kita bayangkan tentang relasi orangtua/anak yang umumnya tidak rancu. Kueri pertama kita Andaikan kita ingin mendaftarkan semua anak dari komponis baroque Johann Sebastian Bach. Dengan menggunakan pseudo-elemen seperti kueri-kueri di atas, bagaimana kamu akan menuliskan kueri?Semoga kamu mendapatkan yang seperti berikut: SELECT ?anak
WHERE
{
  #  anak \"punya orang tua\" Bach
  ?anak orangtua Bach.
  # (cat: semua yang muncul setelah tanda '#' adalah komentar yang diabaikan oleh WDQS.)
} atau ini, SELECT ?anak
WHERE
{
  # anak \"punya bapak\" Bach 
  ?anak bapak Bach. 
} atau ini, SELECT ?anak
WHERE
{
  #  Bach \"punya anak\" anak
  Bach anak ?anak.
} Kedua tripel pertama mengatakan bahwa ?anak harus memiliki orangtua/bapak Bach; yang ketiga mengatakan bahwa Bach harus memiliki anak ?anak. Mari kita pakai yang kedua untuk saat ini.Sekarang tinggal bagaimana mengubah hal-hal tersebut menjadi kueri WDQS yang layak. di Wikidata, butir dan atribut tidak diidentifikasi dengan nama yang mudah dibaca seperti \"bapak\" (atribut) atau \"Bach\" (butir). (\"Johann Sebastian Bach\" juga adalah nama untuk Pelukis Jerman, dan \"Bach\" mungkin juga merujuk ke nama marga, komune di Perancis, kawah di Merkurius, dst.) sebagai gantinya, butir dan atribut Wikidata diberi penanda unik. Untuk mencari penanda suatu butir, kita cari butir tersebut dan salin Q-angka dari hasil yang paling pas dengan yang kita cari (misalnya, berdasarkan pemerian). Untuk mencari penanda atribut, kita lakukan yang sama. hanya saja pencariannya menggunakan \"P:istilah pencarian\" dan bukan sekadar \"istilah pencarian\" sehingga pencariannya dibatasi hanya pada atribut saja. Dari sini kita tahu bahwa komponis terkenal Johann Sebastian Bach adalah Q1339, dan atribut yang menentukan bapak dari butir adalah P:P22.Akhirnya, kita perlu menambahkan prefiks. untuk tripel-tripel WDQS sederhana, butir-butirnya perlu diawali wd: dan wdt: untuk atribut. (ini hanya berlaku untuk nilai yang sudah tetap – variabel tidak membutuhkan prefix!)Menggabungkan itu semua, sampailah kita pada kueri WDQS kita pertama yang layak: SELECT ?anak
WHERE
{
# ?anak bapak Bach.
  ?anak wdt:P22 wd:Q1339.
}
 Try it! klik tautan \"Cobalah\" dan \"Jalankan\" kueri di halaman WDQS. Apa yang kamu dapatkan? ?anak wd:Q57225 wd:Q76428 … Tampak tidak menarik. Kamu hanya melihat penanda-penanda. Kamu bisa klik pada penanda tersebut untuk melihat halaman Wikidatanya (termasuk label yang berterbaca manusia), tapi bukankah ada cara yang lebih baik untuk melihat hasilnya?Ternyata ada! (pertanyaan retoris itu keren, kan?) kalau kamu tambahkan teks ajaib berikut """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Før vi går igang 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Tilfælde og klasser 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Kemiske elementer 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Datatyper 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Gruppering 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VÆRDIER 12 Label in multiple languages 13 And beyond… 14 Se også Før vi går igang While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} eller dette, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} eller dette, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS: خدمة استعلام ويكي بيانات: هي أداة قوية لتوفير نظرة ثاقبة لمحتوى ويكي بيانات. سوف يعلمك هذا الدليل كيفية استخدامه. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents ١ قبل أن نبدأ ٢ أساسيات سباركل ٣ استعلامنا الأول ٣.١ إكما تلقائي ٤ أنماط ثلاثية متقدمة ٥ مثيلات وفئات ٥.١ مسارات الخاصية ٦ التصفيات ٧ ORDER وLIMIT ٧.١ تمرين ٧.١.١ كتب آرثر كونان دويل ٧.١.٢ العناصر الكيميائية ٧.١.٣ الأنهار التي تتدفق إلى المسيسيبي ٧.١.٤ الأنهار التي تتدفق إلى الميسيسيبي 2 ٨ OPTIONAL ٩ تعبيران: FILTER وBIND ٩.١ أنواع البيانات ٩.٢ المشغلون ٩.٣ FILTER ٩.٤ BIND، BOUND، IF ٩.٥ COALESCE ١٠ التجمع ١٠.١ سكان المدينة ١٠.٢ مواد الطلاء ١٠.٣ البنادق حسب الشركة المصنعة ١٠.٤ الناشرون حسب عدد الصفحات ١٠.٤.١ HAVING ١٠.٥ ملخص الدالات التجميعية ١٠.٦ wikibase:Label and aggregations ١١ VALUES ١٢ Label in multiple languages ١٣ وما وراء... ١٤ See also قبل أن نبدأ في حين أن هذا الدليل قد يبدو طويلا ومرهقا، فلا تدع هذا يخيفك! إن مجرد تعلم أساسيات سباركل سيوفر لك طريقا طويلا - حتى إذا توقفت عن القراءة بعد #استعلامنا الأول ، سوف تفهم بالفعل ما يكفي لبناء العديد من الاستعلامات المثيرة للاهتمام، سيقوم كل قسم من هذا البرنامج التعليمي بتمكينك من كتابة استعلامات أكثر فعالية.أيضا، إذا لم تكن قد سمعت من قبل عن ويكي بيانات أو سباركل أو خدمة استعلام ويكي بيانات من قبل، فإليك شرح موجز لتلك المصطلحات: ويكي بيانات هي قاعدة بيانات المعرفة، تحتوي على ملايين البيانات، مثل \"عاصمة كندا أوتاوا\"، أو \"الموناليزا مطلية بطلاء زيت على خشب الحور\"، أو \"الذهب له نقطة انصهار 1064.18 درجة مئوية\". 'SPARQL' هي لغة لصياغة أسئلة (استعلامات) لقواعد بيانات المعرفة، باستخدام قاعدة البيانات الصحيحة، يمكن أن يجيب استعلام سباركل على أسئلة مثل \"ما هي النغمة الأكثر شيوعا في الموسيقى؟\" أو \"أية شخصية تم تصويرها بواسطة أكثر الممثلين؟\" أو \"ما هو توزيع أنواع الدم؟ \"أو\" ما أعمال المؤلفين التي دخلت الملكية العامة هذا العام؟\". WDQS:خدمة استعلام ويكي بيانات تجمع الاثنين معا: يمكنك إدخال استعلام سباركل، فإنها تشغله تجاه مجموعة بيانات ويكي بيانات ويظهر لك النتيجة.  أساسيات سباركل يبدو استعلام سباركل بسيط مثل هذا: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} تسرد جملة SELECT المتغيرات التي تريد إرجاعها (تبدأ المتغيرات بعلامة استفهام)، وتحتوي جملة WHERE على قيود عليها، معظمها في صورة ثلاثيات، يتم تخزين جميع المعلومات في ويكي بيانات (وقواعد بيانات المعرفة المماثلة) في شكل ثلاثيات، عندما تقوم بتشغيل الاستعلام، تحاول خدمة الاستعلام ملء المتغيرات بالقيم الفعلية بحيث تظهر الثلاثيات الناتجة في قاعدة بيانات المعرفة، وترجع نتيجة واحدة لكل مجموعة من المتغيرات التي تعثر عليها. يمكن قراءة الثلاثي كجملة (وهذا هو السبب في أنه ينتهي بنقطة)، مع موضوع، ومسند، وكائن: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} قد تتضمن نتائج هذا الاستعلام، على سبيل المثال، \"ليمون\"، في ويكي بيانات، معظم الخصائص هي خصائص \"لديه\"-نوع ; لذا قد يقرأ الاستعلام بدلا من ذلك: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} الذي يقرأ مثل \"?fruit له لون \"أصفر\" (ليس \"?fruit is لون \"الأصفر\"، ضع هذا في الاعتبار لأزواج الخواص مثل \"الأم\"/\"الطفل\"!).ومع ذلك، هذا ليس مثالا جيدًا لـخدمة استعلام ويكي بيانات، الذوق شخصي; لذلك ليس لدى ويكي بيانات خاصية خاصة به، بدلا من ذلك، دعونا نفكر في العلاقات بين الوالد/الطفل، والتي لا لبس فيها في الغالب. استعلامنا الأول لنفترض أننا نريد سرد جميع أطفال الملحن الباروكي يوهان سيباستيان باخ، باستخدام عناصر زائفة كما في الاستعلامات أعلاه، كيف تكتب هذا الاستعلام؟نأمل أن يكون لديك شيء من هذا القبيل: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (ملاحظة: كل شيء بعد '#' هو تعليق ويتم تجاهله بواسطة خدمة استعلام ويكي بيانات.)
} أو هذا، SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} أو هذا، SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} تقول أول ثلاثيتين أن ?child يجب أن يكون له الوالد/الأب باخ، تقول الثالثة أن باخ يجب أن يكون الطفل ?child، لنذهب مع الثاني في الوقت الحالي.ما الذي يجب عمله حتى يتم تحويله إلى استعلام خدمة استعلام ويكي بيانات ملائم؟ في ويكي بيانات، لا يتم تحديد العناصر والخصائص بواسطة أسماء يمكن قراءتها بواسطة الإنسان مثل \"الأب\" (خاصية) أو \"باخ\" (عنصر). (لسبب وجيه: \"يوهان سيباستيان باخ\" هو أيضا اسم رسام ألماني، وقد يشير \"باخ\" أيضا إلى لقب، البلدية الفرنسية ، الحفرة الزئبقية، إلخ.) بدلا من ذلك، يتم تعيين معرف لعناصر وخصائص ويكي بيانات، للعثور على المعرف لعنصر; نحن نبحث عن العنصر وننسخ الرقم Q للنتيجة التي يبدو أنها العنصر الذي نبحث عنه (على أساس الوصف، على سبيل المثال)، للعثور على معرف خاصية; نفعل نفس الشيء، ولكن ابحث عن \"P:مصطلح البحث\" بدلا من \"مصطلح البحث\"، والذي يحدد البحث إلى الخصائص، هذا يخبرنا أن الملحن الشهير يوهان سيباستيان باخ هو Q1339، والخاصية التي تحدد اسم الأب هي P:P22وأخيرا وليس آخرا، نحتاج إلى تضمين البادئات، بالنسبة لمضاعفات خدمة استعلام ويكي بيانات البسيطة، يجب أن تبدأ العناصر بـwd:، وخصائص تحتوي على wdt:. (لكن هذا ينطبق فقط على القيم الثابتة، لا تحصل المتغيرات على بادئة!)بوضع هذا الأمر معا، نصل إلى أول طلب بحث في أول استعلام خدمة استعلام ويكي بيانات صحيح: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! انقر فوق ذلك الرابط \"جربه\"، ثم \"تشغيل\" الاستعلام على صفحة خدمة استعلام ويكي بيانات، على ماذا تحصل؟ طفل wd:Q57225 wd:Q76428 … حسنا هذا مخيب للآمال، أنت فقط ترى المعرفات، يمكنك النقر عليها لرؤية صفحة ويكي بيانات الخاصة بها (بما في ذلك تسمية يمكن قراءتها بواسطة البشر)، ولكن أليست هناك طريقة أفضل لرؤية النتائج؟حسنا، كما يحدث، هناك! (أليست الأسئلة الخطابية رائعة؟) إذا قمت بتضمين النص السحري """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS こと Wikidata Query Service は、Wikidata のコンテンツへの洞察を提供する強力なツールです。このガイドでは WDQS の使い方を説明します。interactive tutorial by Wikimedia Israel も参照してください。自分で SPARQL クエリを書く前に、{{Item documentation}}やその他の一般的な SPARQL クエリのテンプレートを調べて、その中にすでに書きたいクエリが含まれていないかどうか確認してください。 Contents 1 はじめる前に 2 SPARQLの基本 3 初めてのクエリ 3.1 自動補完 4 より進んだトリプルのパターン 5 インスタンスとクラス 5.1 プロパティパス 6 修飾子 7 ORDERとLIMIT 7.1 演習 7.1.1 アーサー・コナン・ドイルの本 7.1.2 化学元素 7.1.3 ミシシッピ川に流れ込む川 7.1.4 ミシシッピ川に流れ込む川 その2 8 OPTIONAL 9 式、FILTERとBIND 9.1 データ型 9.2 演算子 9.3 FILTER 9.4 BIND、BOUND、IF 9.5 COALESCE 10 グループ化 10.1 都市の人口 10.2 画材 10.3 メーカー別の銃 10.4 ページ数別の出版社 10.4.1 HAVING 10.5 集約関数の概要 10.6 wikibase:ラベルと集約 11 VALUES 12 Label in multiple languages 13 さらには… 14 関連項目 はじめる前に このガイドはとても長く威圧的に見えるかもしれませんが、どうか敬遠しないでください。SPARQLの基本を学ぶだけでも、かなりのことができるようになります。#初めてのクエリまでで読むのを止めたとしても、興味深いクエリをたくさん書くための知識としては十分です。さらにこのチュートリアルの各セクションを読めば、よりパワフルなクエリを書くことができるでしょう。WikidataやSPARQL、WDQSについて、これまでまったく聞いたことがない方のために、これらの用語について簡単に説明しておきましょう。 Wikidata は知識データベースです。「カナダの首都はオタワである」「モナリザはポプラの木に油絵の具で描かれている」「金の融点は1,064.18度である」といったような、何百万もの文から成ります。 SPARQL は知識データベースに対して定式化された質問（クエリ）を行うための言語です。適切なデータベースとSPARQLクエリがあれば、「音楽のもっとも主要な調性は?」「もっとも多くの俳優に演じられたキャラクターは?」「血液型の分布は?」「今年パブリックドメインになる作家の作品は?」といった疑問に答えることができます。 WDQS こと Wikidata Query Service は、上のふたつを統合したものです。SPARQLクエリを入力すると、Wikidataのデータセットに対して検索を行い、その結果を表示します。  SPARQLの基本 シンプルなSPARQLクエリは次のようなものです。 SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT節にはクエリの結果として得たい変数を列挙します（変数はクエスチョン・マークで始まります）。WHERE節はそれらの変数に対する制約からなり、ほとんどの場合はトリプルの形をとります。Wikidata（および類似の知識データベース）のすべての情報は、トリプルの形で保存されています。クエリが実行されると、クエリサービスは得たいトリプルの制約を満たすような変数の値を知識データベース上に見つけようと試みます。そしてそのような変数の組み合わせが見つかるごとに、それをひとつの結果として返します。 トリプルは主語、述語、目的語を持つ文のように読むことができます(トリプルがピリオドで終わるのはそのためです)。 SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} このクエリの回答は、例えば “lemon” です。Wikidataでは、ほとんどのプロパティは “has” の性質を持つプロパティです。そのためこのクエリは以下のように書いてもいいでしょう。 SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} これは?fruit has color ‘yellow’ と読めます（?fruit is the color of ‘yellow’ ではありません — parent/child のような対になるプロパティのためにこれは心に留めておいてください）。しかしながら、WDQSの説明のためには、これはあまりいい例ではありませんでした。taste（〜な味がする）は主観的なので、Wikidataにはこれに対応するプロパティがないのです。代わりに、たいていの場合においては曖昧さのない、parent/child（親／子）の関係について考えてみましょう。 初めてのクエリ バロック音楽の作曲家、ヨハン・ゼバスティアン・バッハの、すべての子供を列挙したいものと考えてみてください。上のクエリで見たような擬似要素を使うとして、あなたならどんなクエリを書きますか？こんな感じのクエリを書いたのではないでしょうか。 SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # （注：‘#’ より後ろはすべてはコメントで、WDQSには無視されます。）
} あるいはこんなのや、 SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} こんなのかもしれませんね。 SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} 最初のふたつのトリプルは、?childは parent/father に Bach を持っていなければならない、と言っています。3つめのは、Bach はその子供に?childを持っていなければならない、と言っています。ここでは2つめのを採用することにしましょう。では、これを適切なWDQSクエリに変換するためには、あと何が必要でしょうか。ウィキデータでは、項目やプロパティを特定するために使われているのは、例えば「父親」（プロパティ）とか、「バッハ」（項目）とかいった、人間にわかりやすい名前ではありません。（これにはちゃんとした理由があります。「ヨハン・ゼバスティアン・バッハ」はドイツの画家の名前でもありますし、「バッハ」は人物の姓であるだけでなく、フランスの自治体や、火星のクレーターなどの名前でもあり、これらを指しているかもしれないからです。） 代わりに、ウィキデータの項目とプロパティには、識別子が割り当てられています。ある項目の識別子を見つけるには、項目を検索して、（例えば説明文などから）それらしいものが見つかったら、その Q ナンバーをコピーします。プロパティの識別子を見つけるのにも同じことを行いますが、単に検索窓に探している言葉を入力するのではなく、「P:探している言葉」と入力すれば、プロパティに限定して検索を行います。この検索の結果として、あの有名な作曲家のヨハン・ゼバスティアン・バッハは Q1339 であり、そしてある人物の父親を指定するプロパティは P:P22 であることがわかります。最後に忘れてはいけないのが、接頭辞をつけることです。単純なWDQSトリプルでは、項目にはwd:を、そしてプロパティにはwdt:を、その頭につけなければいけません。（ただしこれは値が決まっているときだけにしてください。変数に接頭辞をつけてはいけません。）これをまとめると、初めての正しいWDQSクエリが出来上がります。 SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! 「Try it!」のリンクをクリックすると、WDQSのページでクエリが実行されます。結果はどうなりましたか？ child wd:Q57225 wd:Q76428 … うーんこれはちょっとがっかりですね。識別子しか表示されていません。識別子をクリックすれば該当のWikidataのページを見ることはできるのですが（そこには人にわかりやすいラベルもあるのですが）、検索結果を見るのにもうちょっといい方法はないのでしょうか？はい、実はこれがあるんですね！（修辞疑問文ってすごいと思いませんか？）次の魔法の一文を WHERE 節のどこかに追加すると、 """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, es una herramienta poderosa para proporcionar información sobre el contenido de Wikidata. Esta guía te enseñará cómo usarla. Mira también el tutorial interactivo de Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Antes de comenzar 2 Conceptos básicos de SPARQL 3 Nuestra primera query 3.1 Autocompletado 4 Funciones avanzadas 5 Instancias y clases 5.1 Propiedades y rutas 6 Calificadores 7 ORDER y LIMIT 7.1 Ejercicios 7.1.1 Libros de Arthur Conan Doyle 7.1.2 Elementos químicos 7.1.3 Ríos que desembocan en el Mississippi 7.1.4 Ríos que desembocan en el Mississippi II 8 OPCIONAL 9 Expresiones, FILTER y BIND 9.1 Tipos de datos 9.2 Operadores 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupación 10.1 Poblaciones de ciudades 10.2 Materiales de pintura 10.3 Armas por fabricante 10.4 Editores por cantidad de páginas 10.4.1 HAVING 10.5 Sumario de las funciones agregación 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 Y más allá… 14 Véase también Antes de comenzar Si bien esta guía puede parecer muy larga e intimidante, ¡no dejes que eso te asuste! El solo hecho de aprender los conceptos básicos de SPARQL te llevará lejos, incluso si dejas de leer después de #Nuestra primera query ya sabrás lo suficiente como para construir muchas consultas interesantes. Cada sección de este tutorial te permitirá crear consultas aún más complejas.Si nunca has oído hablar de Wikidata, SPARQL, o WDQS antes, aquí una breve explicación de estos términos: Wikidata es una base de datos de conocimiento. Contiene muchas declaraciones como \"la capital de Canadá es Ottawa\", o \"la Mona Lisa está pintada al óleo sobre madera de álamo\", o \"el oro tiene un punto de fusión de 1,064.18 grados Celsius\". SPARQL es un lenguaje para formular preguntas (consultas) para bases de datos de conocimiento. Con la base de datos adecuada, una consulta SPARQL podría responder a preguntas como \"¿cuál es la tonalidad más popular en la música?\" o \"¿qué personaje fue representado por la mayoría de los actores? o \"¿cuál es la distribución de los tipos de sangre? o \"¿qué obras pasaron a ser de dominio público este año?\" WDQS, el servicio de consulta de Wikidata, reúne ambas funciones: si escribes una consulta SPARQL, la ejecuta contra el conjunto de datos de Wikidata y te muestra el resultado.  Conceptos básicos de SPARQL Una consulta SPARQL sencilla tiene este aspecto: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La cláusula SELECT enumera las variables que deseas que se respondan (las variables comienzan con un signo de interrogación), y la cláusula WHERE contiene las restricciones, principalmente en forma de ternas. Toda la información en Wikidata (y bases de datos de conocimiento similares) se almacena en forma de terna; cuando se ejecuta una consulta, el servicio de consulta intenta completar las variables con valores reales para que las ternas resultantes aparezcan en la base de datos de conocimiento, y devuelve un resultado para cada combinación de variables que encuentra. Una terna se puede leer como una oración (por eso termina con un punto), con un \"sujeto\", un \"predicado\" y un \"objeto\": SELECT ?fruta
WHERE
{
  
?fruta tieneColor amarillo.
  ?fruta gusto agrio.
} Los resultados para esta consulta podrían incluir, por ejemplo, “limón”. En Wikidata, la mayoría de las propiedades se pueden leer como propiedades que comienzan con “tiene”, así que la consulta podría ser en su lugar: SELECT 
?fruta
WHERE
{
  
?fruta color amarillo.
  ?fruta gusto agrio.
} Lo cual se lee “?fruta tiene color ‘amarillo’” (no como “?fruta es de color ‘amarillo’” – ten esto en cuenta para los pares de propiedades como \"padre\" / \"niño\"!).Sin embargo, ese no es un buen ejemplo para WDQS. El gusto es subjetivo, por lo que Wikidata no tiene una propiedad para ello. En su lugar, pensemos en las relaciones entre padres e hijos, que en su mayoría son inequívocas. Nuestra primera query Supongamos que queremos enumerar a todos los hijos del compositor barroco Johann Sebastian Bach. Usando pseudo-elementos como en las consultas anteriores, ¿cómo escribirías esa consulta?Esperemos que tengas algo como esto: SELECT ?hijo
WHERE
{
  #  hijo \"tiene padre\" Bach
  ?hijo padre Bach.
  # (Nota: todo lo que se escribe después de un '#' es un comentario y es ignorado por WDQS.)
} O esto, SELECT ?hijo
WHERE
{
  # hijo \"tiene padre\" Bach 
  ?hijo papá Bach. 
} o esto, SELECT ?hijo
WHERE
{
  #  Bach \"tiene hijo\" hijo
  
Bach hijo ?hijo.
} Las primeras dos ternas dicen que el ?hijo debe tener el padre Bach; el tercero dice que Bach debe tener el hijo ?hijo. Vayamos con el segundo por ahora.Entonces, ¿qué queda por hacer para convertir esto en una consulta WDQS adecuada? En Wikidata, los elementos y las propiedades no se identifican con nombres legibles como \"padre\" (propiedad) o \"Bach\" (elemento). (Por una buena razón: \"Johann Sebastian Bach\" es también el nombre del pintor alemán, y \"Bach\" también puede referirse al apellido, o a la comuna francesa, o a cráter en Mercurio, etc.) En vez de nombres, a los elementos y propiedades de Wikidata se les asigna un identificador. Para encontrar el identificador de un elemento, buscamos el elemento y copiamos el número \"Q\" que corresponde al elemento que buscamos (lo podés identificar a partir de la descripción, por ejemplo). Para encontrar el identificador de una propiedad, hacemos lo mismo, pero buscamos \"P: término de búsqueda\" en lugar de solo el \"término de búsqueda\", lo que limita la búsqueda a las propiedades. Esto nos dice que el famoso compositor Johann Sebastian Bach es la Q1339, y la propiedad para designar al padre de un elemento es la P:P22.Por último pero no menos importante, necesitamos incluir los prefijos. Para las consultas de ternas simples, los items deberían tener como prefijo wd:, y las propiedades wdt:. (Esto solo aplica a valores fijos - las variables no tienen un prefijo)Juntando esto, llegamos a nuestra primera consulta WDQS: SELECT ?hijo
WHERE
{
# ?hijo padre Bach
  ?hijo wdt:P22 wd:Q1339.
}
 Try it! Haz clic en el enlace \"Pruébalo\", luego \"Ejecutar\" la consulta en la página WDQS. ¿Qué obtienes? Hijo wd:Q57225 wd:Q76428 … Bueno, eso es decepcionante. Acabamos de ver un listado con los identificadores (Q). Puedes hacer clic en ellos para ver su página en Wikidata (incluida la etiqueta legible por humanos), pero ¿no hay una mejor manera de ver los resultados?Bueno, ¡claro que la hay! (¿no son geniales las preguntas retóricas?) Solo tienes que incluir el texto mágico. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, il servizio di query di Wikidata, è un potente strumento per accedere ai contenuti di Wikidata. Questa guida ti insegnerà come usarlo. Leggi anche il tutorial interattivo di Wikimedia Israele Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Prima di iniziare 2 SPARQL di base 3 La nostra prima query 3.1 Completamento automatico 4 Modelli di triple avanzate 5 Istanze e classi 5.1 Percorsi delle proprietà 6 Qualificatori 7 ORDER e LIMIT 7.1 Esercizio 7.1.1 Libri di Arthur Conan Doyle 7.1.2 Elementi chimici 7.1.3 Affluenti del Mississippi 7.1.4 Affluenti del Mississippi II 8 OPTIONAL 9 Espressioni, FILTER e BIND 9.1 Tipi di dati 9.2 Operatori 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Raggruppamento 10.1 Popolazioni delle città 10.2 Materiali per la pittura 10.3 Pistole per produttore 10.4 Editori per numero di pagine 10.4.1 HAVING 10.5 Riepilogo delle funzioni aggregatrici 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 E oltre… 14 Vedi anche Prima di iniziare Questa guida sembra molto lunga, forse addirittura intimidatoria. Per favore, non lasciare che ti spaventi! SPARQL è complicato, ma delle semplici basi già ti faranno fare molta strada – se vuoi, puoi smettere di leggere dopo #La nostra prima query, e ne saprai già abbastanza per scrivere molte query interessanti. Le sezioni successive aggiungono informazioni su questi argomenti che puoi usare per scrivere differenti query. Ognuna di esse ti darà la possibilità di scrivere query ancora più interessanti, ma nessuna di esse è indispensabile - puoi smettere di leggere in qualsiasi momento e avrai comunque utili informazioni!Se non hai mai sentito prima parlare di Wikidata, SPARQL o WDQS, ecco una breve spiegazione di questi termini: Wikidata è un database delle conoscenze. Contiene molte dichiarazioni come “la capitale del Canada è Ottawa”, o “La Gioconda è un dipinto a olio su tavola di legno di pioppo”, o “l'oro ha una capacità termica di 25 418 joule per mole-kelvin”. SPARQL è un linguaggio per formulare domande (query) per i database delle conoscenze. Con il giusto database, una query SPARQL può rispondere a domande come “qual è la tonalità più popolare nella musica?” o “quale personaggio è stato interpretato dal maggior numero di attori?” o “qual è la distribuzione del tipo di sangue?” o “quali opere e di quali autori sono entrate nel pubblico dominio quest'anno?”. WDQS, Wikidata Query Service, unisce i due insieme: tu immetti una query SPARQL, lui la esegue sul dataset di Wikidata e ti mostra il risultato.  SPARQL di base Una semplice query SPARQL ha il seguente aspetto: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clausola SELECT elenca le variabili che si desidera vengano restituite (le variabili iniziano con un punto interrogativo), e la clausola WHERE contiene restrizioni su di esse, principalmente sotto forma di triple. Tutte le informazioni in Wikidata (e database delle conoscenze simili) sono memorizzate sotto forma di triple; quando si esegue la query, il servizio query prova a compilare le variabili con i valori effettivi in modo che le triple risultanti vengano visualizzate come nel database della conoscenza, e restituisce un risultato per ciascuna combinazione di variabili che trova. Una tripla può essere letta come una frase (ecco perché termina con un punto), con un \"soggetto\", un \"predicato\" e un \"oggetto\": SELECT ?frutto
WHERE
{
  ?frutto haColore giallo.
  ?frutto haSapore aspro.
} I risultati per questa query potrebbero includere, ad esempio, \"limone\". In Wikidata, la maggior parte delle proprietà sono proprietà di tipo \"ha\", quindi la query si potrebbe leggere: SELECT ?frutto
WHERE
{
  ?frutto colore giallo.
  ?frutto sapore aspro.
} che si legge come “?frutto ha colore ‘giallo’” (non “?frutto è di colore ‘giallo’” – tienilo a mente per coppie di proprietà come “genitore”/“figlio”!).Tuttavia, questo non è un buon esempio per WDQS. Il gusto è soggettivo, quindi Wikidata non ha una proprietà per questo. Invece, pensiamo alle relazioni genitori/figli, che sono per lo più non ambigue. La nostra prima query Supponiamo di voler elencare tutti i figli del compositore barocco Johann Sebastian Bach. Usando pseudo-elementi come nelle query precedenti, come scriveresti quella query?Spero che tu abbia qualcosa del genere: SELECT ?figlio
WHERE
{
  #  figlio \"ha genitore\" Bach
  ?figlio genitore Bach.
  # (nota: ogni cosa dopo un ‘#’ è un commento ed è ignorato da WDQS.)
} o questo, SELECT ?figlio
WHERE
{
  # figlio \"ha padre\" Bach 
  ?figlio padre Bach. 
} o questo. SELECT ?figlio
WHERE
{
  #  Bach \"ha figlio\" figlio
  Bach figlio ?figlio.
} Le prime due triple dicono che il ?figlio deve avere come padre/genitore Bach; la terza dice che Bach deve avere il figlio ?figlio, Per ora esaminiamo il secondo.Quindi, cosa rimane da fare per trasformare questo in una query WDQS corretta? Su Wikidata, gli oggetti e le proprietà non sono identificati da nomi leggibili dall'utente umano come \"padre\" (proprietà) o \"Bach\" (elemento). (Per una buona ragione: \"Johann Sebastian Bach\" è anche il nome di un pittore tedesco e Bach potrebbe anche riferirsi al cognome, al comune francese, al cratere di Mercurio, etc.) Invece, agli oggetti e alle proprietà di Wikidata viene assegnato un identificatore. Per trovare l'identificatore di un oggetto, cerchiamo l'elemento e copiamo il numero-Q del risultato che sembra sia l'elemento più simile a quello che stiamo cercando (in base alla descrizione, ad esempio). Per trovare l'identificatore di una proprietà, facciamo lo stesso, ma cerchiamo “P:termine cercato” invece che solo “termine cercato”, questo limita la ricerca solo alle proprietà. Questo ci dice che il famoso compositore Johann Sebastian Bach è Q1339, e la proprietà per designare il padre di un oggetto è P:P22.E, ultimo ma non meno importante, abbiamo bisogno di includere dei prefissi. Per semplici triple WDQS, gli elementi devono essere preceduti da wd:, e le proprietà da wdt:. (Ma questo si applica solo ai valori fissi - le variabili non necessitano di un prefisso!)Mettendo insieme tutto questo, arriviamo alla nostra prima query WDQS corretta: SELECT ?figlio
WHERE
{
# ?figlio  padre   Bach
  ?figlio wdt:P22 wd:Q1339.
}
 Try it! Clicca su “Provalo” e poi “Esegui query” nella pagina WDQS. Che cosa ottieni? figlio wd:Q57225 wd:Q76428 … Beh, questo è deludente. Vedi solo gli identificatori. Puoi cliccare su di loro per vedere la corrispondente pagina Wikidata (inclusa un'etichetta leggibile dall'uomo), ma non c'è un modo migliore per vedere i risultati?Certo che sì! (Le domande retoriche non sono grandi?) Se includi il testo magico """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, el Servei de Consultes, és una eina per respondre preguntes que pugueu tenir, i aquesta guia us ajudarà a aprendre com utilitzar-lo. Vegeu també el tutorial interactiu de Wikimedia Israel.Abans d'escriure la vostra pròpia consulta d'SPARQL, reviseu {{Item documentation}} o qualsevol altra plàntilla de consulta SPARQL genèrica per veure si la vostra consulta ja hi ha estat inclosa. Contents 1 Abans de començar 2 Conceptes bàsics d'SPARQL 3 La nostra primera consulta 3.1 Autocompletat 4 Patrons avançats de ternes 5 Instàncies i classes 5.1 Rutes de propietats 6 Qualificadors 7 ORDER i LIMIT 7.1 Exercici 7.1.1 Llibres d'Arthur Conan Doyle 7.1.2 Elements químics 7.1.3 Rius que desemboquen al Mississippi 7.1.4 Rius que desemboquen al Mississippi II 8 OPTIONAL 9 Expressions, FILTER i BIND 9.1 Tipus de dades 9.2 Operadors 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupant 10.1 Població de ciutats 10.2 Materials de pintura 10.3 Armes per fabricant 10.4 Editorials per nombre de pàgines 10.4.1 HAVING 10.5 Resum de funcions d'agregació 10.6 wikibase: Etiquetes i agregacions 11 VALUES 12 Label in multiple languages 13 I més enllà… 14 Vegeu també Abans de començar Aquesta guia pot semblar llarga, tant que potser intimida. No us espanteu! L'SPARQL és complicat, però només amb els conceptes bàsics ja es pot anar força lluny. Si voleu, podeu deixar de llegir després de la nostra primera consulta i ja podreu escriure moltes consultes interessants. Les seccions que venen a continuació d'això només afegeixen informació sobre altres elements que podeu utilitzar per escriure consultes diferents. Cadascuna d'aquestes seccions us capacitarà per escriure consultes encara més potents, però cap d'elles és necessària: podeu deixar de llegir en qualsevol moment i, tot i així, disposareu de molts coneixements útils.Si no heu sentit mai a parlar de Wikidata, SPARQL o WDQS, aquí en teniu una explicació breu: Wikidata és una base de dades de coneixement. Conté molts fets, com ara que «la capital de Canadà és Ottawa», o que «la Mona Lisa fou pintada a l'oli en una fusta de pollancre», o que «l'or té una conductivitat tèrmica de 25.418 joules per mol kelvin». L'SPARQL és un llenguatge per formular consultes a bases de dades de coneixement. Amb la base de dades correcta, una consulta SPARQL podria preguntar qüestions com ara “quina és la tonalitat musical més popular?” o “quin personatge ha estat interpretat per més actors?” o “quina és la distribució de tipus de sang?” o “quines obres d'autor han entrat en el domini públic enguany?”. WDQS, el Servei de Consulta de Wikidata ajunta les dues coses: en definir una consulta SPARQL, el servei l'executa usant les dades de Wikidata, mostrant-ne el resultat.  Conceptes bàsics d'SPARQL Una consulta senzilla en SPARQL s'assembla a això: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clàusula SELECT llista les variables que volem consultar (les variables comencen amb un signe d'interrogació) i la clàusula WHERE conté les restriccions que hi volem aplicar, en forma de ternes. Tota la informació de Wikidata (i d'altres bases de dades de coneixement similars) està desada en forma de ternes; quan executem la consulta, el servei de consultes intenta emplenar les variables amb valors reals existents a la base de dades, tornant un resultat per a cada combinació de variables que troba.Una terna es pot considerar com dos vèrtexs (és a dir, 2 nodes, 2 recursos) connectats per una aresta (un arc, una propietat) dins del vast multigràfic de propietats directe (orientat) que forma Wikidata. Es pot llegir com una frase (per això s'acaba amb un punt), amb un «subjecte», un «predicat» i un «complement directe». SELECT ?fruita
WHERE
{
  ?fruita ésDeColor groc.
  ?fruita téGust agre.
} El resultat d'aquesta consulta pot incloure, per exemple, «llimona». A Wikidata, la majoria de propietats assumeixen que els ítems «tenen» propietats, pel què la consulta podria ser: SELECT ?fruita
WHERE
{
  ?fruita color groc.
  ?fruita gust agre.
} el que es pot llegir com “?fruita té color ‘groc’” (no “?fruita és de color ‘groc’” – tinguem això present per a propietats com “pare”/“fill”!).Tot i això, aquest no és un bon exemple de WDQS. El gust és subjectiu, així que Wikidata no en té una propietat. En canvi, observem la relació pare/fill, que és menys ambigua. La nostra primera consulta Suposem que volem llistar tots els fills del compositor barroc Johann Sebastian Bach. Utilitzant psèudo-elements com a les consultes anteriors, com escriuríem la consulta?Amb sort, aconseguirem una cosa així: SELECT ?fill
WHERE
{
  #  fill «té pare» Bach
  ?fill pare Bach.
  # (Nota: tot el que hi ha darrere d'un ‘#' és un comentari i WDQS ho ignora.)
} o això, SELECT ?fill
WHERE
{
  # fill «té pare» Bach 
  ?fill pare Bach. 
} o això, SELECT ?fill
WHERE
{
  #  Bach «té fill» fill
  Bach fill ?fill.
} Les dues primeres ternes diuen que ?fill ha de tenir Bach com a pare; la tercera diu que Bach ha de tenir el fill ?fill. Per ara i tant, quedem-nos amb la segona.Aleshores, què falta per a convertir això en una consulta vàlida de WDQS? A Wikidata, els ítems i les propietats no s'identifiquen amb noms llegibles-pels-humans com «pare» (una propietat) o «Bach» (un ítem). (I per una bona raó: «Johann Sebastian Bach» també és el nom d'un pintor alemany, i «Bach» també es podria referir al cognom, la comuna francesa, el cràter de Mercuri, etc). En canvi, els ítems i propietats de Wikidata tenen assignades un identificador. Per a trobar l'identificador d'un ítem, fem una cerca de l'ítem i en copien el número Q de l'ítem que coincideixi amb el que estem buscant (per exemple, basant-nos en la descripció). Per trobar l'identificador d'una propietat fem el mateix, però cercant amb «P:terme» amb el que ampliem la cerca a les propietats. Això ens diu que el famós compositor Johann Sebastian Bach és Q1339 i que la propietat per a designar el pare d'un ítem és la P:P22.Finalment, però no per això menys important, necessitem incloure prefixos. Per ternes senzilles de WDQS, els elements s'haurien de prefixar amb wd:, i les propietats amb wdt:. (Però això només s'aplica als valors fixos, les variables no porten prefix!)I, així, arribem a la nostra primera consulta WDQS: SELECT ?fill
WHERE
{
# ?fill  pare   Bach
  ?fill wdt:P22 wd:Q1339.
}
 Try it! Feu clic a l'enllaç «Proveu-ho» i després «Executeu» la consulta a la pàgina de WDQS. Què obteniu? fill wd:Q57225 wd:Q76428 … Bé, això és decebedor. Només veieu els identificadors. Si hi feu clic, anireu a la seva pàgina de Wikidata (on hi ha una etiqueta entenedora pels humans), però no hi ha una forma millor de veure els resultats?Resulta que sí que n'hi ha una (oi que les preguntes retòriques són genials?), si hi incloeu el text màgic """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidatas frågetjänst, är ett kraftfullt verktyg som erbjuder insyn i Wikidatas innehåll. Denna guide lär dig hur man använder den. Se även Wikimedia Israels interaktiva guide.Innan du skriver din egen SPRAQL-sökfråga, ta en titt på {{Item documentation}} eller någon annan generisk SPARQL-sökfrågemall och se om din sökfråga redan finns där. Contents 1 Innan vi börjar 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Datatyper 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Se även Innan vi börjar While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, der Wikidata Query Service, ist ein leistungsfähiges Werkzeug, das dir Einblick in die Inhalte von Wikidata verschafft. In diesem Tutorial lernst du, wie du den WDQS benutzen kannst. Siehe auch das interaktive Tutorial von Wikimedia Israel.Bevor du deine eigene SPARQL-Abfrage schreibst, schaue nach, ob deine Abfrage bereits in {{Item documentation}} oder den anderen SPARQL-Beispielvorlagen enthalten ist. Contents 1 Bevor wir beginnen 2 SPARQL-Basics 3 Unsere erste Abfrage 3.1 Autovervollständigung 4 Fortgeschrittene Tripelmuster 5 Instanzen und Klassen 5.1 Eigenschaftspfade 6 Qualifikatoren 7 ORDER und LIMIT 7.1 Übung 7.1.1 Bücher von Arthur Conan Doyle 7.1.2 Chemische Elemente 7.1.3 Flüsse, die in den Mississippi fließen 7.1.4 Flüsse, die in den Mississippi fließen II 8 OPTIONAL 9 Ausdrücke, FILTER und BIND 9.1 Datentypen 9.2 Operatoren 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Gruppierung 10.1 Einwohnerzahlen von Städten 10.2 Gemäldematerialien 10.3 Waffen nach Hersteller 10.4 Verlage nach Seitenanzahl 10.4.1 HAVING 10.5 Zusammenfassung der Aggregat-Funktionen 10.6 wikibase:Label und Aggregat 11 VALUES 12 Label in multiple languages 13 Und darüber hinaus… 14 Siehe auch Bevor wir beginnen Auch wenn dieser Leitfaden lang und einschüchternd wirkt, lass dich davon nicht abschrecken! Alleine mit den SPARQL-Grundlagen kommst du schon sehr weit. Wenn du nach #Unsere erste Abfrage aufhörst, wirst du schon genug wissen, um viele interessante Abfragen zu erstellen. Mit jedem weiteren Kapitel wirst du in der Lage sein, noch umfangreichere Abfragen zu schreiben.Du hast noch nie von Wikidata, SPARQL oder WDQS gehört? Hier eine kurze Erklärung dieser Begriffe: Wikidata ist eine Wissensdatenbank. Sie enthält Millionen von Aussagen wie zum Beispiel „Die Hauptstadt von Kanada ist Ottawa” oder „Die Mona Lisa wurde mit Ölfarbe auf Pappelholz gemalt” oder „Gold hat einen Schmelzpunkt von 1064,18 Grad Celsius”. SPARQL ist eine Sprache, um Abfragen (Queries) für Wissensdatenbanken zu formulieren. Mit der richtigen Datenbank kann eine SPARQL-Abfrage Fragen wie “Was ist die beliebteste Tonart in der Musik?” oder “Welche Rolle wurde von den meisten Schauspielern gespielt?” oder “Wie ist die Verteilung von Blutgruppen?” oder “Welche Werke von Autoren sind in diesem Jahr frei zugänglich geworden?” beantworten. WDQS, der Wikidata Query Service, bringt diese beiden Dinge zusammen: Du gibst eine SPARQL-Abfrage ein, sie durchsucht die Wikidata-Datensätze und zeigt dir das Resultat.  SPARQL-Basics Eine einfache SPARQL-Abfrage sieht so aus: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Unter SELECT werden die Variablen aufgeführt, die du als Ausgabe haben willst (Variablen beginnen mit einem Fragezeichen) und unter WHERE steht, worauf sie eingeschränkt werden sollen, meistens in Form von Tripeln. Alle Informationen in Wikidata (und ähnlichen Wissensdatenbanken) sind in Tripeln gespeichert. Wenn du die Abfrage durchführst, versucht der Query Service, die Variablen so mit tatsächlichen Werten zu füllen, dass der Tripel in der Wissensdatenbank vorkommt. Zurückgegeben wird dann ein Resultat für jede Kombination von Variablen, die gefunden wird.Ein Tripel kann man wie einen Satz lesen (deshalb endet es auch mit einem Punkt): Es hat ein „Subjekt“, ein „Prädikat“ und ein „Objekt“. Und er hört mit einem Punkt auf. SELECT ?frucht
WHERE
{
  ?frucht hatFarbe gelb.
  ?frucht schmeckt sauer.
} Das Resultat dieser Abfrage könnte zum Beispiel “Zitrone” enthalten. In Wikidata sind die meisten Eigenschaften “hat”-Eigenschaften; die Abfrage sieht somit folgendermaßen aus: SELECT ?frucht
WHERE
{
  ?frucht farbe gelb.
  ?frucht geschmack sauer.
} ... was sich folgendermaßen liest: “?frucht hat farbe ‘gelb’” (nicht “?frucht ist die Farbe von ‘gelb’”. Merk dir das für Eigenschafts-Paare wie “eltern”/“kind”!).Das ist jedoch kein gutes Beispiel für WDQS. Geschmack ist subjektiv, also hat Wikidata dafür keine Eigenschaft. Reden wir stattdessen über Eltern-/Kind-Beziehungen nachdenken, diese sind meistens eindeutig. Unsere erste Abfrage Angenommen wir möchten alle Kinder des Barock-Komponisten Johann Sebastian Bach auflisten. Wie würdest du diese Abfrage schreiben, wenn du Pseudo-Elemente wie im Beispiel oben verwendest?Es sollte etwas in dieser Art sein: SELECT ?kind
WHERE
{
  #  kind \"hat Elternteil\" Bach
  ?kind elternteil Bach
  # (Hinweis: alles nach einem „#“ ist ein Kommentar und wird vom WDQS ignoriert.)
} oder das: SELECT ?kind
WHERE
{
  # kind \"hat Vater\" Bach 
  ?kind vater Bach 
} oder das: SELECT ?kind
WHERE
{
  #  Bach \"hat Kind\" Kind
  Bach unterelement ?kind.
} Die ersten beiden Tripel sagen: ?kind muss den Elternteil/Vater Bach haben; das dritte sagt, dass Bach das Kind ?kind haben muss. Fangen wir erst einmal mit dem zweiten an:Was müssen wir also noch machen, um daraus eine richtige WDQS-Abfrage zu machen? In Wikidata sind Objekte und Eigenschaften nicht mit für Menschen verständlichen Namen wie “Vater” (Eigenschaft) oder “Bach” (Gegenstand) bezeichnet. (Aus gutem Grund: “Johann Sebastian Bach” ist auch der Name eines Deutschen Malers und “Bach” könnte auch ein Vorname, eine Französische Gemeinde, ein Krater auf dem Merkur usw. sein.) Stattdessen teilt Wikidata jedem Objekt und jeder Eigenschaft einen Identifikator zu. Um den Identifikator eines Objekts zu finden, suchen wir das Objekt und kopieren die Q-Nummer des Resultates, welches uns passend erscheint (zum Beispiel aufgrund der Beschreibung). Um den Identifikator für eine Eigenschaft zu finden, machen wir es genauso, suchen aber nach „P:Suchbegriff” statt nur „Suchbegriff”, was unsere Suche auf Eigenschaften beschränkt. Das sagt uns dann, dass der berühmte Komponist Johann Sebastian Bach Q1339 ist und die Eigenschaft, um den Vater eines Gegenstandes zu bestimmen, ist P:P22.Zum Schluss müssen wir noch Präfixe einbinden. Bei einfachen WDQS-Triples sollte Objekten das Präfix wd: und Eigenschaften das Präfix wdt: vorangestellt werden. (Das betrifft aber nur feste Werte, Variablen bekommen kein Präfix!)Zusammengenommen erhalten wir unsere erste richtige WDQS-Abfrage: SELECT ?kind
WHERE
{
# ?kind vater Bach
  ?kind wdt:P22 wd:Q1339.
}
 Try it! Klicke auf den Link „Versuche es” und dann „Abfrage ausführen” auf der WDQS-Seite. Was ist das Ergebnis? kind wd:Q57225 wd:Q76428 … Das Ergebnis ist enttäuschend: Du siehst nur die Identifikatoren der Ergebnisse. Du kannst auf diese Identifikatoren klicken und die dazugehörige Wikidata-Seite (mit verständlichen Beschriftungen) öffnen. Aber kann man die Ergebnisse nicht besser anzeigen?Nun, tatsächlich, das kannst du! (Sind rhetorische Fragen nicht großartig?) Indem du die Zauberworte """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 Сервис запросов Викиданных (WDQS, Wikidata Query Service) – мощный инструмент, позволяющий работать с содержимым Викиданных. Данное руководство расскажет, как работать с этим сервисом. См. также интерактивное руководство от Wikimedia Israel.Перед тем как написать свой собственный запрос SPARQL, посмотрите на шаблон {{Item documentation}} или любой другой шаблон запроса SPARQL и посмотрите, не включён ли уже туда ваш запрос. Contents 1 Перед началом 1.1 Основы SPARQL 2 Ваш первый запрос 2.1 Автозаполнение 3 Advanced triple patterns 4 Частные случаи и классы 4.1 Property paths 5 Квалификаторы 6 ORDER and LIMIT 6.1 Упражнение 6.1.1 Книги Артура Конан Дойля 6.1.2 Химические элементы 6.1.3 Реки, впадающие в Миссисипи 6.1.4 Rivers that flow into the Mississippi II 7 OPTIONAL 8 Expressions, FILTER and BIND 8.1 Типы данных 8.2 Операторы 8.3 FILTER 8.4 BIND, BOUND, IF 8.5 COALESCE 9 Группирование 9.1 Население города 9.2 Painting materials 9.3 Guns by manufacturer 9.4 Publishers by number of pages 9.4.1 HAVING 9.5 Aggregate functions summary 9.6 wikibase:Label and aggregations 10 VALUES 11 Label in multiple languages 12 И далее… 13 См. также Перед началом Хотя это руководство может показаться очень длинным и пугающим, не позвольте этому вас отпугнуть! Простое изучение основ SPARQL поможет вам пройти долгий путь — даже если вы перестанете читать после вашего первого запроса, вы уже будете понимать достаточно, чтобы построить много интересных запросов. Каждый раздел этого руководства даст вам возможность писать еще более мощные запросы.Если вы никогда прежде не слышали о Викиданных, SPARQL или WDQS, вот краткое описание этих понятий: Викиданные — это база знаний. Она содержит миллионы таких утверждений, как, например, «столицей Канады является Оттава», «„Мона Лиза“ написана масляными красками по тополю» или «золото имеет температуру плавления 1064,18 градусов Цельсия». SPARQL — это язык формулировки вопросов (запросов) к базам знаний. При обращении к подходящей базе запрос SPAQRL может дать ответы на такие вопросы, как «Какая самая распространённая музыкальная тональность?», «Какого персонажа играло наибольшее количество актёров?», «Каково распределение групп крови?» или «Произведения каких авторов перешли в общественное достояние в этом году?». WDQS, Wikidata Query Service (Сервис запросов Викиданных), совмещает их: вы вводите запрос SPARQL, сервис обращается с ним к содержимому Викиданных и показывает вам результат.  Основы SPARQL Простой SPARQL-запрос выглядит следующим образом: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} В секции SELECT перечислены переменные, которые вы хотите получить в результате запроса (переменные начинаются со знака вопроса). В секции WHERE содержатся условия, уточняющие их, в основном в виде троек. Вся информация в Викиданных (и аналогичных базах данных знаний) хранится в виде троек; когда вы запускаете запрос, служба запроса пытается заполнить переменные фактическими значениями, чтобы получаемые тройки присутствовали в базе данных знаний, и возвращает один результат для каждой комбинации переменных, которую она находит. Тройку можно рассматривать как предложение (поэтому она заканчивается точкой), содержащее \"субъект\", \"предикат\" и \"объект\": SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Результаты этого запроса могут включать, например, «лимон». В Викиданных большинство свойств подразумевают «имеет», так что запрос можно прочитать так: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} который читается как \"?fruit\" имеет цвет \"жёлтый\" (но не \"?fruit\" есть цвета \"желтого\" - имейте это в виду, пары свойств похожи как сотношение \"родители\"/\"дети\"!).Однако это не хороший пример для WDQS. Вкус субъективен, поэтому Викиданные не имеют такого свойства. Вместо этого, давайте подумаем об отношениях родители/дети, которые в основном однозначны. Ваш первый запрос Предположим, мы хотим получить список всех детей композитора эпохи барокко Иоганна Себастьяна Баха. При использовании псевдоэлементов, как в запросах выше, как бы вы составили такой запрос?Надеемся у вас получилось что-то вроде этого: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (Примечание: текст после символа \"#\" - это комментарий и игнорируется WDQS.)
} или этого: SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} или этого: SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} Первые два триплета говорят, что у ?child должен быть родитель/отец Бах; третий говорит, что у Баха должен быть ребенок ?child. Давайте присмотримся ко второму.Итак, что еще нужно сделать, чтобы превратить это в правильный запрос WDQS? На Викиданных элементы и свойства не обозначаются человекочитаемыми именами, такими как \"отец\" (свойство) или \"Бах\" (элемент). (по уважительной причине: \"Иоганн Себастьян Бах\" это и имя немецкого художника, и фамилия, и французская коммуна, и кратер Меркурия и т. д.) Вместо этого, элементам и свойствам в Викиданных присваивается идентификатор. Чтобы найти идентификатор для элемента мы ищем элемент и копируем Q-номер результата, описание которого походит на элемент, который мы ищем. Чтобы найти идентификатор для свойства, мы делаем то же самое, но ищем \"P:search term\" вместо просто \"search term\" (соответственно, \"P:отец\" и \"Бах\"), что ограничивает поиск именно поиском в свойствах. В результате узнаём, что знаменитый композитор Иоганн Себастьян Бах имеет код Q1339, а свойство для обозначения отца предмета - это P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service (Служба запитів Вікіданих) – це потужний інструмент для надання інформації про вміст Вікіданих. Цей підручник навчить вас, як користуватися WDQS. Див. також інтерактивний підручник від Wikimedia Israel.Перш ніж писати свій власний запит SPARQL, подивіться {{Item documentation}} або будь-який інший типовий шаблон запиту SPARQL і подивіться, чи ваш запит уже включено. Contents 1 Перед тим, як почати 2 Основи SPARQL 3 Наш перший запит 3.1 Автозавершення 4 Удосконалені схеми триплетів 5 Екземпляри й класи 5.1 Шляхи властивостей 6 Кваліфікатори 7 ORDER і LIMIT 7.1 Вправа 7.1.1 Книги Артура Конана Дойла 7.1.2 Хімічні елементи 7.1.3 Річки, що впадають у Міссісіпі 7.1.4 Річки, що впадають у Міссісіпі II 8 OPTIONAL 9 Вирази, FILTER і BIND 9.1 Типи даних 9.2 Оператори 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Групування 10.1 Міське населення 10.2 Матеріал для картин 10.3 Вогнепальна зброя за виробником 10.4 Видавці за кількістю сторінок 10.4.1 HAVING 10.5 Огляд агрегатних функцій 10.6 wikibase:Назви й агрегації 11 VALUES 12 Label in multiple languages 13 А далі… 14 Див. також Перед тим, як почати Хоча цей посібник може виглядати дуже довгим і складним, будь ласка, не дозволяйте цьому лякати вас! Просто вивчивши основи SPARQL, ви пройдете довгий шлях - навіть якщо ви перестанете читати після нашого першого запиту, ви вже зрозумієте достатньо, щоб створити багато цікавих запитів. Кожен розділ цього підручника дозволить вам писати ще потужніші запити.Якщо ви ніколи раніше не чули про Вікідані, SPARQL або WDQS, ось коротке пояснення цих термінів: Вікідані – це база даних знань. Вона містить мільйони тверджень, наприклад, «столиця Канади — Оттава», «Мона Ліза намальована олійною фарбою на дереві тополі», або «золото має температуру плавлення 1064,18 градуса за Цельсієм». SPARQL – це мова для формулювання питань (запитів) до баз даних знань. Для правильної бази даних запит SPARQL міг би відповісти на такі запитання, як \"яка найпопулярніша тональність у музиці?\" або \"який персонаж був зображений більшістю акторів?\" або \"який розподіл груп крові?\" або \"роботи яких авторів перейшли у суспільне надбання цього року?\". WDQS, служба запитів Вікіданих, об’єднує їх разом: ви вводите запит SPARQL, служба запускає його з набором даних Вікіданих та показує вам результат.  Основи SPARQL Простий запит SPARQL виглядає так: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Пункт SELECT перераховує змінні, які ви хочете повернути (змінні починаються із знака питання), а пункт WHERE містить обмеження на них, переважно у формі триплетів. Уся інформація у Вікіданих (і аналогічних базах даних знань) зберігається у вигляді триплетів; коли ви запускаєте запит, служба запитів намагається заповнити змінні фактичними значеннями, так, як отримані триплети з'являються в базі знань, і повертає один результат для кожної комбінації змінних, які вона знаходить.Триплет можна розглядати як дві вершини (псевдоніми — два вузли, два ресурси), з’єднані ребром (дугою, властивістю) всередині величезного орієнтованого (спрямованого) мультиграфа властивостей, який утворює Вікідані. Його можна читати як речення (тому він закінчується крапкою), з суб'єктом (підметом, subject), предикатом (присудком, predicate) і об'єктом (додатком, object): SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Результати для цього запиту можуть включати, наприклад, «лимон». У Вікіданих більшість властивостей є властивостями типу «має» («has»), тому запит можна читати навпаки: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} який читається як «?fruit має колір 'yellow'» (не «?fruit є колір 'yellow'» – майте це на увазі для таких пар властивостей, як «батько»/«дитина»!).Однак це не дуже хороший приклад для WDQS. Смак суб’єктивний, тому Вікідані не мають властивостей для нього. Натомість давайте подумаємо про відношення між батьками та дітьми, які переважно однозначні. Наш перший запит Припустимо, ми хочемо скласти список усіх дітей барокового композитора Йоганна Себастьяна Баха. Використовуючи псевдоелементи, як у запитах вище, як би ви написали цей запит?Сподіваємось, у вас є щось на зразок цього: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (примітка: все після ‘#’ є коментарем й ігнорується у WDQS.)
} або цього SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} або цього SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Натисніть посилання \"Виконати!\", потім \"Виконати запит\" на сторінці WDQS. Що ви отримуєте? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Zanim zaczniemy 2 Podstawy SPARQL 3 Our first query 3.1 Autouzupełnianie 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Kwalifikatory 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Pierwiastki chemiczne 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Typy danych 9.2 Operatory 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Zobacz też Zanim zaczniemy While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result.  Podstawy SPARQL A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?owoc
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?owoc
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?dziecko
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?dziecko
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?dziecko
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?dziecko
WHERE
{
# ?child  father   Bach
  ?dziecko wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? dziecko wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds.A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, le Wikidata Query Service (service de requête de Wikidata), est un outil puissant pour fournir un aperçu du contenu de Wikidata. Ce guide vous apprendra à l'utiliser. Voir aussi le tutoriel interactif par Wikimedia Israël.Avant de rédiger votre propre requête SPARQL, prenez le temps de regarder {{Item documentation}} ou toute autre requête générique avec modèle et voir si votre requête n'existe pas déjà. Contents 1 Avant de commencer 2 Les bases de SPARQL 3 Notre première requête 3.1 Auto-complétion 4 Motifs de triplets avancés 5 Classes et instances 5.1 Chemins de propriétés 6 Qualificatifs 7 ORDER et LIMIT 7.1 Exercice 7.1.1 Les livres d'Arthur Conan Doyle 7.1.2 Éléments chimiques 7.1.3 Les rivières qui se jettent dans le Mississippi 7.1.4 Les rivières qui se jettent dans le Mississippi II 8 OPTIONAL 9 Expressions, FILTER et BIND 9.1 Types de données 9.2 Opérateurs 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Groupement 10.1 Populations des villes 10.2 Matériaux de peinture 10.3 Fusils par fabricant 10.4 Editeurs par nombre de pages 10.4.1 HAVING 10.5 Sommaire des fonctions d’agrégation 10.6 wikibase:Label et agrégations 11 VALUES 12 Libellé en plusieurs langues 13 Et plus loin… 14 Voir aussi Avant de commencer Ce guide peut sembler très long et intimidant. Ne soyez pas effrayé ! Acquérir les bases de SPARQL va déjà vous permettre de faire pas mal de chemin — même si vous vous arrêter de lire après #Notre première requête, vous en saurez assez pour écrire de nombreuses requêtes intéressantes. Chaque section de cette page vous outille pour écrire encore plus de questions formidables.Si vous n'avez jamais entendu parler de Wikidata, SPARQL ou WDQS jusqu'à maintenant, voici une courte explication de ces mots : Wikidata est une base de connaissances. Cette base contient de nombreuses affirmations/déclarations, comme « la capitale du Canada est Ottawa » ou « la Joconde est peinte avec de la peinture à l'huile sur du bois de peuplier » ou encore « l'or a un point de fusion de 1 064,18 degrés Celsius ». SPARQL est un langage pour formuler des questions (requêtes) dans une base de connaissance. Avec la bonne base, une requête SPARQL peut répondre à des questions comme « quelle est la tonalité la plus populaire en musique? » ou « quel est le personnage qui a été le plus joué par des acteurs ou actrices ? » ou « quelle est la distribution des groupes sanguins? » or « quelles sont les œuvres d'auteur qui entrent dans le domaine public cette année? » WDQS, le service de requête Wikidata, joint les deux précédents : vous entrez une requête SPARQL, et elle s'exécute sur l'ensemble des données de Wikidata et vous montre le résultat.  Les bases de SPARQL Une requête SPARQL simple se présente ainsi : SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clause SELECT liste les variables que vous voulez renvoyer (les variables commencent avec un point d'interrogation) et la clause WHERE contient des restrictions sur ces variables, principalement sous la forme de triplets ; quand vous exécutez la requête, le service de requête essaye de combiner les variables avec les valeurs courantes de telle manière que les triplets résultant de ce remplissage soient présents dans la base de connaissances, et renvoie un résultat pour chaque combinaison de variables que le service trouve.Un triplet peut être vu comme représentant deux sommets (i.e. 2 noeuds, 2 ressources) connectés par une arête ou arc (une propriété) à l'intérieur du vaste multigraphe de propriétés orienté que constitue Wikidata. - Il peut être lu comme une phrase (qui se termine avec un point), avec un sujet, un prédicat et un objet. Les termes en anglais sont : subject, predicate, and object : SELECT ?fruit
WHERE
{
  ?fruit aCouleur jaune.
  ?fruit goût acide.
} Les résultats pour cette question peuvent inclure, par exemple, \"citron\". Dans Wikidata, la plupart des propriétés sont de type \"a le/la\" (en anglais : “has”-kind properties), ainsi la requête pourrait aussi être lue : SELECT ?fruit
WHERE
{
  ?fruit couleur jaune.
  ?fruit goût aigre.
} qui se lit comme “?fruit a la couleur ‘jaune’” (et non pas “?fruit est la couleur de ‘jaune’” – gardez cela en tête pour les paires de propriétés comme “parent”/“enfant”!).Cependant, ce n'est pas un bon exemple pour WDQS. Les goûts sont subjectifs, aussi Wikidata n'a pas de propriété pour cela. Laissons cela de côté, et intéressons-nous aux relations parent/enfant, qui sont généralement non-ambigües. Notre première requête Supposons que nous voulions la liste de tous les enfants du compositeur baroque Jean-Sébastien Bach. En utilisant les pseudo-éléments comme dans les requêtes ci-dessus, comment écririez-vous la requête ?Avec un peu de chance, vous obtenez quelque chose comme cela : SELECT ?enfant
WHERE
{
  #  enfant \"a pour parent\" Bach
  ?enfant parent Bach.
  # (note : tout ce qui se trouve après un « # » est un commentaire de code et est ignoré par WDQS.)
} ou ceci, SELECT ?enfant
WHERE
{
  # enfant \"a pour père\" Bach 
  ?enfant père Bach. 
} ou ceci, SELECT ?enfant
WHERE
{
  #  Bach \"a pour enfant\" enfant
  Bach enfant ?enfant.
} Les deux premiers triplets disent que la variable ?enfant doit avoir le 'parent/père' Bach ; le troisième triplet dit que Bach doit avoir un enfant avec une variable ?enfant. Allons-y avec le deuxième pour l'instant.Que reste-t-il à faire pour transformer cela en une requête WDQS correcte ? Dans Wikidata, les éléments et les propriétés ne sont pas identifiés par des noms lisibles par des humains tel que \"père\" (propriété) ou \"Bach\" (élément). (Pour de bonnes raisons : \"Johann Sebastian Bach\" est aussi le nom d'un peintre allemand et \"Bach\" peut aussi faire référence au nom de famille, à la commune française, au cratère sur Mercure, etc.) Au lieu de cela, éléments et propriétés de Wikidata sont affectés à un identifiant. Pour trouver l'identifiant d'un élément, nous cherchons cet élément et nous copions le Q-nombre qui semble être celui de l'élément que nous cherchons (en nous basant sur la description, par exemple). Pour trouver l'identifiant d'une propriété, nous faisons la même chose mais en cherchant “P:terme cherché” au lieu de “terme cherché”, ce qui limite la recherche aux propriétés. Ceci nous apprend que le fameux compositeur Jean-Sébastien Bach est Q1339 et que la propriété pour désigner le père d'un élément est P:P22.Enfin, nous avons besoin d'inclure les préfixes. Pour des triplets WDQS de base, les éléments doivent être préfixés avec wd: et les propriétés avec wdt:. (Mais ceci ne s'applique qu'aux valeurs - les variables n'ont pas de préfixe !)En mettant tout cela ensemble, nous arrivons à notre première requête WDQS correcte : SELECT ?enfant
WHERE
{
# ?enfant père Bach
  ?enfant wdt:P22 wd:Q1339.
}
 Try it! Cliquez sur le lien « Essayez ! » puis « lancez » la requête sur la page WDQS. Qu'obtenez-vous ? enfant wd:Q57225 wd:Q76428 … Bon c'est décevant. Vous ne voyez que les identifiants. Vous pouvez cliquer dessus pour voir leur page Wikidata (incluant un libellé lisible par les humains), mais n'y a-t-il pas une meilleure manière de voir les résultats ?Et bien, comme nous allons le voir, c'est possible ! (N'est-ce pas que c'est génial de se poser des questions rhétoriques ?) Si vous incluez le texte magique """@en;
  dcterms:isPartOf <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/lb>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/he>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/nl>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/szl>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/en-gb>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/zh>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/et>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/pt-br>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/hy>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/tr>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/id>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/da>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ar>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ja>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/es>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/it>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ca>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/sv>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/de>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ru>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/uk>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/pl>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/en>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/fr>;
  dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/>;
  sh:prefixes _:wikidata_prefixes, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-wikidata_prefixes,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-D0DAD27E88B593CFEC061049CD14D1D2, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-F72F3A21AE41BD34BF60DA8B9F9DA9CB,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-81667F17B3D16984A567B3F015A0393A, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-476AB0E41E3C7EF9F2C375A61163D7F5,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-136FED77FAB31D43021C0AFE861435B6, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-8E48956D3A8F02FDA9EBAAA36C16EBFA,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-15982F5A0AFEB2803DBDB9CC44A0146D, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-E6262B8A5FFB0F2D00A394BA4508DD67,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-A39AF48F3EFE284F4F766376DB767289, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-B544F4FB58320C5D353ECBE96DBA6E0F,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-6F83F50B935AF131243101CA4DEBD45F, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-4CB9462AAA2A886D6181617DC32E4949,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-B13A70363CE9565A113734BA34C2D2F8, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-118273C39E53F16AA62C0DFF46A21191,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-66669C5B134472CD2E9C65199DFD4CB3, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-C63C9F1F1B2DFF99A33AB04BF198A609,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-3165A70C3FFD2A42163D13698F130839, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-2A9B90D43B831CF484DDFCD0026469EE,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-40EE23DAC54EC611152F7948CFBE6961, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-6F4CBED216946F3AD6E6AF379F9787D0,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-97E5461C9B3493FE6DC42252FBC285CC, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-2615FD4CF8FF95F46E25D4688E3D9DFF,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-E1E0C7B18CEBC5CC9989C635112F0988, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec126431-A95D935875DB04A79C50B550F04F7D98;
  schema:target <https://query.wikidata.org/sparql/> .

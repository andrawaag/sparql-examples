@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix schema: <https://schema.org/> .

<https://www.wikidata.org/#query-a7909808dd28ead45ac0163fd2ea3c1a> a sh:SPARQLExecutable;
  rdfs:comment """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instanzen a Klassen 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercice 7.1.1 Arthur Conan Doyle books 7.1.2 Cheemesch Elementer 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natierlech Sprooch Beispill SPARQL Beispill Saz Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. Komma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ].  Instanzen a Klassen Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, שירות התשאול של ויקינתונים, הוא כלי רב עוצמה להפקת תובנות לפי התוכן של ויקינתונים. המדריך הזה ילמד אותך איך להשתמש בו. ר׳ גם את המדריך האינטראקטיבי של ויקימדיה ישראל.לפני שנכתוב שאילתת SPARQL משלך, כדאי להסתכל על {{Item documentation}} או על כל תבנית שאילתת SPARQL כללית אחרת ולראות אם השאילתה הנחוצה לך כבר שם. Contents 1 לפני שנתחיל 2 יסודות SPARQL 3 השאילתה הראשונה שלנו 4 השלמה אוטומטית 5 תבניות שלישיות מתקדמות 6 מופעים ומחלקות 6.1 נתיבי מאפיינים 7 מבחינים 8 ORDER ו־LIMIT (סידור והגבלה) 8.1 תרגול 8.1.1 ספרים של ארתור קונאן דויל 8.1.2 יסודות כימיים 8.1.3 נחלים שזורמים לתוך נהר המיסיסיפי 8.1.4 נחלים שזורמים לתוך נהר המיסיסיפי 2 9 OPTIONAL (רשות) 10 ביטויים, FILTER ו־BIND (סינון ואיגוד) 10.1 טיפוסי נתונים 10.2 פעולות 10.3 FILTER (סינון) 10.4 BIND,‏ BOUND,‏ IF (איגוד, תיחום, ברירה) 10.5 COALESCE (החזרת הערך התקין מבין האפשרויות) 11 קיבוץ 11.1 אוכלוסיות עירוניות 11.2 חומרי ציור 11.3 אקדחים לפי יצרן 11.4 מוציאים לאור לפי מספר דפים 11.4.1 HAVING (שיש לו) 11.5 סיכום על פונקציות כינוס 11.6 wikibase:Label וכינוסים 12 VALUES (ערכים) 13 Label in multiple languages 14 ועוד הרבה מעבר… 15 ר׳ גם לפני שנתחיל למרות שהמדריך הזה נראה ארוך ומאיים, אין סיבה לחשוש! למידת היסודות של SPARQL תיקח אותך הרחק - אפילו אם בחרת להפסיק לקרוא אחרי #השאילת הראשונה שלנו, כבר תתגבש אצלך הבנה מספקת להרכבת מגוון רחב של שאילתות מעניינות. כל סעיף במדריך הזה יעשיר אותך בכתיבת שאילתות יותר ויותר מדויקות.אם מעולם לא שמעת על ויקינתונים, SPARQL או WQDS לפני כן, הנה הסבר קצר של המונחים האלה: ויקינתונים הוא מסד נתוני ידע. הוא מכיל מיליוני קביעות, כגון „עיר הבירה של קנדה היא אוטווה”, או „ציור המונה ליזה צויר בשמן על עץ צפצפה”, או „נקודת ההתכה של זהב היא 1,064.18 מעלות צלזיוס”. SPARQL היא שפה לביטוי נוסחאי של שאלות (שאילתות) במסדי נתוני ידע. עם מסד הנתונים הנכון, שאילתת SPARQL יכולה לענות על שאלות כמו „מה הטונליות הנפוצה ביותר במוזיקה?” או „איזו דמות שיחקו הכי הרבה שחקנים?” או „מה היא התפלגות סוגי הדם?” או „איזו יצירה של אומנים הונגשה לנחלת הכלל השנה?”. WDQS, שירות התשאול של ויקינתונים, מחבר בין השניים: כותבים שאילתת SPARQL, היא רצה כנגד סדרת הנתונים של ויקינתונים ומציגה לך את התוצאות.  יסודות SPARQL שאלת SPARQL פשוטה נראית ככה: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} הפסוקית SELECT כוללת את המשתנים שנרצה להחזיר (משתנים מתחילים בסימן שאלה), והפסוקית WHERE מכילה מגבלות עליהם, בעיקר בצורת שלישיות. כל המידע בוויקינתונים (ומסדי נתוני ידע דומים) מאוחסן בצורת שלישיות, כשמריצים את השאילתה, שירות התשאול ינסה למלא את המשתנים בערכים בפועל כדי שהשלישיות המתקבלות תופענה במסד נתוני הידע ותוחזרנה תוצאה אחת לכל צירוף משתנים שנמצאו. שלישייה יכולה להיות כמו משפט (לכן היא מסתיימת בנקודה) עם נושא (subject), נשוא (predicate) ועצם (object): SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} התוצאות לשאילתה הזאת יכולות לכלול, למשל, „לימון”. בוויקינתונים, רוב המאפיינים הם מסוג „יש” (has), לכן השאילתה יכולה להיראות כך: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} שיפורש בצורה ‎„?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’”)‎ ובעברית: ל?פרי יש את הצבע ‚צהוב’” (לא “?פרי הוא הצבע של ‚צהוב’”) - חשוב לזכור את זה לטובת צמדי מאפיינים מהצורה „הורה”/„צאצא”!.עם זאת, זאת לא דוגמה טובה ל־WQDS. טעם הוא סובייקטיבי, לכן לוויקינתונים אין מאפיין לזה. במקום, אפשר לחשוב על יחסי הורה/צאצא, שהם בדרך כלל חד־משמעיים. השאילתה הראשונה שלנו נניח שנרצה להציג את כל הצאצאים של המלחין מתקופת הבארוק יוהאן סבסטיאן באך. באמצעות רכיבים מדומים כמו בשאילתות להלן, איך כדאי לכתוב את השאילתה הזאת?אמור היה לצאת משהו כזה: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach (‏(ל)צאצא ''יש הורה'' באך)
  ?child parent Bach.
  # ‫(נא לשים לב: כל מה שנכתב אחרי ‚#’ נחשב הערה ו־WQDS יתעלם ממנו.)
} או ככה, SELECT ?child
WHERE
{
  # child \"has parent\" Bach (‏(ל)צאצא ''יש אבא'' באך) 
  ?child father Bach. 
} או ככה, SELECT ?child
WHERE
{
  #  Bach \"has child\" child (‏(ל)באך ''יש צאצא'' צאצא)
  Bach child ?child.
} שתי השלישיות הראשונות טוענות של־‎?child חייב להיות הורה/אבא בשם Bach, השלישית טוענת של־Bach יש את הצאצא ‎?child. בואו נמשיך עם האפשרות השנייה כרגע.אם כן, מה צריך לעשות כדי להפוך את זה לשאילתה תקפה של WQDS? בוויקינתונים פריטים ומאפיינים לא מזוהים בשם שמובן לבני אדם כמו „אבא” (מאפיין) או „באך” (פריט). (יש לכך סיבה טובה: „יוהאן סבסטיאן באך” הוא גם השם של צייר גרמני, ו„באך” יכול גם להיות שם משפחה, קהילה צרפתית, מכתש בכוכב חמה וכן הלאה). במקום, לפריטים ולמאפיינים בוויקינתונים מוקצים מזהים. כדי למצוא מזהה של פריט עלינו לחפש את הפריט ולהעתיק את מספר ה־Q של התוצאה שנשמעת כמו הפריט שאנחנו מחפשים (לפי התיאור למשל). כדי למצוא מזהה של מאפיין, נעשה את אותו הדבר, אך נחפש אחר „‪P:<ביטוי לחיפוש>‬” במקום רק „ביטוי לחיפוש”, מה שיגביל את החיפוש למאפיינים. כך נוכל למצוא שהמלחין המפורסם יוהאן סבסטיאן באך מיוצג על ידי Q1339, ושהמאפיין להקצאת הורה לפריט הוא P:P22.ואחרון חביב, צריך לכלול קידומות. לשלישיות פשוטות של WQDS, יש להוסיף קידומת wd:‎ לפריטים, ולמאפיינים את wdt:‎. (אך זה חל רק על ערכים קבועים - משתנים לא מקבלים קידומת!)אם נחבר הכול יחד, נגיע לשאילתת ה־WDQS הראויה הראשונה שלנו: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! נלחץ על הקישור „לנסות את זה”, לאחר מכן על „ביצוע שאילתה” בעמוד ה־WDQS. מה יוצא? child wd:Q57225 wd:Q76428 … קצת מאכזב. רואים רק את המזהים. אפשר ללחוץ עליהם כדי לראות את העמוד שלהם בוויקינתונים (כולל תווית שבני אדם יכולים להבין), אבל אין דרך טובה יותר לראות את התוצאות?נו, כמובן שיש! (שאלות רטוריות זה דבר נפלא, לא?) אם כוללים את מלל הקסם SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } איפשהו בתוך פסוקית ה־WHERE יש משתנים נוספים: לכל משתנה ‎?foo בשאילתה שלך יש עכשיו גם משתנה ‎?fooLabel, which שמכיל את תווית הפריט שמאחורי ‎?foo. אם נוסיף אותו לפסוקית ה־SELECT יופיע הפריט וגם התווית שלו: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כדאי לנסות להריץ את השאילתה הזאת - אמורים להופיע לא רק מספרי הפריטים אלא גם שמות הצאצאים השונים. child childLabel wd:Q57225 יוהאן כריסטוף פרידריך באך wd:Q76428 קארל פיליפ עמנואל באך …  השלמה אוטומטית לא נראה שקל כל כך לזכור את מקטע הקוד הזה עם SERVICE, נכון? ולהשתמש בחיפוש כל פעם בזמן כתיבת השאילתה זה גם די מייגע. למרבה המזל, WDQS מציע לכך פתרון נהדר: autocompletion (השלמה אוטומטית). בעורך השאילתות query.wikidata.org אפשר ללחוץ על Ctrl+רווח (or Alt+אנטר או Ctrl+Alt+אנטר) בכל נקודה בשאילתה ולקבל הצעות לקוד שיכול להתאים, את ההצעה המתאימה ניתן לבחור עם מקשי החצים למעלה/למטה ואז על אנטר כדי לבחור אותה.למשל, במקום לכתוב SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } כל פעם מחדש, אפשר פשוט להקליד SERV, ללחוץ על Ctrl+רווח, והתוצאה הראשונה תהיה כישוף שירות התווית המלא, מוכן לשימוש! עכשיו צריך רק ללחוץ על אנטר כדי לאשר אותו. (העיצוב יהיה מעט שונה אבל זה לא משנה.)השלמה אוטומטית יכולה גם לחפש עבורך. אם הקלדת את אחת מהקידומות של ויקינתונים כגון wd:‎ או wdt:‎, ואז את הטקסט לאחר מכן, Ctrl+רווח תחפש את הטקסט הזה בוויקינתונים ותציע תוצאות. wd:‎ מחפשת אחר פריטים, wdt:‎ אחר מאפיינים. למשל, במקום לחפש את הפריטים עבור Johann Sebastian Bach (Q1339) וfather (P22), אפשר פשוט להקליד wd:Bach ו־wdt:fath ואז פשוט לבחור את הרשומה המתאימה מההשלמה האוטומטית. (עובד אפילו עם רווחים בטקסט, למשל: wd:Johann Sebastian Bach.) תבניות שלישיות מתקדמות אז עכשיו פגשנו את כל הצאצאים של יוהאן סבסטיאן באך - יותר נכון: את כל הפריטים שהאבא שלהם הוא יוהאן סבסטיאן באך. אך לבאך היו שתי נשים, לכן לפריטים האלה יש שתי אימהות שונות: מה אם אנחנו רוצים לראות רק את הצאצאים של יוהאן סבסטיאן באך עם אשתו הראשונה, מריה ברברה באך (Q57487)? כדאי לנסות לכתוב את זה בשאילתה, לפי המידע שיש לנו.סיימנו? מצוין, נעבור לפתרון! הדרך הפשוטה ביותר לעשות זאת היא להוסיף שלישייה שניה עם המגבלה הזאת: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! בעברית המשמעות היא: לילד יש אבא יוהאן סבסטיאן באך. לילד יש אימא מריה ברברה באך. נשמע מוזר, לא? בשפה טבעית נוכל לקצר את זה לביטוי: לילד יש אבא יוהאן סבסטיאן באך ואימא מריה ברברה באך. למעשה, אפשר לבטא את אותו הקיצור גם ב־SPARQL: אם סוגרים את השלישייה בנקודה פסיק (;) במקום בנקודה, אפשר להוסיף עוד צמד נשוא-עצם. כך נוכל לקצר את השאילתה שלעיל לכדי: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! שמציגה את אותן תוצאות אך עם פחות חזרות בשאילתה.עכשיו נניח, שמתוך התוצאות האלו, מעניינים אותנו רק הצאצאים שהיו גם מלחינים ופסנתרנים. המאפיינים והפריטים הרלוונטיים הם occupation (P106), composer (Q36834) וpianist (Q486748). עכשיו ננסה לשנות את השאילתה שלהלן כדי להוסיף לה את המגבלות האלה!הינה הפתרון שלי: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כאן נעשה שימוש בקיצור ; פעמיים נוספות כדי להוסיף את שני העיסוקים הנחוצים. אך כפי שניתן לשים לב, עדיין יש חזרתיות. זה כמו שנגיד: לילד יש עיסוק מלחין ועיסוק פסנתרן. מה שבדרך כלל נוכל לקצר לביטוי: לילד יש עיסוק מלחין ופסנתרן. ול־SPARQL יש תחביר גם לזה: ממש כמו ש־; מאפשר להוסיף צמד נשוא-עצם לשלישייה (תוך שימוש בנושא לשתי מטרות), , מאפשר לך להוסיף עצם נוסף לסוף שלישייה (תוך ניצול של הנושא והנשוא לשתי מטרות). כך, אפשר לקצר את השאילתה לכדי: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! כדאי לשים לב: אין משמעות להזחות ולרווחים נוספים - הם רק מקלים על הקריאה. אפשר גם לכתוב את זה ככה: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # שני העיסוקים באותה שורה
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! או, בצורה הפחות נוחה לקריאה: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # אין הזחה, מקשה על הבדלה בין ; לבין ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! למרבה המזל, העורך של WDQS מזיח את השורות עבורך אוטומטית, כך שזה בדרך כלל לא אמור להטריד אותך.מצוין, נערוך סיכום ביניים. ראינו ששאילתות בנויות כמו טקסט. כל שלישייה על נושא נסגרת בנקודה. מספר נשואים על אותו הנושא מופרדים בנקודה פסיק, ומגוון עצמים לאותו הנושא והנשוא ניתן לכתוב עם פסיקים ביניהם. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} עכשיו נציג קיצור נוסף ש־SPARQL מציע. כל עוד נוכל לזרום בצחוק על עוד תרחיש מומצא…נניח שאנחנו לא באמת מעוניינים בילדים של באך. (טוב, אולי אותך זה כן מעניין!) אבל אנחנו מעוניינים בנכדים שלו. (לכאורה.) יש כאן סיבוך מסוים: נכד יכול להיות קשור לבאך דרך האימא או דרך האבא. אלו שני מאפיינים שונים, שזה מצב לא נוח. במקום, נהפוך את הזיקה: לנתונים יש גם מאפיין „צאצא”, P:P40, שמפנה מההורה לצאצא ללא תלות במגדר. עם המידע הזה, אפשר לכתוב שאילתה שמחזירה את הנכדים של באך?הינה הפתרון שלי: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! בשפה טבעית, המשמעות היא: לבאך יש ילד ‎?child. ל־‎?child יש ילד ?grandChild. גם כאן, אני מציע לקצר את המשפט הזה ואז ארצה להראות איך SPARQL תומך בקיצור דומה. בדרך הזאת לא ממש אכפת לנו מהצאצא: אנחנו לא משתמשים במשתנה למעט כדי לדבר על הנכד. לכן עלינו לקצר את המשפט הזה לכדי: לבאך יש איזשהו ילד שיש לו ילד ‎?grandChild. במקום להגיד איזה ילד זה של באך, אנחנו פשוט מציינים „מישהו”: לא אכפת לנו מי הוא. אבל אפשר להתייחס אליהם בחזרה כיוון שאמרנו „איזשהו/מישהו ש”: בכך פתחנו בפסוקית זיקה, ובתוך פסוקית הזיקה הזאת נוכל לציין דברים על „איזשהו/מישהו” (למשל: ש„יש להם ילד ‎?grandChild”). למעשה, „איזשהו/מישהו” הוא משתנה, אך מיוחד שתקף רק בתוך פסוקית הזיקה הזאת וכזה שאנחנו לא פונים אליו במפורש (אנחנו מציינים ש„למישהו שהוא זה ועושה את זה”, לא „מישהו שהוא זה ומישהו שעושה את זה” - זה לא אותו „מישהו”).ב־SPARQL אפשר לכתוב את זה בתור: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! אפשר להשתמש בצמד סוגריים מרובעים ([]) במקום משתנה, שמתנהג כמו משתנה אלמוני. בתוך הסוגריים, אפשר לציין צמדים של נשוא-עצם, בדיוק כמו אחרי ; שאחרי שלישייה רגילה, הנושא המרומז הוא במקרה הזה המשתנה האלמוני שהסוגריים האלה מייצגים. (לתשומת ליבך: כמו מיד אחרי code>;, אפשר להוסיף עוד צמדי נשוא-עצם עם יותר נקודות פסיקים או יותר עצמים לאותו הנשוא עם פסיקים.)זה הכול על תבניות שלישיות! יש עוד מה לגלות על SPARQL, אך כיוון שאנחנו מתכננים לעזוב את החלקים ממנו שהם אנלוגיים לטובת שפה טבעית, ארצה לסכם את היחס הזה פעם נוספת: שפה טבעית דוגמה SPARQL דוגמה משפט יוליה אוהבת את רומיאו. תקופה יוליה אוהבת את רומיאו. חיבור (פסוקית) רומיאו אוהב את יוליה וגם הורג את עצמו. נקודה פסיק רומיאו אוהב את יוליה; הורג את רומיאו. חיבור (שם עצם) רומיאו הורג את טיבלט וגם את עצמו. פסיק רומיאו הורג את טיבלט, רומיאו. פסוקית זיקה יוליה אוהבת מישהו אשר הורג את טיבלט. סוגריים מרובעים יוליה אוהבת את [ הורג את טיבלט ].  מופעים ומחלקות לפני כן, ציינתי שרוב המאפיינים של ויקינתונים הם זיקה מסוג „יש” (has): יש צאצא, יש אבא, יש עיסוק. אבל לפעמים (למעשה, לעיתים קרובות), צריך גם לדבר על אופיו של משהו (is). אך זה מתחלק למעשה לשני סוגים של קשרים: חלף עם הרוח הוא סרט. סרט הוא יצירת אומנות. חלף עם הרוח הוא סרט מסוים אחד. יש לו במאי מסוים (ויקטור פלמינג), אורך מסוים (238 דקות), רשימת שחקנים (קלארק גייבל, ויויאן לי…), ועוד.סרט הוא עקרון כללי. לסרטים יכולים להיות במאים, אורכים ושחקנים, אבל לעקרון „סרט” כפי שהוא אין במאי, משך או ליהוק מסוים. ולמרות שסרט הוא יצירת אומנות, וליצירת אומנות בדרך כלל יש יוצר, לעקרון „סרט” לכשעצמו אין יוצר – רק למופעים מסוימים של העקרון הזה יש.ההבדל הזה הוא הסיבה לכך שיש שני מאפיינים עבור „is” (תת־קבוצה של/מופע של) בוויקינתונים: instance of (P31) וsubclass of (P279). חלף עם הרוח הוא מופע מסוים של המחלקה „סרט”, המחלקה „סרט” היא תת־מחלקה (ליתר דיוק מחלקה, התמחות) של מחלקה כללית יותר בשם „יצירת אומנות”.כדי לסייע להבין את ההבדלים, אפשר לנסות להשתמש בשני פעלים שונים: „תת־קבוצה” ו„מופע של”. אם „תת־קבוצה” מתאים (למשל: סרט הוא „תת־קבוצה של” יצירת אומנות), זה אומר שמדובר בתת־מחלקה. מומחיות של מחלקה רחבה יותר ויש להשתמש בsubclass of (P279). אם „תת־מחלקה של” לא מתאים (למשל: המשפט חלף עם הרוח הוא „מופע של” סרט אין בו היגיון), זה אומר שמדובר במופע מסוים ושצריך להשתמש בinstance of (P31).אז מה זה אומר לגבינו בעת כתיבת שאילתות SPARQL? כשאנו רוצים לחפש אחר „כל יצירות האומנות”, לא מספיק לחפש את כל הפריטים שהם מופעים ישירים של „יצירת אומנות”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # מופע של יצירת אומנות
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! בזמן תרגום המדריך (דצמבר 2023), השאילתה הזאת החזירה רק 31,308 תוצאות - כמובן שיש הרבה יותר יצירות אומנות מהכמות הזאת! הבעיה היא שהשאילתה מחמיצה פריטים כמו חלף עם הרוח, שזה מופע של „סרט” בלבד ולא של „יצירת אומנות”. „סרט” זאת תת־מחלקה של „יצירת אומנות” אבל אנחנו צריכים לדרוש מ־SPARQL לקחת את זה בחשבון בזמן החיפוש.פתרון אחד לכך הוא התחביר [] שדיברנו עליו: חלף עם הרוח הוא מופע של איזושהי תת־מחלקה של „יצירת אומנות”. (לצורך התרגול, כדאי לנסות לכתוב את השאילתה הזאת!) אך גם בגישה הזאת עדיין יש בעיות: אנחנו לא כוללים עוד פריטים שהם מופעים ישירים של יצירת אומנות. אנחנו עדיין מחמיצים פריטים שהם מופעים של תת־מחלקה כלשהי של איזה תת־מחלקה אחרת של „יצירת אומנות” - למשל, שלגיה ושבעת הגמדים הוא סרט מונפש, שהוא סרט, שהוא יצירת אומנות. במקרה הזה אנחנו צריכים לעקוב אחר שתי קביעות מסוג „תת־מחלקה של” - אבל זה יכול להיות גם שלושה, ארבעה, חמישה ולמעשה כל מספר. הפתרון: ‎?item wdt:P31/wdt:P279* ?class‎. המשמעות היא שיש „מופע של” אחד ואז מספר כלשהו של קביעות מסוג „תת־מחלקה של” בין הפריט ובין המחלקה. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # מופע של תת־מחלקה כלשהי של יצירת אומנות
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (לא מומלץ להריץ את השאילתה הזאת. WDQS יכול להתמודד איתה (ממש בקושי), אבל הדפדפן שלך עלול לקרוס בעת ניסיון להציג את התוצאות כי יש הרבה מהן.)עכשיו יותר ברור איך לחפש אחר כל יצירות האומנות או כל הבניינים או כל היישובים לבני אדם: כישוף הקסם wdt:P31/wdt:P279*‎, יחד עם המחלקה המתאימה. לשם כך נעשה שימוש בעוד כמה יכולות SPARQL שעדיין לא הסברתי עליהן, אבל למען ההגינות, זה בערך השימוש הרלוונטי היחידי של היכולות האלה כך שאין צורך אמיתי להבין איך זה עובד כדי להשתמש ב־WDQS ביעילות. אם חשוב לך לדעת, אסביר זאת בקצרה אבל אפשר פשוט לדלג לסעיף הבא ולשנן או להעתיק ולהדביק את wdt:P31/wdt:P279*‎ מכאן בעת הצורך. נתיבי מאפיינים נתיבי מאפיינים הן דרך לכתוב נתיב של מאפיינים בין שני פריטים בצורה תמציתית. הנתיב הפשוט ביותר הוא מאפיין יחיד, שמתגבש לכדי שלישייה פשוטה: ?item wdt:P31 ?class. אפשר להוסיף רכיבי נתיב עם לוכסן (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. שקול לאחד מהבאים: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. תרגיל: נא לשכתב את שאילתת „הנכדים של באך” מקודם לשימוש בתחביר הזה.כוכבית (*) אחרי רכיב נתיב משמעה „אפס או יותר מהרכיב הזה”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Zobŏcz tyż Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel.Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations bug 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries.If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be read like a sentence (which is why it ends with a full stop), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColour yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit colour yellow.
  ?fruit taste sour.
} which reads like “?fruit has colour ‘yellow’” (not “?fruit is the colour of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!).However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query?Hopefully you've got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now.So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22.And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!)Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results?Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it.For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.)And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above.Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a full stop, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query.Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions!Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this.Alright, let’s summarise here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a full stop. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humour me for one more hypothetical scenario…Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren?Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s).In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.)And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarise that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. full stop juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on.Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do.This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialisation) of the more general class “work of art”.To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialisation of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31).So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching.One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (As an exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.)Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorise or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths Property paths are a way to very tersely write down a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax.An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 维基数据查询服务（WDQS）是洞察维基数据内容的一个强大工具。本指南将教您如何使用它。另可尝试维基媒体以色列提供的交互式教程。自行编写SPARQL查询前，查阅{{Item documentation}}和其他通用SPARQL查询模板，看看所需的查询是否已有人提供。 Contents 1 开始之前 2 SPARQL基础 3 迈向第一个查询 3.1 自动完成 4 高级三元模式 5 实例和类别 5.1 属性路径 6 限定符 7 顺序（ORDER）和限制（LIMIT） 7.1 练习 7.1.1 Conan Doyle写的书 7.1.2 化学元素 7.1.3 流入密西西比河的河流 7.1.4 流入密西西比河的河流（第二课） 8 可选（OPTIONAL） 9 表达式、筛选器和绑定 9.1 数据类型 9.2 运算符 9.3 筛选器 9.4 BIND、BOUND、IF 9.5 组合（COALESCE） 10 分组 10.1 城市人口 10.2 绘画材料 10.3 按制造商划分枪支 10.4 按页数排序出版商 10.4.1 HAVING（必须） 10.5 聚合函数简述 10.6 wikibase:标签和聚合的bug 11 VALUES 12 Label in multiple languages 13 未完待续… 14 参见 开始之前 虽然这本指南看起来非常长且令人生畏，但请壮起胆来。了解SPARQL的基础知识就能让你走得更远——即便你在读完#迈向第一个查询后就停止阅读，你也能了解到许多有趣的查询。本教程的每个章节都能使你有能力写出更多强大的查询。如果你以前从未听说过维基数据、SPARQL或WDQS，下方有关于这些术语的简短解释。 维基数据是一个知识数据库。它包含了数以百万计的陈述，如“加拿大的首都是渥太华”，或“蒙娜丽莎是用油彩画在杨木上的”，或“黄金的熔点是1064.18摄氏度”。 SPARQL是一种为知识数据库制定问题（查询）的语言。有了合适的数据库，SPARQL查询可以回答诸如“音乐中最流行的音调是什么？”或“哪个角色被最多的演员所描绘？”或“血型的分布是什么？”或“今年哪些作家的作品进入了公共领域？”这样的问题。 WDQS，即维基数据查询服务，将这两者结合起来。你输入一个SPARQL查询，它针对维基数据的数据集运行，并向你显示结果。  SPARQL基础 一个简单的SPARQL查询看起来像这样： SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT从句列出您希望返回的变量（变量以问号开头），WHERE从句包含相关限制，主要以三元组的形式。维基数据（以及类似的知识数据库）中的所有信息都是以三元组的形式存储；当你运行查询时，查询服务会尝试将实际的值填入变量，从而呈现知识数据库中的三元组，并在返回的一个结果中呈现找到的每个变量组合。 三元组可以像一个句子一样阅读（这就是为什么它以句号结束），有一个主语、一个谓语和一个宾语。 SELECT ?水果
WHERE
{
  ?水果 它的颜色 黄色.
  ?水果 味道 酸.
} 这个查询的结果可能包括如“柠檬”。在维基数据中，大多数属性都是“具有”类型的属性，因此查询通常为： SELECT ?水果
WHERE
{
  ?水果 颜色 黄色.
  ?水果 味道 酸.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). 但其实这不是WDQS的一个好例子。味道是主观的，所以维基数据没有为它设置属性。现在，让我们考虑一下“父与子”的关系，这种关系通常不存在歧义。 迈向第一个查询 假设我们想列出巴洛克作曲家Johann Sebastian Bach的所有孩子。像上面的查询一样使用“伪元素”，你会怎么写这个查询？你或许会写成这样： SELECT ?孩子
WHERE
{
  #  孩子 \"他的父母\" Bach
  ?孩子 父母 Bach.
  # （注：'#'后面的所有内容都是注释，WDQS会忽略。）
} 或者这样， SELECT ?孩子
WHERE
{
  # 孩子（变量） \"他的父亲\" Bach 
  ?孩子 父亲 Bach. 
} 或者这样， SELECT ?孩子
WHERE
{
  #  Bach \"的孩子\" 孩子（变量）
  Bach 孩子 ?孩子.
} 前两个三元组要求?孩子必须有父母/父亲“巴赫”；第三个要求“巴赫”必须有孩子?child。我们现在先用第二个。那么，如何将其变为一个合适的WDQS查询呢？在维基数据中，项目和属性不是由人类可读的名称来识别的，如“父亲”（属性）或 “巴赫”（项目）。有充分的理由：“约翰·塞巴斯蒂安·巴赫”也是一位德国画家的名字，而“巴赫”也可能指的是姓氏、法国公社、水星坑等等。要找到一个项目的标识符，我们要搜索该项目，并复制结果中像是我们要找的项目的Q号（例如根据描述判断）。找到一个属性的标识符的方法相同，但要搜索“P:关键词”而不是仅仅搜索“关键词”，这样就能搜索范围限制在属性上。如此做能告诉我们，著名作曲家约翰·塞巴斯蒂安·巴赫对应的是Q1339，而指定一个项目的父亲的属性是P:P22。最后，还有一点很重要，我们要加上前缀。对简单的WDQS三元组来说，项的前缀是wd:，属性的前缀是wdt:。以上仅适用于固定的值，变量不需要前缀。综上所述，我们得到了首个正确的WDQS查询： SELECT ?孩子
WHERE
{
# ?孩子 父亲 Bach.
  ?孩子 wdt:P22 wd:Q1339.
}
 Try it! 单击“试一试”链接，然后在WDQS页面上“运行”查询。你得到想要的结果了吗？ 孩子 wd:Q57225 wd:Q76428 … 也许令你失望了？你只能看到标识符，虽然你可以单击来查看其对应的维基数据页面（包含易读的文字标签），有更好的方法显示这些结果吗？别急，我们有，只需包含下列神奇的语句 SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } 到WHERE从句，你就能拿到额外的标签。对您的查询中的每个?abc变量来说，你都有一个额外的?abcLabel，其中包含?abc变量所对应的项的文字标签（label）。如果将这个加到SELECT从句，你就能得到所需的项以及项的标签： SELECT ?child ?childLabel
WHERE
{
# ?孩子  父亲   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 运行试试 - 你应该不仅看到项目的编号，还能看到各个项目的名称。 child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  自动完成 SERVICE 这段句子看上去很难记吧？编写查询时不停的搜索翻找也很烦人。还好，WDQS提供了“自动完成”解决方案。在query.wikidata.org查询编辑器中，在查询的任何位置按下Ctrl+Space（空格键）（或Alt+Enter（回车键）或Ctrl+Alt+Enter）可以获取或许合适的代码建议；用方向键上和下选择合适的建议，然后按下Enter（回车键）来选择。例如，相比每次都输入完整的SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }，您只需输入SERV，按Ctrl+Space，首个建议就是完整的这个句子，随取随用！按下Enter确认使用。（格式可能稍有变化，但无关紧要。）自动完成还可帮您搜索。如果输入一个维基数据前缀，例如wd:或wdt:，在后面输入一些内容，按Ctrl+Space将在维基数据上搜索该内容并给出建议的结果。wd:搜索项目（item），wdt:搜索属性。例如，相比找到Johann Sebastian Bach (Q1339)和father (P22)，只需输入wd:Bach和wdt:fath，然后从自动完成中选择正确的结果。这也支持有空格的文本，例如wd:Johann Sebastian Bach。 高级三元模式 现在我们看到了Johann Sebastian Bach的所有孩子，更准确的说——所有“父亲”为Johann Sebastian Bach的项目。但Bach有两任妻子，所以这些项包含不同的生母，如果我们只想看第一任妻子, Maria Barbara Bach（Q57487）所生的孩子呢？尝试基于上方的查询编写这个查询。写出来了吗？让我们来看解决方案。完成此操作的最简单方法是添加第二个三元组作为限制条件： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 它可以被理解为： 孩子（Child） 父亲 Johann Sebastian Bach. 孩子（Child） 母亲 Maria Barbara Bach. 听起来有点尴尬？在自然语言中我们会写为： 孩子的父亲是Johann Sebastian Bach，母亲是Maria Barbara Bach。 而事实上，SPARQL中也可以表达为类似的缩写形式：如果用英文的分号（;）而非句号结尾，就可以添加第二组谓词-对象。如此一来，上述查询可以缩写为： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 如此能得到相同的结果，并减少在查询中的复述。现在假设，我们只对结果中是作曲家且是钢琴家的孩子感兴趣。对应项目是occupation (P106)、composer (Q36834)和pianist (Q486748)。尝试更新上方的查询来添加这些限制。我的方案是这样： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 这里使用;缩写法超过两次，追加了两个必要条件。但正如你所见到的，仍有一些复述的地方，就好像在说： 孩子的职业是作曲家、职业是钢琴家。 而我们通常会说： 孩子的职业是作曲家和钢琴家。 巧的是，SPARQL对此也有语法应对：就像;允许你将谓词-对象追加到三元组（重用主语），英文逗号,则允许你再追加一个“对象”到三元组（重用主语和谓词）。因此，查询可以缩写为： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 注：缩进和其他空格其实不重要，只是为了可读性。因此还可以缩写为： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # 两个职业（匹配）放在同一行
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 或者更低可读性的写法： SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # 不留缩进，会不容易区分,和;
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 幸运的是，WDQS编辑器能为您自动缩进，因此通常无需担心。我们总结一下。每行查询的结构类似一句话。每个主题的三元组用一个英文句号终结。同一个主题多个谓词（第二项）用英文分号分隔，同一个主题和谓词的多个对象（第三项）用英文逗号分隔。 SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} 现在我想再介绍一个SPARQL提供的缩写。让我来再假设一个场景。假设我们对Bach的孩子不感兴趣，但想了解他的“孙子”辈。注意，“孙子”可能因父亲或母亲而与Bach有关系，而这是两个不同的属性，这让事情变得复杂。让我们思维逆转，维基数据还有一个孩子（“child”）属性P:P40，是从“父母”项指向“子女”项，并且无关性别。那么，你能写一个返回Bach的孙子孙女的查询吗？我的方案是这样： SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 在自然语言中对应： Bach有一个孩子（?child），这个 孩子（?child）也有一个孩子（?grandChild）。 我们再来试试缩写这个查询。我们实际不关心中间的那个Bach的“孩子”，而只需要获取Bach的孙子/孙女。因此，我们不使用中间变量，可以将查询缩写为： Bach的孩子有一个孩子（?grandChild）。 Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). 在SPARQL中这可以写为： SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 你可以用一对方括号（[]）代替变量，形成匿名变量。在方括号内可以指定“谓词-对象”组（亦即匹配条件），形式类似一般三元组后面的;；这种情况下，隐式的“主语”是括号所表现的匿名变量。另外，与放在;后面一样，你可以添加多组“谓词-对象”，或者用逗号添加同一谓词的多个对象（亦即匹配值）。以上就是三元组模式。SPARQL还有很多内容，但因为我们即将离开与自然语言非常相似的部分，我想再次总结一下这种对应关系： 自然语言 例子 SPARQL 例子 句子 Juliet 爱 Romeo。 句号 juliet 爱 romeo. 连词（从句） Romeo 爱 Juliet 并且 杀死了 他自己。 分号 romeo 爱 juliet; 杀死了 romeo. 连词（名词） Romeo 杀死了 Tybalt 和 他自己。 逗号 romeo 杀死了 tybalt, romeo. 相对从句 Juliet 爱 杀死了 Tybalt 的人。 方括号 juliet 爱 [ 杀死了 tybalt ].  实例和类别 不久前我说，维基数据的大多数属性“有”的关系，“有”孩子、“有”父亲、“有”职业。但有时（且其实是经常），你需要说的是“是”。但这实际涉及到两种关系。 亂世佳人 是 一部电影。 一部电影 是 一件艺术作品。 Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. 这就是为什么维基数据中针对“是”（“is”）有两个属性，instance of (P31)和subclass of (P279)。亂世佳人是“电影”类别中的一个特定实例，而类别“电影”是“艺术作品”中的一个更具体的专门子类。 To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). 所以这对于编写SPARQL意味着什么？当我们想搜索“所有艺术作品”时，搜索所有直接隶属于“艺术作品”的实例项目是不够的。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # “艺术作品”的实例
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 我写这篇教程时（2016年10月），该查询只返回2,815个结果 - 显然，还有更多的艺术作品！这是因为它忽略了“乱世佳人”这种项目，它只是“电影”的一个实例，而不是“艺术作品”的实例。“电影”是“艺术作品”的一个子类，我们需要令SPARQL搜索时考虑这点。一种可能的方案是之前提过的方括号[]语法：乱世佳人是“艺术作品”的某个子类别的实例。（为了试验，尝试这种查询）。但这仍存在问题： 这不再包含直接隶属于“艺术作品”的实例项目。 仍缺少一些项目，它们是“艺术作品”的多级子类下的实例——例如，《白雪公主与七个小矮人》是一部动画电影，这是一部电影，这是一件艺术作品。此时我们需要查询两级“子类”的语句——但也可能是三级、四级或更多。 解决方案：?item wdt:P31/wdt:P279* ?class。这表示“它”符合“隶属于”，并且在项目和类别之间有任意数量的“上级分类”语句。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # 艺术作品的任何子类的实例
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! （我不建议运行该查询。WDQS可能勉强处理它，但您的浏览器可能在尝试显示结果时崩溃，因为结果非常多。）现在你应该知道如何搜索所有艺术品、所有建筑物，或者所有人类定居点：魔咒 wdt:P31/wdt:P279* 以及相应类别。这使用了一些我还没有介绍的SPARQL功能，但这几乎是这些功能的唯一相关用途，因此，您“不需要”了解它的工作原理，也能有效地使用WDQS。如果你仍然想知道，我会在稍后介绍；你也可以跳过下一章节，并只在需要用到时复制粘贴 wdt:P31/wdt:P279*。 属性路径 “属性路径”是一种非常简洁的记述两个项目（item）间的属性的路径的方法。最简单的路径只有一个属性，形成一个普通的三元组： ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. 这等同于下列任一写法： ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. 练习：用此语法重写前面的“巴赫的孙子”查询。路径后面的星号（*）意味着0个或许多个路径元素。 """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS ehk Wikidata päringuteenus on võimas tööriist, mis võimaldab piiluda Wikidata telgitagustesse. See juhend õpetab päringukeskkonda kasutama. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Enne alustamist 2 SPARQL-i alused 3 Meie esimene päring 3.1 Automaatne täitmine 4 Keerulisemad kolmikud 5 Üksikjuht nähtusest ja klassid 5.1 Omaduste rajad 6 Täpsustajad 7 ORDER ja LIMIT 7.1 Harjutus 7.1.1 Arthur Conan Doyle'i raamatud 7.1.2 Keemilised elemendid 7.1.3 Jõed, mis suubuvad Mississippisse 7.1.4 Jõed, mis suubuvad Mississippisse II 8 OPTIONAL 9 Avaldised, FILTER ja BIND 9.1 Andmetüübid 9.2 Tehtemärgid 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Rühmitamine 10.1 Linnade rahvaarvud 10.2 Maalimisel kasutatud materjalid 10.3 Relvad tootja kaupa 10.4 Kirjastused lehekülgede arvu järgi 10.4.1 HAVING 10.5 Kokkuvõte agregeerivatest funktsioonidest 10.6 wikibase:Label ja agregeerimine 11 VALUES 12 Label in multiple languages 13 Ja nii edasi… 14 See also Enne alustamist See juhend võib tunduda pikk ja hirmutav, kuid ära ehmu! SPARQL-i aluste õppimine laob tugeva põhja. Isegi, kui lõpetad lugemise pärast meie esimest päringut, oskad juba piisavalt, et koostada palju põnevaid päringuid. Juhendi iga lõik võimaldab Sul kirjutada aina võimsamaid päringuid.Kui Sa ei ole kunagi kuulnud mõistetest Wikidata, SPARQL või WDQS, siis siin on lühiseletus: Wikidata on koondandmebaas. See sisaldab miljoneid sissekandeid, nagu “Kanada pealinn on Ottawa” või “Mona Lisa on maalitud paplile õlivärviga” või “kulla sulamistemperatuur on 1064,18 kraadi Celsiuse järgi”. SPARQL on keel, mille abil saab sõnastada küsimusi (päringuid) andmebaasidele. Sobivas andmebaas suudab SPARQL-i päring vastata küsimustele nagu “mis on muusikas enim levinud tonaalsus?” või “millist tegelaskuju on mänginud suurim arv näitlejaid?” või “mis on veregruppide jaotus?” või “milliste autorite tööd lisandusid sel aastal avalikku omandisse?”. WDQS (Wikidata Query Service) ehk Wikidata päringuteenus toob need kaks kokku: Sa sisestad SPARQL-i päringu, see käib läbi Wikidata andmete ning kuvab Sulle tulemuse.  SPARQL-i alused Lihtne SPARQL-i päring näeb välja selline: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT lause on nimekiri muutujatest, mida Sa tahad tagastada (muutujad algavad küsimärgiga), ja WHERE lause sisaldab nende muutujate kitsendusi, peamiselt kolmikute kujul. Wikidatas (ja sarnastes andmebaasides) hoitakse kogu infot kolmikutena. Kui Sa käivitad päringu, siis proovib päringuteenus täita muutujad päris väärtustega, et tulemusena tekkinud kolmikud ilmuksid andmebaasis. Seejärel tagastab ta ühe tulemuse iga leitud muutujate kombinatsiooni kohta. Kolmikut võib lugeda kui lauset (mistõttu ta lõppeb ka punktiga), milles on subjekt, predikaat ja objekt: SELECT ?puuvili
WHERE
{
  ?puuvili omabVärvi kollane.
  ?puuvili maitseb hapult.
} Selle päringu tulemused võiksid sisaldada näiteks sidrunit. Wikidatas on enamik omadusi \"omab\" tüüpi, seega päringut võiks lugeda hoopis selliselt: SELECT ?puuvili
WHERE
{
  ?puuvili värv kollane.
  ?puuvili maitse hapu.
} mida võib lugeda “?puuvili omab värvi kollane” (mitte “?puuvili on kollase värv” – pea seda meeles selliste omaduspaaride juures nagu “vanem”/“laps”!).See aga ei ole hea näide WDQSi jaoks. Maitse on subjektiivne, seega Wikidatas ei ole selle jaoks omadust (ingl property). Mõtleme selle asemel vanema/lapse suhetele, mis on enamasti üheti mõistetavad. Meie esimene päring Oletame, et me tahame nimekirja barokkajastu helilooja Johann Sebastian Bachi kõigist lastest. Kasutades pseudoelemente nagu ülaltoodud päringutes, kuidas Sa selle päringu kirja paneksid?Loodetavasti said midagi sellist: SELECT ?laps
WHERE
{
  #  lapsel \"on vanem\" Bach
  ?laps vanem Bach.
  # (pane tähele: kõik, mis järgneb trellidele (‘#’) on kommentaar ning WDQS ignoreerib seda.)
} või siis SELECT ?laps
WHERE
{
  # lapsel \"on vanem\" Bach 
  ?laps vanem Bach. 
} või siis SELECT ?laps
WHERE
{
  #  Bachil \"on laps\" laps
  Bach laps ?laps.
} Esimesed kaks kolmikud ütlevad, et ?laps peab omama vanemat/isa Bach; kolmas ütleb, et Bachil peab olema laps ?laps. Vaatame praegu teist varianti.Mida me peame veel tegema, et sellest korralik WDQS-i päring teha? Wikidatas ei tuvastata üksusi ja omadusi inimloetavate siltide järgi nagu \"isa\" (omadus) või \"Bach\" (üksus). (Seda põhjusega: “Johann Sebastian Bach” on ühtlasi saksa maalikunstniku nimi ja “Bach” võib tähendada hoopis perekonnanimi, Prantsuse kommuuni, Merkuuri kraatrit või muud.) Selle asemel määratakse Wikidatas üksustele ja omadustele identifikaator. Selleks, et leida kindla üksuse identifikaatorit, otsime üksust ja kopeerime Q-numbri sellelt tulemuselt, mis tundub kõige sarnasem selle üksusega, mida me otsime (otsustades näiteks kirjelduse põhjal). Omaduse identifikaatori leidmiseks teeme sama, aga otsime “otsingutermini” asemel “P:otsingutermin”, mis kitsendab tulemused omadustele. See ütleb meile, et kuulus helilooja Johann Sebastian Bach on Q1339 ja üksuse isa kirjeldamiseks kasutatav omadus on P:P22.Viimaseks peame lisama eesliited. Lihtsate WDQS-i kolmikute puhul on üksustel eesliide wd: ja omadustel wdt:. (See käib ainult fikseeritud väärtuste kohta – muutujatele ei panda eesliidet!)Pannes kokku saadud teadmised, jõuame oma esimese WDQS-i päringuni: SELECT ?laps
WHERE
{
# ?laps  isa   Bach
  ?laps wdt:P22 wd:Q1339.
}
 Try it! Kliki nupul \"Proovi järele\", siis vajuta WDQS-i lehel suurt sinist nuppu päringu jooksutamiseks. Mis tulemuse saad? laps wd:Q57225 wd:Q76428 … See on küll pettumus. Sa näed ainult identifikaatoreid. Neile klikkides jõuad vastavale Wikidata lehele (kus on ka inimkeelne silt), aga kas tulemuste kuvamiseks pole paremat viisi?On ikka! (Kas retoorilised küsimused pole mitte toredad?) Kui Sa lisad maagilise teksti SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } kuhugi WHERE lausesse, saad muutujaid juurde: Iga muutuja ?foo kohta Su päringus on nüüd ka muutuja ?fooLabel, mis sisaldab üksuse ?foo silti. Kui Sa lisad uue muutuja ka SELECT lausesse, saad tulemuseks nii üksuse kui selle sildi: SELECT ?laps ?lapsLabel
WHERE
{
# ?laps  isa   Bach
  ?laps wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Proovi seda päringut jooksutada – peaksid nägema mitte ainult üksuste numbreid, vaid ka laste nimesid. laps lapsLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Automaatne täitmine Seda SERVICE jupp tundub raske meelde jätta, eks? Ja päringut kirjutades iga kord õige identifikaatori otsimine on samuti tüütu. Õnneks pakub WDQS sellele hea lahenduse: automaatne täitmine. query.wikidata.org päringutoimetis saad vajutada Ctrl+Tühik (või Alt+Enter või Ctrl+Alt+Enter) mistahes hetkel päringut kirjutades. Seejärel ilmub ekraanile soovitus, mis koodijupp sinna võiks sobida; vali õige soovitus üles/alla nooltega ja vajuta Enter, et see kinnitada.Näiteks selle asemel, et iga kord välja kirjutada SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }, võid lihtsalt trükkida SERV, vajutada Ctrl+Tühik ning esimene soovitus ongi täielik service loits! Lihtsalt vajuta Enter, et valik kinnitada. (Lause formaat tuleb veidi teistsugune, kuid sellest pole vahet.)Automaatne täitmine võib ka Sinu eest otsida. Kui trükid mõne Wikidata eesliidetest, nagu wd: või wdt: ja seejärel lihtsalt kirjutad teksti, siis Ctrl+Tühik otsib seda teksti Wikidatast ja soovitab leitud tulemusi. wd: otsib üksusi, wdt: omadusi. Näiteks, selle asemel et üles otsida Johann Sebastian Bach (Q1339) ja father (P22) üksused, võid lihtsalt trükkida wd:Bach ja wdt:isa ja seejärel lihtsalt valida automaatsoovituste seast õige. (See töötab isegi siis, kui su tekstis on tühikud, näiteks wd:Johann Sebastian Bach.) Keerulisemad kolmikud Nüüd oleme näinud Johann Sebastian Bachi kõiki lapsi, täpsemalt kõiki üksusi, mille isa on Johann Sebastian Bach. Aga Bachi oli kaks naist, seega nendel üksustel on erinevad emad: mis siis, kui me tahame näha ainult Johann Sebastian Bachi lapsi esimese naise, Maria Barbara Bachiga (Q57487)? Proovi vastav päring koostada, toetudes ülaltehtule.Valmis? Vaatame lahendust! Lihtsaim viis seda teha on lisada teine kolmik vastava piiranguga: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339.
  ?laps wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Eesti keeles saaks seda lugeda nii: Lapsel on isa Johann Sebastian Bach. Lapsel on ema Maria Barbara Bach. Kõlab natuke veidralt, kas pole? Loomulikus keeles me lühendaksime lauset: Lapsel on isa Johann Sebastian Bach ja ema Maria Barbara Bach. Tegelikkuses on võimalik sama lühivormi ka SPARQL-is kasutada: kui kirjutad kolmiku lõppu punkti asemel semikooloni (;), saad lisada veel ühe predikaadi-objekti paari. See lubab meil päringut lühendada nii: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! millel on samad tulemused, kuid vähem kordusi päringus.Nüüd oletame, et saadud tulemustest oleme huvitatud ainult neist, kus lapsed olid samuti heliloojad ja pianistid. Vastavad omadused ja üksused on occupation (P106), composer (Q36834) ja pianist (Q486748). Proovi uuendada ülaltoodud päringut, lisades need kitsendused!Siin on minu lahendus: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! See kasutab ; lühivormi veel kaks korda, et lisada vajalikud ametid. Ometi võid endiselt märgata kordusi. Praegune päring on sama, nagu me oleksime öelnud: Lapsel on amet helilooja ja amet pianist. mida me tavaliselt lühendaksime nii: Lapsel on amet helilooja ja pianist. Ja SPARQL-il on selle jaoks samuti süntaks olemas: kui ; lubab Sul kolmikule predikaadi-objekti paari lisada (taaskasutades subjekti), siis , lubab Sul kolmikule lisada veel ühe objekti (taaskasutades nii subjekti kui ka predikaati). Selle abil saab päringut lühendada nii: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Pane tähele: taanded ja muud tühikud ei ole tegelikult olulised – need teevad päringu lihtaslt loetavamaks. Sa võid kirjutada ka nii: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # mõlemad ametid ühel real
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! või vähem loetavalt: SELECT ?laps ?lapsLabel
WHERE
{
  ?laps wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # ilma taaneteta on raske eristada ; ja ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Õnneks loob päringukeskkond taanded automaatselt Sinu eest, seega Sa ei pea tavaliselt nende pärast muretsema.Teeme siin väikese kokkuvõtte. Me nägime, et päringuid ehitatakse üles nagu teksti. Iga kolmik mingi subjekti kohta lõpeb punktiga. Mitut predikaati sama subjekti kohta eraldab semikoolon ning mitut objekti sama subjekti ja predikaadi kohta võib eraldada komaga. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Nüüd tahan ma tutvustada veel üht lühendit, mida SPARQL pakub. Seega, kui lubate mul kirjeldada veel üht hüpoteetilist stsenaariumit...Oletame, et me ei ole tegelikult Bachi lastest huvitatud. (Kes teab, äkki see on Sinu puhul päriselt tõsi!) Aga meid huvitavad Bachi lapselapsed. Siin on üks probleem: lapselaps võib Bachiga seotud olla kas isa või ema kaudu. Need on kaks eri omadust, mis on ebamugav. Pöörame küsimuse ümber: Wikidatas on ka omadus “laps”, P:P40, mis osutab lapselt vanemale ja on soospetsiifiline. Kas Sa suudad selle info põhjal kirjutada päringu, mis tagastab Bachi lapselapsed?Siin on minu lahendus: SELECT ?lapselaps ?lapselapsLabel
WHERE
{
  wd:Q1339 wdt:P40 ?laps.
  ?laps wdt:P40 ?lapselaps.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Loomulikus keeles ütleksime seda nii: Bachil on laps ?laps. ?laps omab last ?lapselaps. Pakun jälle, et võiksime seda eestikeelset lauset lühendada, ja seejärel tahan Sulle näidata, kuidas SPARQL sarnast lühivormi lubab. Jälgi, kuidas me ei hooli tegelikult lapsest: me kasutame seda muutujat ainult selleks, et rääkida lapselapsest. Seetõttu saaksime lauset lühendada selliselt: Bachil on keegi selline laps, kellel on laps ?lapselaps. Selle asemel, et öelda, kes Bachi laps on, ütleme lihtsalt keegi: meil pole vahet, kes ta on. Aga me saame tagantjärele talle viidata, sest me kirjutasime \"keegi selline, kellel\": see alustab relatiivlauset ja me saame selles relatiivlauses öelda asju “kellegi” kohta (näiteks et tal “on laps ?lapselaps”). Mingis mõttes on \"keegi\" eriline muutuja, mis kehtib ainult selles relatiivlauses ning millele me otseselt ei viita (me ütleme \"keegi, kes on see ja teeb seda\", mitte \"keegi, kes on see, ja keegi, kes teeb seda\" – need on kaks erinevat \"keegit\").SPARQL-is võiks selle kirja panna nii: SELECT ?lapselaps ?lapselapsLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?lapselaps ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Sa võid kasutada muutuja asemel kandilisi sulge ([]), mis käituvad nagu nimetu muutuja. Sulgude sees saad täpsustada predikaadi-objekti paare, just nagu ; järel tavalise kolmiku puhul; seekord on kaudne subjekt nimetu muutuja, mida esindavad kandilised sulud. (Märkus: täpselt nagu pärast ;, võid ka siin lisada semikoolonitega veel predikaadi-objekti paare, või samale predikaadile komade abil rohkem objekte.)Ja see on kolmikute kohta kõik! SPARQL-is on palju muud, aga kuna me hakkame lahkuma nendest osadest, mis on loomuliku keelega tugevalt analoogsed, tahaksin selle suhte veel korra kokku võtta: loomulik keel näide SPARQL näide lause Julia armastab Romeot. punkt julia armastab romeot. konjunktsioon (lause) Romeo armastab Juliat ja tapab end. semikoolon romeo armastab juliat; tapab romeo. konjunktsioon (nimisõna) Romeo tapab Tybalti ja enda. koma romeo tapab tybalti, romeo. relatiivlause Jula armastab kedagi, kes tapab Tybalti. kandilised sulud julia armastab [ tapab tybalti ].  Üksikjuht nähtusest ja klassid Mainisin varem, et enamik Wikidata omadusi on \"omama\" suhted: omab last, omab isa, omab ametit. Aga vahel (tegelikult isegi tihti) on vaja rääkida, mis miski on. Siin saab aga eristada kaht erinevat suhet: Tuulest viidud on film. Film on kunstiteos. \"Tuulest viidud\" on üks kindel film. Sellel on kindel režissöör (Victor Fleming), kestus (238 minutit), nimekiri näitlejatest (Clark Gable, Vivien Leigh, …) ja nii edasi.Film on üldine mõiste. Filmidel võivad olla režissöörid, kestused ja näitlejad, kuid mõistel \"film\" kui sellisel ei ole ühtki kindlat režissööri, kestust ega näitlejat. Ja kuigi film on kunstiteos ja kunstiteosel on tavaliselt autor, siis mõistel “film” ei ole autorit — ainult üksikjuhtudel sellest mõistest on.Selle erinevuse tõttu on Wikidatas kaks eri omadust \"on\" väljendamiseks: instance of (P31) ja subclass of (P279). Tuulest viidud on üksikjuht klassist \"film\"; klass \"film\" on alamklass (ehk täpsem klass) üldisemast klassist \"kunstiteos\".Et Sul oleks kergem vahest aru saada, võid proovida kasutada kaht erinevat tegusõna: \"on üks kindel\" ja \"on mingit tüüpi\". Kui \"on mingit tüüpi\" sobib (nt Film \"on mingit tüüpi\" kunstiteos), osutab see sellele, et Sa räägid alamklassist ning peaksid kasutama subclass of (P279). Kui \"on mingit tüüpi\" ei sobi (nt lause \"Tuulest viidud\" \"on mingit tüüpi\" film ei ole loogiline), osutab see sellele, et Sa räägid kindlast näitest ning peaksid kasutama instance of (P31).Mida see meie jaoks tähendab, kui me kirjutame SPARQL-i päringuid? Kui me tahame otsida \"kõiki kunstiteoseid\", siis ei piisa, kui me otsime üksusi, mis on üksikjuhud \"kunstiteosest\". SELECT ?töö ?tööLabel
WHERE
{
  ?töö wdt:P31 wd:Q838948. # üksikjuht kunstiteosest
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Juhendi kirjutamise hetkel annab päring ainult 17937 kunstiteost – ilmselgelt on maailmas sellest rohkem kunstiteoseid! Probleem on selles, et siin on puudu üksused nagu \"Tuulest viidud\", mis on üksikjuht \"filmist\", aga mitte \"kunstiteosest\". \"Film\" on alamklass \"kunstiteosest\", aga me peame seda SPARQL-ile teada andma. Üks võimalik lahendus oleks [] süntaks, millest rääkisime: \"Tuulest viidud\" on üksikjuht mingist “kunstiteose” alamklassist. (Koosta see päring harjutamise mõttes!) Kuid sellega on endiselt probleeme: Otsing ei sisalda enam üksusi, mis on otseselt üksikjuhud kunstiteosest. Meil on endiselt puudu üksused, mis on üksikjuhud mingist alamklassist, mis on omakorda mingi muu alamklass “kunstiteosest” – näiteks Lumivalgeke ja seitse pöialpoissi on animeeritud film, mis on film, mis on omakorda kunstiteos. Sel juhul peaksime minema kahe sammu sügavusele – aga tasemeid võib olla ka kolm, neli, viis või tegelikult mistahes arv. Lahendus: ?üksus wdt:P31/wdt:P279* ?klass. See tähendab, et on ainult üks \"üksikjuht nähtusest\" ja seejärel mistahes arv \"alamklass\" avaldusi üksusi ja klassi vahel. SELECT ?töö ?tööLabel
WHERE
{
  ?töö wdt:P31/wdt:P279* wd:Q838948. # üksikjuht kunstiteose mistahes alamklassist
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Ma ei soovita seda päringut jooksutada. WDQS ei pruugi sellega hakkama saada, sest tulemusi on nii palju.)Nüüd Sa tead, kuidas otsida kõiki kunstiteoseid või kõiki hooneid või kõiki inimasulaid: kasutades maagilist loitsu wdt:P31/wdt:P279* koos vastava klassiga. See kasutab SPARQL-i funktsioone, mida ma veel seletanud ei ole, aga ausalt-öeldes on see nende funktsioonide ainus vajalik kasutus, seega Sul ei ole vaja mõista, kuidas see töötab, et WDQS-i efektiivselt kasutada. Kui Sind huvitab, siis ma varsti seletan, aga võid ka järgmise sektsiooni vahele jätta ning meelde jätta või siit wdt:P31/wdt:P279* kopeerida-kleepida, kui seda vaja läheb. Omaduste rajad Omaduste rajad on viis lühidalt kirja panna kahe üksuse vahel olevat teekonda. Lühim teekond on üksainus omadus, mis loob tavalise kolmiku: ?item wdt:P31 ?class. Raja elemente saad lisada kaldkriipsuga (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. See on võrdväärne mõlema järgmise näitega: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Harjutus: kirjuta ümber \"Bachi lapselaste\" päring varasemast, kasutades seda süntaksit.Tärn (*) raja elemendi järel tähendab “null või enam seda elementi”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included. Contents 1 Before we start 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Վարժություն 7.1.1 Արթուր Կոնան Դոյլի գրքեր 7.1.2 Քիմիական տարրեր 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Ներկարարական նյութեր 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Տես նաև Before we start While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} կամ սա, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language օրինակ SPARQL example sentence Juliet loves Romeo. ժամանակահատված juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. ստորակետ romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. չակերտներ juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Vikiveri Sorgu Servisi, Vikiveri'nin içeriği hakkında fikir sahibi olmak için güçlü bir araçtır. Bu rehber size nasıl kullanılacağını öğretecektir. Ayrıca Wikimedia İsrail tarafından oluşturulmuş etkileşimli öğreticiye bakabilirsiniz.Kendi SPARQL sorgunuzu yazmadan önce, sorgunuzun zaten daha önce {{Item documentation}} ya da diğer genel SPARQL sorgu şablonlarına dâhil edilip edilmediğine bakın. Contents 1 Başlamadan önce 2 SPARQL temelleri 3 İlk sorgumuz 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Data types 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 See also Başlamadan önce Bu rehber çok uzun ve korkutucu görünmekle birlikte lütfen bunun sizi korkutmasına izin vermeyin! Sadece SPARQL temellerini öğrenmek bile uzun vadede işinize yarayacaktır. İlk sorgumuzdan sonra okumayı bıraksanız bile birçok ilginç sorgu oluşturacak kadar konuyu zaten anlayacaksınız. Bu eğitimin her bölümü daha güçlü sorgular yazmanızı sağlayacaktır.Daha önce Vikiveri, SPARQL veya WDQS'i hiç duymadıysanız bu terimlerin kısa bir açıklaması karşınızda: Vikiveri, bir bilgi veritabanıdır. \"Kanada'nın başkenti Ottawa'dır\" ya da \"Mona Lisa kavak ağacı üzerine yağlı boyayla boyanmıştır\" veya \"altın 1.064.18 santigrat derece erime noktasına sahiptir\" gibi milyonlarca cümle içerir. SPARQL, bilgi veritabanları için sorular (sorgular) formüle etmek için kullanılan bir dildir. Doğru veritabanıyla bir SPARQL sorgusu \"müzikte en popüler tonalite nedir?\", en çok hangi oyuncu hangi karakteri canlandırdı?, \"kan gruplarının dağılımı nedir?\" veya \"hangi yazarın eserleri bu yıl yayımlandı?\" gibi sorulara cevap verebilir. WDQS, Vikiveri Sorgu Hizmeti, şu ikisini bir araya getirir: Bir SPARQL sorgusu girince bunu Vikiveri veri kümesine karşı çalıştırır ve sonucu gösterir.  SPARQL temelleri Basit bir SPARQL sorgusu şöyle görünür: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT yan tümcesi, döndürülmesini istediğiniz değişkenleri listeler (değişkenler bir soru işareti ile başlar) ve WHERE yan tümcesi, çoğunlukla üçlü formda olan kısıtlamaları içerir. Vikiveri'deki tüm bilgiler (ve benzer bilgi veritabanları) üçlü şeklinde saklanır; sorguyu çalıştırdığınızda sorgu hizmeti değişkenleri gerçek değerlerle doldurmaya çalışır, böylece elde edilen üçlüler bilgi veritabanında görünür ve bulduğu değişkenlerin her birleşimi için bir sonuca çevirir. Üçlü, bir cümle gibi (bu nedenle bir nokta ile biter) bir özne, bir yüklem ve bir nesne ile okunabilir: SELECT ?meyve
WHERE
{
  ?meyve rengi sarı.
 ?meyve tadı ekşi.
} Bu sorgu için sonuçlar arasında örneğin “limon” yer alabilir. Vikiveri'de çoğu özellik sahiplik anlamı içerir, bu nedenle sorguyu bu şekilde okuyabiliriz: SELECT ?meyve
WHERE
{
  ?meyve rengi sarı.
 ?meyve tadı ekşi.
} yüklemlerin sahiplik özelliğini bu örnekte gözlemleyebiliriz. “‘sarı’ renge sahip ?meyve ” (“sarı renkte ki ?meyve ” değil – sahiplik özelliğine hiyerarşik yapıda ki Üçlü'ler arasında dikkat edin!)Bu örnek WDQS için iyi bir örnek değildir. Tat subjektif bir yüklem olduğu için Vikiveri tat yüklemini kullanmaz. Bunun yerine hiyerarşik bir düzene sahip kaynak/alt-öğe ilişkileri tercih edilir. İlk sorgumuz Barok dönem bestekarlarından Johann Sebastian Bach'ın bütün çocuklarını listeleyelim. Yukarıda gördüğümüz Üçlü elementleriyle nasıl sorgu oluşturabilirsiniz?Umarız aşağıdakine benzer bir sorgu oluşturdunuz: SELECT ?çocuk
WHERE
{
  #  çocuk \"ebeveyne sahip\" Bach
  ?çocuk ebeveyn Bach.
  # (not: '#' karakterinden sonra yazılanlar yorum olarak algılanır ve WDQS sorgusu için kullanılmaz.)
} ya da bu, SELECT ?çocuk
WHERE
{
  # çocuk \"babasına sahip\" Bach 
  ?çocuk baba Bach. 
} ya da bu, SELECT ?çocuk
WHERE
{
  #  Bach \"çocuğa sahip\" çocuk
  Bach çocuk ?çocuk.
} ilk iki Üçlü Bach isminde ebeveyni/babası olan ?çocuk aratırken, üçüncü Üçlü ?çocuk sahibi Bach aratmaktadır. İkinci örneği kullanarak devam edelim.Peki bunları düzgün bir WDQS sorgusuna çevirmek için ne yapmalıyız? Vikiveri'de özneler ve özellikler, ”baba” (özellik) ya da ”Bach” (özne) gibi insanlar tarafından okunabilir isimler tarafından tanımlanmazlar. (Bunun iyi bir nedeni var; ”Johann Sebastian Bach” Alman ressam'a, veya ”Bach” soyadı'na, Fransız komünü'ne, Merkür krateri'ne, vb) ait olabilir. Bu yüzden Vikiveri özne ve özelliklere bir tanımlama numarası atamaktadır. Bu tanımlama numaralarını bulmak için, ara'dan özneyi bulup, (detaylarını okuyup) doğru olduğunu düşündüğünüz sonucun Q-numarasını kopyalayın. Bir özelliğin tanımlama numarasını bulmak için aynı şeyi yapabiliriz, lakin bu sefer arama kriterini ”arama kriteri” yerine “P:arama kriteri” şeklinde düzenlemeniz gerekmektedir. Bu arama sonucu bize ünlü bestekar Johann Sebastian Bach'ın tanımlama numarasının Q1339 olduğunu, ve babasını tanımlayan özelliğin tanımlama numarasının P:P22 olduğunu gösterir. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, adalah perkakas hebat yang dapat memberikan wawasan konten yang ada di Wikidata. Panduan ini akan mengajarkanmu cara menggunakannya. Lihat pula tutorial interaktif oleh Wikimedia Israel.Sebelum menulis kueri SPARQL Anda sendiri, periksa {{Item documentation}} atau templat kueri SPARQL generik lainnya dan lihat apakah kueri Anda sudah ada. Contents 1 Sebelum kita mulai 2 Dasar-dasar SPARQL 3 Kueri pertama kita 3.1 Pelengkap otomatis 4 Pola tripel lanjut 5 Instans and kelas 5.1 Jejak atribut 6 Penjelas 7 ORDER dan LIMIT 7.1 Latihan 7.1.1 Buku-buku Arthur Conan Doyle 7.1.2 Unsur-unsur Kimia 7.1.3 Sungai-sungai yang mengalir ke Mississippi 7.1.4 Sungai yang mengalir ke Mississippi II 8 OPTIONAL 9 Ekspresi, FILTER dan BIND 9.1 Tipe-tipe data 9.2 Operator-operator 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Pengelompokkan 10.1 Populasi kota 10.2 Material lukisan 10.3 Senjata berdasarkan pembuat 10.4 Penerbit berdasarkan banyaknya halaman 10.4.1 HAVING 10.5 Rangkuman fungsi agregat 10.6 Kutu wikibase:Label dan agregasi 11 VALUES 12 Label in multiple languages 13 Dan seterusnya... 14 Lihat pula Sebelum kita mulai Meskipun panduan ini tampak panjang dan menakutkan, tolong jangan terusir! Pelajari saja dasar-dasar SPARQL sembari jalan – bahkan jika kamu berhenti membaca setelah kueri pertama kita, kamu akan sudah cukup paham bagaimana merakit kueri-kueri yang menarik. Setiap bab dari tutorial ini akan memberdayakanmu untuk menulis kueri yang lebih canggih.Kalau kamu belum pernah mendengar Wikidata, SPARQL atau WDQS sebelumnya, berikut ini penjelasan singkat istilah-istilah tersebut: Wikidata adalah basisdata pengetahuan. Ia mengandung jutaan pernyataan, seperti “Ibukota Kanada adalah Ottawa”, atau “Mona Lisa dilukis dengan cat minyak pada kayu poplar”, atau “emas memiliki titik lebur 1,064.18 derajat Celsius”. SPARQL adalah bahasa untuk memformulasi pertanyaan (kueri) pada basisdata pengetahuan. Pada basisdata yang tepat, kueri SPARQL dapat menjawab pertanyaan-pertanyaan seperti “apakah tonalitas di musik yang paling populer?” atau “karakter apa yang paling banyak diperankan oleh para aktor?” atau “bagaimana distribusi golongan darah?” atau “karya penulis apa saja yang jadi domain publik tahun ini?”. WDQS, Wikidata Query Service, menyambung kedua hal tersebut: Kamu memasukkan kueri SPARQL, WDQS menjalankannya terhadap dataset Wikidata dan memberikan hasilnya kepadamu.  Dasar-dasar SPARQL Kueri SPARQL sederhana tampak seperti ini: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Klausa SELECT mendaftarkan variabel yang kamu mau dapatkan (variabel diawali tanda tanya), dan klausa WHERE mengandung batasan-batasannya, umumnya dalam bentuk kumpulan tripel. Semua informasi di Wikidata (dan basisdata pengetahuan sejenisnya) disimpan dalam bentuk kumpulan tripel; tiap kali kamu menjalankan kueri, layanan kueri mencoba mengisikan variabel-variabel dengan nilai yang sesuai dengan tripel-tripel yang ada di basisdata pengetahuan, dan mengembalikan satu hasil untuk setiap kombinasi variabel-variabel yang ditemukan. Sebuah tripel dapat dibaca seperti layaknya kalimat (itulah sebabnya diakhiri tanda titik) yang terdiri dari \"subjek\", \"predikat\", dan \"objek\". SELECT ?buah
WHERE
{
  ?buah berwarna kuning.
  ?buah berasa asam.
} Hasil dari kueri ini dapat mencakup, misalnya \"jeruk nipis\". Di Wikidata, kebanyakan atribut adalah atribut \"ber-\" sehingga kueri juga dapat dibaca: SELECT ?buah
WHERE
{
  ?buah warna kuning.
  ?buah warna asam.
} yang dibaca sebagai “?buah ber warna ‘kuning’” (bukan “?buah adalah warna ‘kuning’” – ingatlah bahwa pasangan atribut seperti “orangtua”/“anak”!).Bagaimanapun, itu bukan contoh yang baik untuk WDQS. Rasa adalah hal yang subjektif sehingga Wikidata tidak memiliki atribut seperti itu. Lebih baik kita bayangkan tentang relasi orangtua/anak yang umumnya tidak rancu. Kueri pertama kita Andaikan kita ingin mendaftarkan semua anak dari komponis baroque Johann Sebastian Bach. Dengan menggunakan pseudo-elemen seperti kueri-kueri di atas, bagaimana kamu akan menuliskan kueri?Semoga kamu mendapatkan yang seperti berikut: SELECT ?anak
WHERE
{
  #  anak \"punya orang tua\" Bach
  ?anak orangtua Bach.
  # (cat: semua yang muncul setelah tanda '#' adalah komentar yang diabaikan oleh WDQS.)
} atau ini, SELECT ?anak
WHERE
{
  # anak \"punya bapak\" Bach 
  ?anak bapak Bach. 
} atau ini, SELECT ?anak
WHERE
{
  #  Bach \"punya anak\" anak
  Bach anak ?anak.
} Kedua tripel pertama mengatakan bahwa ?anak harus memiliki orangtua/bapak Bach; yang ketiga mengatakan bahwa Bach harus memiliki anak ?anak. Mari kita pakai yang kedua untuk saat ini.Sekarang tinggal bagaimana mengubah hal-hal tersebut menjadi kueri WDQS yang layak. di Wikidata, butir dan atribut tidak diidentifikasi dengan nama yang mudah dibaca seperti \"bapak\" (atribut) atau \"Bach\" (butir). (\"Johann Sebastian Bach\" juga adalah nama untuk Pelukis Jerman, dan \"Bach\" mungkin juga merujuk ke nama marga, komune di Perancis, kawah di Merkurius, dst.) sebagai gantinya, butir dan atribut Wikidata diberi penanda unik. Untuk mencari penanda suatu butir, kita cari butir tersebut dan salin Q-angka dari hasil yang paling pas dengan yang kita cari (misalnya, berdasarkan pemerian). Untuk mencari penanda atribut, kita lakukan yang sama. hanya saja pencariannya menggunakan \"P:istilah pencarian\" dan bukan sekadar \"istilah pencarian\" sehingga pencariannya dibatasi hanya pada atribut saja. Dari sini kita tahu bahwa komponis terkenal Johann Sebastian Bach adalah Q1339, dan atribut yang menentukan bapak dari butir adalah P:P22.Akhirnya, kita perlu menambahkan prefiks. untuk tripel-tripel WDQS sederhana, butir-butirnya perlu diawali wd: dan wdt: untuk atribut. (ini hanya berlaku untuk nilai yang sudah tetap – variabel tidak membutuhkan prefix!)Menggabungkan itu semua, sampailah kita pada kueri WDQS kita pertama yang layak: SELECT ?anak
WHERE
{
# ?anak bapak Bach.
  ?anak wdt:P22 wd:Q1339.
}
 Try it! klik tautan \"Cobalah\" dan \"Jalankan\" kueri di halaman WDQS. Apa yang kamu dapatkan? ?anak wd:Q57225 wd:Q76428 … Tampak tidak menarik. Kamu hanya melihat penanda-penanda. Kamu bisa klik pada penanda tersebut untuk melihat halaman Wikidatanya (termasuk label yang berterbaca manusia), tapi bukankah ada cara yang lebih baik untuk melihat hasilnya?Ternyata ada! (pertanyaan retoris itu keren, kan?) kalau kamu tambahkan teks ajaib berikut SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } di beberapa tempat dalam klausa WHERE, kamu bisa menemukan variabel tambahan: untuk setiap variabel ?anu di kuerimu, kamu juga bisa menggunakan variabel ?anuLabel yang mengandung label dari butir dibalik ?anu. Kalau kamu tambahkan ini ke klausa SELECT, kamu akan mendapatkan tidak hanya butir tetapi juga labelnya: SELECT ?anak ?anakLabel
WHERE
{
# ?anak bapak Bach.
  ?anak wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Coba jalankan kueri tersebut – kamu semestinya dapat melihat tidak hanya nomor butir, tetapi juga nama dari anak-anak. anak anakLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Pelengkap otomatis potongan SERVICE tampak sulit diingat? menggunakan fungsi pencarian tiap kali menulis kueri juga agak membosankan. Untungnya, WDQS menawarkan solusi untuk ini: \"Pelengkap otomatis\". di penyunting kueri query.wikidata.org, kamu bisa menekan kombinasi tombol Ctrl+Spasi dimanapun pada kueri dan kode yang pas akan disarankan; pilih saran yang paling pas dengan tombol panah atas/bawah, dan tekan Enter untuk memilihnya.Sebagai contoh, alih-alih selalu menulis SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }, kamu cukup mengetik SERV, tekan Ctrl+Spasi, dan saran pertama adalah rapalan layanan yang lengkap dan siap digunakan! Cukup tekan Enter untuk memakainya. (pemformatannya mungkin berbeda tapi itu lain soal.)Pelengkap otomatis juga bisa mencarikan untukmu. Jika kamu ketikkan salah satu prefiks Wikidata seperti wd: atau wdt: dan tulis teks setelahnya, Ctrl+Spasi akan mencari teks tersebut pada Wikidata dan menyarankan hasilnya. wd: mencari butir sedangkan wdt: untuk atribut. Sebagai contoh, alih-alih mencari butir untuk Johann Sebastian Bach (Q1339) dan father (P22), kamu cukup mengetikkan wd:Bach dan wdt:bapak kemudian pilih saran yang paling pas dari pelengkap. (Hal ini juga berlaku pada teks yang mengandung spasi seperti wd:Johann Sebastian Bach.) Pola tripel lanjut Jadi kita sudah lihat semua anak-anak dari Johann Sebastian Bach – lebih tepatnya: semua butir yang memiliki bapak Johann Sebastian Bach. tetapi Bach punya dua istri, dan butir-butir tersebut punya dua ibu yang berbeda: Bagaimana jika kita hanya ingin melihat anak-anak Johan Sebastian Bach dari istri pertama, Maria Barbara Bach (Q57487)? Coba tulis kueri tersebut berdasarkan kueri sebelumnya di atas.Sudah? Oke, sekarang langsung ke solusi! solusi paling sederhana adalah dengan menambahkan tripel kedua dengan pembatas tersebut: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339.
  ?anak wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! dalam Bahasa Indonesia, ini dibaca: Anak memiliki bapak Johann Sebastian Bach. Anak memiliki ibu Maria Barbara Bach. terdengar aneh? dalam bahasa sehari-hari kita bisa menyingkat ini menjadi: Anak memiliki bapak Johann Sebastian bach dan ibu Maria Barbara Bach. Bahkan, penyingkatan ini juga mungkin diekspresikan dalam SPARQL juga: jikan kamu menakhiri suatu tripel dengan titik koma (;) dan bukannya tanda titik, kamu bisa menambahkan pasangan predikat-objek. Dengan demikian kueri kita bisa juga disingkat menjadi: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! yang mengembalikan hasil yang sama tetapi dengan lebih sedikit pengulangan pada kueri.Sekarang coba bayangkan, dari hasil-hasil tersebut, kita hanya tertarik pada anak-anak yang juga merupakan komponis dan pianis. Atribut dan butir yang relevan untuk hal ini adalah occupation (P106), composer (Q36834) dan pianist (Q486748). Coba perbarui kueri di atas dengan menambahkan pembatasan tersebut!Berikut ini solusi saya: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Tanda ; digunakan dua kali lebih banyak untuk menambahkan kedua pekerjaan yang diperlukan. Seperti yang mungkin kamu perhatikan, masih ada beberapa pengulangan seperti jika kita mengatakan: Anak memiliki pekerjaan komponis dan pekerjaan pianis. yang mungkin kita bisa singkat sebagai: Anak memiliki pekerjaan komponis dan pianis. dan SPARQL memiliki sintaks untuk itu juga: sama seperti ; bisa digunakan untuk menambahkan pasangan atribut-objek pada suatu tripel (menggunakan subjek yang sama), tanda , bisa digunakan untuk menambahkan objek pada tripel (mengulang penggunaan kedua subjek dan predikat). Dengan demikian, kuerinya dapat disingkat menjadi: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Catatan: indentasi dan spasi tidak berpengaruh – Saya hanya mengindentasi kueri supaya lebih mudah dibaca. Kamu juga bisa menulis ini sebagai: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # kedua pekerjaan dalam satu baris
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! atau, agak tidak terlalu mudah dibaca: SELECT ?anak ?anakLabel
WHERE
{
  ?anak wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # tanpa adanya indentasi, membedakan antara ; dan , menjadi lebih sulit
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Untungnya, penyunting WDQS mengindentasi tiap baris secara otomatis sehingga kamu tidak perlu khawatir tentang hal ini.Baiklah, mari kita coba rangkum sampai di sini. Kita telah melihat kueri yang terstruktur seperti teks. Setiap tripel tentang suatu subjek diakhiri oleh titik. Beberapa predikat tentang subjek yang sama dipisahkan titik koma, dan beberapa objek pada subjek dan predikat yang sama dapat didaftarkan dengan dipisah oleh koma. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Sekarang Saya mau memperkenalkan satu lagi singkatan yang ditawarkan SPARQL. Jadi kalau kamu mau mendengarkan skenario khayalan satu lagi...Misalkan kita tidak tertarik dengan anak-anaknya Bach (Siapa tahu, mungkin kamu sebetulnya berpikir demikian) tetapi kita tertarik pada cucu-cucunya (misalkan). Ada satu permasalahan di sini: cucu dari Bach yang lewat jalur ibu atau bapak? keduanya atribut yang berbeda sehingga jadi agak menjengkelkan. Sebagai gantinya, mari kita putar saja relasinya: Wikidata juga punya atribut \"anak\" P:P40 yang menunjuk dari orangtua ke anak dan juga bebas gender. Dengan informasi ini, bisakah kamu menulis kueri yang mengembalikan cucu-cucu dari Bach?Berikut ini solusi saya: SELECT ?cucu ?cucuLabel
WHERE
{
  wd:Q1339 wdt:P40 ?anak.
  ?anak wdt:P40 ?cucu.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! dalam bahasa manusia, ini dibaca: Bach memiliki anak ?anak. ?anak memiliki anak ?cucu. Sekali lagi, Saya sarankan agar kita menyingkan kalimat ini. Kemudian Saya akan perlihatkan bagaimana SPARQL mendukung penyingkatan serupa. Perhatikan bagaimana kita sebetulnya tidak terlalu peduli tentang anaknya: kita tidak perlu menggunakan variabel kecuali untuk membahas tentang cucu sehingga kita dapat menyingkat kalimatnya menjadi: Bach memiliki anak seseorang yang memiliki anak ?cucu. Alih-alih mengatakan siapa anaknya Bach, kita cukup sebut dengan \"seseorang\": kita tidak peduli siapa dia tapi kita bisa menrujuk balik ke mereka karena kita mengatakan \"seseorang yang\": bagian ini memulai klausa relatif dan dalam klausa relatif kita bisa mengatakan hal-hal tentang \"seseorang\" (mis. apakah dia \"memiliki anak ?cucu\"). Dengan kata lain, \"seseorang\" adalah variabel khusus yang hanya valid dalam klausa relatif ini dan kita tidak perlu secara eksplisit merujuk padanya (kita katakan \"seseorang yang begini dan melakukan itu\" dan bukan \"seseorang yang begini dan seseorang yang melakukan itu\", itu bisa jadi dua \"seseorang\" yang berbeda).dalam SPARQL, hal ini dapat dituliskan sebagai: SELECT ?cucu ?cucuLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?cucu ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Kamu bisa menggunakan pasangan kurung siku ([]) sebagai variabel yang berperan sebagai variabel anonim. Di dalam kurung, kamu bisa menambahkan pasangan predikat-objek, sama seperti ketika setelah tanda ; setelah suatu tripel biasa; subjek implisit dalam hal ini adalah variabel anonim yang direpresentasikan oleh kurung. (Catatan: seperti juga setelah tanda ;, kamu dapat menambahkan lebih banyak pasangan predikat-objek dengan titik koma, atau objek-objek lainnya untuk predikat yang sama dengan koma.)Begitulah pola tripel! tentunya masih ada hal lainnya tentang SPARQL. tetapi sambil kita kesampingkan dulu hal tersebut, saya mau membuat rangkuman sekali lagi: bahasa manusia contoh SPARQL contoh kalimat Juliet mencintai Romeo. titik juliet mencintai romeo. konjungsi (klausa) Romeo mencintai Juliet dan membunuh dirinya. titik-koma romeo mencintai juliet; membunuh romeo. konjungsi (nomina) Romeo membunuh Tybalt dan dirinya. koma romeo membunuh tybalt, romeo. klausa relatif Juliet mencintai seseorang yang membunuh Tybalt. tanda kurung juliet mencintai [ membunuh tybalt ].  Instans and kelas Sebelumnya, Saya sebutkan bahwa kebanyakan atribut Wikidata adalah relasi \"ber-\" atau \"punya\": \"punya\" anak, \"punya\" bapak, \"punya\" pekerjaan. Kadang kala (bahkan mungkin sering) kamu juga perlu mengatakan bahwa sesuatu \"adalah\" namun kenyataannya ada dua jenis relasi untuk hal tersebut: Gone with the Wind adalah film. Film adalah karya seni. Gone with the Wind adalah suatu film. Ia memiliki suatu sutradara (Victor Fleming), memiliki durasi tertentu (238 menit), daftar pemeran (Clark Gable, Vivien Leigh, …), dan seterusnya.\"Film\" adalah konsep yang umum. Film bisa punya sutradara, durasi, dan daftar pemeran, namun konsep \"film\" tidak mesti punya sutradara, durasi, atau daftar pemeran tertentu. Walaupun suatu film \"adalah\" karya seni dan karya seni biasanya punya pencipta, konsep \"film\" itu sendiri tidak punya pencipta – hanya \"instans\" dari konsep ini yang punya.Perbedaan inilah kenapa ada dua atribut untuk \"adalah\" di Wikidata instance of (P31) dan subclass of (P279). \"Gone with the Wind\" adalah instans tertentu dari suatu kelas \"film\"; kelas \"film\" adalah subkelas (kelas yang lebih spesifik; spesialisasi) dari kelas yang lebih umum yaitu \"karya seni\".Untuk membantumu memahami bedanya, kamu bisa coba menggunakan dua predikat yang berbeda: \"adalah suatu\" dan \"adalah jenis dari\". Jika sesuatu \"adalah jenis dari\" karya (mis. film \"adalah jenis dari\" karya seni), itu menunjukkan bahwa kamu sedang membahas subkelas, spesialisasi atau pengkhususan dari kelas yang lebih luas dan kamu seharusnya menggunakan subclass of (P279). Jika sesuatu bukan \"adalah jenis dari\" karya (mis. kalimat \"Gone with the wind \"adalah jenis dari\" film\" kurang masuk akal), itu menunnjukkan bahwa kamu sedang membahas instans tertentu dan kamu semestinya menggunakan instance of (P31).jadi apa artinya ini buat kita ketika kita sedang menulis kueri SPARQL? Ketika kita mau mencari \"semua karya seni\", tidak cukup hanya mencari semua butir yang merupakan instans langsung dari \"karya seni\": SELECT ?karya ?karyaLabel
WHERE
{
  ?karya wdt:P31 wd:Q838948. # instans dari karya seni
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Ketika tulisan ini ditulis (Oktober 2016), kueri tersebut hanya mengembalikan 2815 hasil – padahal, ada jauh lebih banyak karya seni daripada itu! Persoalannya adalah kueri ini melewatkan butir-butir seperti \"Gone with the Wind\", yang hanya merupakan instans dari \"film\", bukan \"karya seni\". \"film\" adalah subkelas dari \"karya seni\" namun kita perlu memberitahukan kepada SPARQL tentang hal ini ketika melakukan pencarian.Salah satu solusi yang mungkin untuk hal ini adalah menggunakan sintaks [] yang sudah kita bahas sebelumya: \"Gone with the Wind\" adalah instans dari \"suatu\" subkelas dari \"karya seni\". (Sebagai latihan, coba tuliskan kueri tersebut!) Namun masih ada beberapa masalah: Kita tidak lagi mencantumkan butir-butir yang merupakan instans langsung dari karya seni. Kita masih melewatkan butir-butir yang merupakan instans dari beberapa subkelas dari subkelas karya seni yang lain – sebagai contoh, \"Snow White and the Seven Dwarfs\" adalah film animasi, yang juga adalah film, yang juga adalah karya seni. Dalam hal ini, kita perlu menelusuri dua pernyataan \"subkelas dari\" – bisa juga tiga, empat, lima, berapapun. Solusinya: ?butir wdt:P31/wdt:P279* ?kelas. Ini artinya ada sesuatu yang \"adalah\" dan ada berapapun pernyataan \"subkelas dari\" di antara butir dan kelas tersebut. SELECT ?karya ?karyaLabel
WHERE
{
  ?karya wdt:P31/wdt:P279* wd:Q838948. # instans dari subkelas karya seni manapun
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Saya tidak menyarankan menjalankan kueri tersebut. WDQS mungkin saja (hampir) bisa menanganinya tetapi perambanmu mungkin akan membeku ketika mencoba menampilkan seluruh hasil saking banyaknya.)Sekarang kamu tahu caranya mencari semua karya seni, atau semua bangunan, atau semua permukiman manusia: mantra ajaibnya wdt:P31/wdt:P279* diikuti kelas yang sesuai. Hal ini menggunakan beberapa fitur SPARQL yang belum saya jelaskan tetapi sejujurnya ini merupakan hampir satu-satunya penggunaan fitur-fitur tersebut yang relevan. jadi, kamu tidak \"perlu\" memahami cara kerjanya sekarang untuk menggunakan WDQS secara efektif. Jika kamu ingin tahu, Saya akan jelaskan sedikit, tapi kamu juga bisa melewatkan bab berikut dan mengingat atau salin+tempel wdt:P31/wdt:P279* dari sini ketika kamu membutuhkannya. Jejak atribut Jejak atribut adalah cara singkat untuk menulis jejak atribut antara dua butir. Jejak paling sederhana adalah satu atribut yang membentuk tripel biasa: ?item wdt:P31 ?class. Kamu bisa menambahkan elemen jejak dengan tanda garis miring (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Ini ekuivalen dengan salah satu diantara: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Latihan: tulis ulang kueri \"cucu Bach\" sebelumnya menggunakan sintaks ini.Tanda bintang (*) setelah elemen jejak berarti “nol or lebih elemen ini”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Før vi går igang 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Tilfælde og klasser 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Kemiske elementer 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Datatyper 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Gruppering 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VÆRDIER 12 Label in multiple languages 13 And beyond… 14 Se også Før vi går igang While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} eller dette, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} eller dette, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! På engelsk vil det stå som: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Her er min løsning: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: naturligt sprog eksempel SPARQL eksempel sætning Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. komma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ].  Tilfælde og klasser Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # tilfælde af kunstværk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS: خدمة استعلام ويكي بيانات: هي أداة قوية لتوفير نظرة ثاقبة لمحتوى ويكي بيانات. سوف يعلمك هذا الدليل كيفية استخدامه. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents ١ قبل أن نبدأ ٢ أساسيات سباركل ٣ استعلامنا الأول ٣.١ إكما تلقائي ٤ أنماط ثلاثية متقدمة ٥ مثيلات وفئات ٥.١ مسارات الخاصية ٦ التصفيات ٧ ORDER وLIMIT ٧.١ تمرين ٧.١.١ كتب آرثر كونان دويل ٧.١.٢ العناصر الكيميائية ٧.١.٣ الأنهار التي تتدفق إلى المسيسيبي ٧.١.٤ الأنهار التي تتدفق إلى الميسيسيبي 2 ٨ OPTIONAL ٩ تعبيران: FILTER وBIND ٩.١ أنواع البيانات ٩.٢ المشغلون ٩.٣ FILTER ٩.٤ BIND، BOUND، IF ٩.٥ COALESCE ١٠ التجمع ١٠.١ سكان المدينة ١٠.٢ مواد الطلاء ١٠.٣ البنادق حسب الشركة المصنعة ١٠.٤ الناشرون حسب عدد الصفحات ١٠.٤.١ HAVING ١٠.٥ ملخص الدالات التجميعية ١٠.٦ wikibase:Label and aggregations ١١ VALUES ١٢ Label in multiple languages ١٣ وما وراء... ١٤ See also قبل أن نبدأ في حين أن هذا الدليل قد يبدو طويلا ومرهقا، فلا تدع هذا يخيفك! إن مجرد تعلم أساسيات سباركل سيوفر لك طريقا طويلا - حتى إذا توقفت عن القراءة بعد #استعلامنا الأول ، سوف تفهم بالفعل ما يكفي لبناء العديد من الاستعلامات المثيرة للاهتمام، سيقوم كل قسم من هذا البرنامج التعليمي بتمكينك من كتابة استعلامات أكثر فعالية.أيضا، إذا لم تكن قد سمعت من قبل عن ويكي بيانات أو سباركل أو خدمة استعلام ويكي بيانات من قبل، فإليك شرح موجز لتلك المصطلحات: ويكي بيانات هي قاعدة بيانات المعرفة، تحتوي على ملايين البيانات، مثل \"عاصمة كندا أوتاوا\"، أو \"الموناليزا مطلية بطلاء زيت على خشب الحور\"، أو \"الذهب له نقطة انصهار 1064.18 درجة مئوية\". 'SPARQL' هي لغة لصياغة أسئلة (استعلامات) لقواعد بيانات المعرفة، باستخدام قاعدة البيانات الصحيحة، يمكن أن يجيب استعلام سباركل على أسئلة مثل \"ما هي النغمة الأكثر شيوعا في الموسيقى؟\" أو \"أية شخصية تم تصويرها بواسطة أكثر الممثلين؟\" أو \"ما هو توزيع أنواع الدم؟ \"أو\" ما أعمال المؤلفين التي دخلت الملكية العامة هذا العام؟\". WDQS:خدمة استعلام ويكي بيانات تجمع الاثنين معا: يمكنك إدخال استعلام سباركل، فإنها تشغله تجاه مجموعة بيانات ويكي بيانات ويظهر لك النتيجة.  أساسيات سباركل يبدو استعلام سباركل بسيط مثل هذا: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} تسرد جملة SELECT المتغيرات التي تريد إرجاعها (تبدأ المتغيرات بعلامة استفهام)، وتحتوي جملة WHERE على قيود عليها، معظمها في صورة ثلاثيات، يتم تخزين جميع المعلومات في ويكي بيانات (وقواعد بيانات المعرفة المماثلة) في شكل ثلاثيات، عندما تقوم بتشغيل الاستعلام، تحاول خدمة الاستعلام ملء المتغيرات بالقيم الفعلية بحيث تظهر الثلاثيات الناتجة في قاعدة بيانات المعرفة، وترجع نتيجة واحدة لكل مجموعة من المتغيرات التي تعثر عليها. يمكن قراءة الثلاثي كجملة (وهذا هو السبب في أنه ينتهي بنقطة)، مع موضوع، ومسند، وكائن: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} قد تتضمن نتائج هذا الاستعلام، على سبيل المثال، \"ليمون\"، في ويكي بيانات، معظم الخصائص هي خصائص \"لديه\"-نوع ; لذا قد يقرأ الاستعلام بدلا من ذلك: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} الذي يقرأ مثل \"?fruit له لون \"أصفر\" (ليس \"?fruit is لون \"الأصفر\"، ضع هذا في الاعتبار لأزواج الخواص مثل \"الأم\"/\"الطفل\"!).ومع ذلك، هذا ليس مثالا جيدًا لـخدمة استعلام ويكي بيانات، الذوق شخصي; لذلك ليس لدى ويكي بيانات خاصية خاصة به، بدلا من ذلك، دعونا نفكر في العلاقات بين الوالد/الطفل، والتي لا لبس فيها في الغالب. استعلامنا الأول لنفترض أننا نريد سرد جميع أطفال الملحن الباروكي يوهان سيباستيان باخ، باستخدام عناصر زائفة كما في الاستعلامات أعلاه، كيف تكتب هذا الاستعلام؟نأمل أن يكون لديك شيء من هذا القبيل: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (ملاحظة: كل شيء بعد '#' هو تعليق ويتم تجاهله بواسطة خدمة استعلام ويكي بيانات.)
} أو هذا، SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} أو هذا، SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} تقول أول ثلاثيتين أن ?child يجب أن يكون له الوالد/الأب باخ، تقول الثالثة أن باخ يجب أن يكون الطفل ?child، لنذهب مع الثاني في الوقت الحالي.ما الذي يجب عمله حتى يتم تحويله إلى استعلام خدمة استعلام ويكي بيانات ملائم؟ في ويكي بيانات، لا يتم تحديد العناصر والخصائص بواسطة أسماء يمكن قراءتها بواسطة الإنسان مثل \"الأب\" (خاصية) أو \"باخ\" (عنصر). (لسبب وجيه: \"يوهان سيباستيان باخ\" هو أيضا اسم رسام ألماني، وقد يشير \"باخ\" أيضا إلى لقب، البلدية الفرنسية ، الحفرة الزئبقية، إلخ.) بدلا من ذلك، يتم تعيين معرف لعناصر وخصائص ويكي بيانات، للعثور على المعرف لعنصر; نحن نبحث عن العنصر وننسخ الرقم Q للنتيجة التي يبدو أنها العنصر الذي نبحث عنه (على أساس الوصف، على سبيل المثال)، للعثور على معرف خاصية; نفعل نفس الشيء، ولكن ابحث عن \"P:مصطلح البحث\" بدلا من \"مصطلح البحث\"، والذي يحدد البحث إلى الخصائص، هذا يخبرنا أن الملحن الشهير يوهان سيباستيان باخ هو Q1339، والخاصية التي تحدد اسم الأب هي P:P22وأخيرا وليس آخرا، نحتاج إلى تضمين البادئات، بالنسبة لمضاعفات خدمة استعلام ويكي بيانات البسيطة، يجب أن تبدأ العناصر بـwd:، وخصائص تحتوي على wdt:. (لكن هذا ينطبق فقط على القيم الثابتة، لا تحصل المتغيرات على بادئة!)بوضع هذا الأمر معا، نصل إلى أول طلب بحث في أول استعلام خدمة استعلام ويكي بيانات صحيح: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! انقر فوق ذلك الرابط \"جربه\"، ثم \"تشغيل\" الاستعلام على صفحة خدمة استعلام ويكي بيانات، على ماذا تحصل؟ طفل wd:Q57225 wd:Q76428 … حسنا هذا مخيب للآمال، أنت فقط ترى المعرفات، يمكنك النقر عليها لرؤية صفحة ويكي بيانات الخاصة بها (بما في ذلك تسمية يمكن قراءتها بواسطة البشر)، ولكن أليست هناك طريقة أفضل لرؤية النتائج؟حسنا، كما يحدث، هناك! (أليست الأسئلة الخطابية رائعة؟) إذا قمت بتضمين النص السحري SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } في مكان ما داخل عبارة WHERE ، تحصل على متغيرات إضافية: لكل متغير ?foo في استعلامك، لديك الآن أيضا متغير ?fooLabel، الذي يحتوي على تسمية العنصر خلف ?foo، إذا أضفت هذا إلى جملة SELECT، فستحصل على العنصر بالإضافة إلى تسميته: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! حاول تشغيل هذا الاستعلام - يجب ألا تشاهد فقط أرقام العناصر، بل أيضا أسماء مختلف الأطفال. طفل تسمية الطفل wd:Q57225 يوهان كريستوف فريدريك باخ wd:Q76428 كارل فيليب إيمانويل باخ …  إكما تلقائي يبدو أن مقتطف SERVICE صعب التذكر رغم ذلك، أليس كذلك؟ والقيام بوظيفة البحث طوال الوقت أثناء كتابة الاستعلام أمر ممل، لحسن الحظ، تقدم خدمة استعلام ويكي بيانات حلا رائعا لهذا: الإكمال التلقائي، في محرر استعلام query.wikidata.org، يمكنك الضغط على Ctrl+Space في أية نقطة في الاستعلام والحصول على اقتراحات للأكواد التي قد تكون مناسبة، حدد الاقتراح الصحيح باستخدام مفاتيح الأسهم up/down، ثم اضغط على Enter لتحديده.على سبيل المثال، بدلا من كتابة SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } في كل مرة، يمكنك فقط كتابة SERV، والضغط على Ctrl+Space، وسيكون أول اقتراح أن تعويذة خدمة التسمية الكاملة، جاهزة للاستخدام! ما عليك سوى الضغط على Enter لقبولها. (سيكون التنسيق مختلفا بعض الشيء، ولكن لا يهم ذلك).ويمكن للإكمال التلقائي أيضا البحث عنك، إذا كتبت إحدى بادئات ويكي بيانات، مثل wd: أو wdt:، ثم اكتب النص بعد ذلك، Ctrl+Space سيبحث عن هذا النص على ويكي بيانات ويقترح النتائج. wd: يبحث عن العناصر، wdt: عن الخصائص على سبيل المثال، بدلا من البحث عن العناصر الخاصة بـJohann Sebastian Bach (Q1339) وfather (P22)، يمكنك فقط كتابة wd:Bach وwdt:fath ثم حدد الإدخال الصحيح من الإكمال التلقائي، (هذا يعمل حتى مع المساحات في النص، مثل wd:Johann Sebastian Bach.) أنماط ثلاثية متقدمة حتى الآن رأينا جميع أطفال يوهان سيباستيان باخ - بشكل أكثر تحديدا: كل العناصر مع الأب يوهان سيباستيان باخ، لكن باخ كان عنده زوجتان; ولهذا فإن هاذين الأمرين لديهما أمان مختلفتان: ماذا لو كنا نريد فقط رؤية أطفال يوهان سيباستيان باخ مع زوجته الأولى ماريا باربرا باخ (Q57487)؟ حاول كتابة هذا الاستعلام، بناءً على الموجود أعلاه.فعلت ذلك؟ حسنا، ثم على الحل! أبسط طريقة للقيام بهذا هي إضافة ثلاثية ثانية مع هذا القيد: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! بالإنجليزية، هذا يقرأ: الطفل لديه الأب يوهان سيباستيان باخ. الطفل لديه الأم ماريا باربرا باخ. هذا يبدو محرجا بعض الشيء، أليس كذلك؟ باللغة الطبيعية، سنقوم باختصار هذا: الطفل لديه الأب يوهان سيباستيان باخ والأم ماريا باربرا باخ. في الواقع، من الممكن التعبير عن الاختصار نفسه بسباركل أيضا: إذا قمت بإنهاء ثلاثية بفاصلة منقوطة (;) بدلا من نقطة، يمكنك إضافة زوج آخر من كائن الأصل، هذا يسمح لنا باختصار الاستعلام أعلاه إلى: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! الذي له نفس النتائج، ولكن أقل تكرارا في الاستعلام.لنفترض الآن أنه من بين هذه النتائج، نحن مهتمون فقط بالأولاد الذين كانوا مؤلفين وملحنين وعازفي بيانو الخصائص والعناصر ذات الصلة هي occupation (P106) وcomposer (Q36834) وpianist (Q486748)، حاول تحديث الاستعلام أعلاه لإضافة هذه القيود!ها هو الحل الخاص بي: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! يستخدم هذا الاختصار ; مرتين إضافتين لإضافة المهنتين المطلوبتين، ولكن كما قد تلاحظ، لا يزال هناك بعض التكرار، هذا كما لو قلنا: الطفل لديه مهنة الملحن ومهنة عازف البيانو. والتي عادة ما نختصرها كما يلي: الطفل لديه مهنة الملحن وعازف البيانو. ولدى سباركل بعض البنية كذلك: تماما مثل ; تسمح لك بإلحاق زوج كائن أصلي إلى ثلاثي (إعادة استخدام الموضوع)، , تسمح لك بإلحاق كائن آخر إلى ثلاثية (إعادة استخدام كل الموضوع والمسند)، مع هذا، يمكن اختصار الاستعلام إلى: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ملاحظة: لا تهم المسافة البادئة والمسافة البيضاء الأخرى - لقد حددت مسافة الاستعلام فقط لجعلها أكثر قابلية للقراءة، يمكنك أيضا كتابته على النحو التالي: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # كل المهن في سطر واحد
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! أو، أقل سهولة في القراءة: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # عدم وجود مسافة بادئة يجعل من الصعب التمييز بين , و;
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! لحسن الحظ; يحرر محرر خدمة استعلام ويكي بيانات الخطوط لك تلقائيا،; لذلك لا داعٍ للقلق بشأن هذا الأمر.حسنا، دعونا نلخص هنا، لقد رأينا أن الاستعلامات منظمة مثل النص، يتم إنهاء كل ثلاثية حول موضوع من قبل فترة، ويتم فصل المسندات متعددة حول نفس الموضوع بواسطة فواصل منقوطة، ويمكن إدراج كائنات متعددة لنفس الموضوع والمسند مفصولة بفواصل. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} الآن أريد أن أقدم اختصارا آخر تقدمه سباركل، لذا; إذا كنت ستمتعني بسكريبت افتراضي آخر... Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? ها هو حلي: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! باللغة الطبيعية، هذا يقرأ: باخ لديه طفل ?child، ?child لديه طفل ?grandChild. مرة أخرى، أقترح أن نختصر هذه الجملة الإنجليزية، ثم أريد أن أريك كيف تدعم سباركل اختصارا مشابها، لاحظ كيف لا نهتم بالطفل: لا نستخدم المتغير إلا للحديث عن الحفيد، يمكننا بالتالي اختصار الجملة إلى: باخ لديه طفل لديه طفل ?grandChild. بدلا من قول من هو طفل باخ، نحن فقط نقول \"من شخص ما\": لا يهمنا من هو، ولكن يمكننا الرجوع إليهم لأننا قلنا \"شخص ما\" من \"\": هذا يبدأ بعلامة نسبية، وضمن تلك الفقرة النسبية يمكننا قول أشياء عن \"شخص ما\" (على سبيل المثال،?grandChild”))، بطريقة ما، يُعَد \"شخص ما\" متغيرا، ولكنه متغير خاص صالح فقط ضمن هذه الفقرة النسبية، وهو مصطلح لا نشير إليه صراحة (نحن نقول \"شخص ما يفعل هذا ويفعل ذلك\"، وليس \"شخص هل هذا هو وشخص ما يفعل ذلك\"، هذان \"شخصان\" مختلفان.بسباركل، يمكن كتابة هذا على النحو التالي: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! يمكنك استخدام زوج من الأقواس ([]) بدلا من متغير، والذي يعمل كمتغير مجهول، داخل الأقواس، يمكنك تحديد أزواج الأجسام الأصلية، مثلما يحدث بعد ; بعد ثلاثية عادية، الموضوع الضمني هو في هذه الحالة المتغير المجهول الذي تمثله الأقواس. (ملاحظة: كما هو الحال أيضا بعد ;، يمكنك إضافة المزيد من أزواج كائن البحث مع المزيد من الفواصل المنقوطة، أو المزيد من الكائنات لنفس المسند باستخدام الفواصل.)هذا كل شيء من أجل الأنماط الثلاثية! هناك أكثر من سباركل، ولكن عندما نوشك على ترك أجزاء منها تشبه إلى حد كبير اللغة الطبيعية، أود أن ألخص هذه العلاقة مرة أخرى: لغة طبيعية مثال سباركل مثال جملة جولييت تحب روميو. فترة جولييت تحب روميو. اقتران (شرط) روميو يحب جولييت و يقتل نفسه. فاصلة منقوطة روميو يحب جولييت; يقتل روميو. اقتران (اسم) روميو يقتل تيبالت و نفسه. فاصلة روميو يقتل تيبالت, روميو. جملة نسبية جولييت تحب الشخص الذي قتل تيبالت. أقواس جولييت تحب [ تقتل تيبالت ].  مثيلات وفئات في وقت سابق، قلت أن معظم خصائص ويكي بيانات هي علاقات \"لديه\": لديه طفل، لديه أب، لديه، لكن في بعض الأحيان (في الواقع، في كثير من الأحيان)، تحتاج أيضا إلى التحدث عن ما هو الشيء، لكن في الحقيقة هناك نوعان من العلاقات هناك: ذهب مع الريح هو فيلم. فيلم هو عمل فني. ذهب مع الريح هو فيلم خاص واحد، ولديه مخرج خاص (فيكتور فليمنج)، ومدة محددة (238 دقيقة)، وقائمة بأسماء الأعضاء (كلارك غيبل، فيفيان لي، ...)، وهكذا.فيلم هو مفهوم عام، يمكن أن يكون للأفلام مخرجون، ومدد، وأعضاء، ولكن المفهوم \"فيلم\" على هذا النحو لا يملك أي مخرج أو مدة معينة أو أعضاء معينين، وعلى الرغم من أن الفيلم هو عمل فني، وعادة ما يكون للعمل الفني منشئ، فإن مفهوم \"الفيلم\" نفسه لا يحتوي على منشئ، \"حالات\" خاصة فقط من هذا المفهوم.هذا الاختلاف هو سبب وجود خاصيتين لـ\"هو\" في ويكي بيانات: instance of (P31) وsubclass of (P279)، \"ذهب مع الريح\" هو مثال خاص للفئة \"فيلم\"، الفئة \"فيلم\" هي فئة فرعية (فئة أكثر تحديدا، تخصص) للفئة الأكثر عمومية \"أعمال فنية\". To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). إذن ماذا يعني هذا بالنسبة لنا عندما نكتب استعلامات سباركل؟ عندما نريد البحث عن \"كل الأعمال الفنية\"، لا يكفي البحث عن كل العناصر التي تكون حالات \"عمل فني\": SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # مثال على العمل الفني
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! كما أكتب هذا، هذا الاستعلام فقط يرجع 2815 نتيجة - من الواضح أن هناك أعمال فنية أكثر من ذلك! تكمن المشكلة في أن هذا يخطئ بعض العناصر مثل ذهب مع الريح، التي هي مجرد مثال \"فيلم\"، وليس \"عمل فني\"، \"الفيلم\" هي فئة فرعية من \"العمل الفني\"، ولكننا نحتاج إلى إخبار سباركل بأخذ ذلك في الاعتبار عند البحث.أحد الحلول الممكنة لهذا هو بناء الجملة [] الذي تحدثنا عنه: ذهب مع الريح مثال على الفئة الفرعية لبعض \"العمل الفني\". (للتمرين; حاول كتابة هذا الاستعلام!) ولكن ما زالت هناك مشكلات: لم نعد نضمِّن العناصر التي تمثل مثيلات مباشرة للعمل الفني. مازلنا نفتقد العناصر التي هي أمثلة لبعض الفئات الفرعية لبعض الفئات الفرعية الأخرى من العمل الفني - على سبيل المثال، سنو وايت والأقزام السبعة هو فيلم متحرك، وهو فيلم ، وهو عمل فني، في هذه الحالة، نحتاج إلى بياني \"فئة فرعية من\" - ولكن قد يكون أيضا ثلاثة أو أربعة أو خمسة أو أي رقم. الحل: ?item wdt:P31/wdt:P279* ?class: هذا يعني أن هناك \"مثال\" واحد ثم أي عدد من بيانات \"الفئة الفرعية\" بين العنصر والفئة. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # مثال على أية فئة فرعية من الأعمال الفنية
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (لا أوصي بتشغيل هذا الاستعلام، يمكن لخدمة استعلام ويكي بيانات التعامل معه (بالكاد فقط)، ولكن قد يتعطل متصفحك عند محاولة عرض النتائج لأن هناك الكثير منها.)الآن أنت تعرف كيفية البحث عن جميع الأعمال الفنية، أو جميع المباني، أو جميع المستوطنات البشرية: التعويذة السحرية wdt:P31/wdt:P279*، إلى جانب الفئة المناسبة، يستخدم هذا بعض ميزات سباركل التي لم أفسرها بعد، ولكن بصراحة تامة، هذا هو الاستخدام الوحيد الملائم لتلك الميزات; لذا لن تحتاج إلى فهم كيفية عملها من أجل استخدام خدمة استعلام ويكي بيانات بفعالية، إذا كنت تريد أن تعرف، سأشرحها قليلا، ولكن يمكنك أيضا تخطي القسم التالي وحفظ أو نسخ+لصق wdt:P31/wdt:P279* من هنا عندما تحتاج ذلك. مسارات الخاصية مسارات الخاصية هي طريقة لتدوين مسار خصائص بين عنصرين، أبسط مسار هو مجرد خاصية واحدة، والتي تشكل ثلاثية عادية: ?item wdt:P31 ?class. يمكنك إضافة عناصر مسار باستخدام شرطة مائلة للأمام (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. هذا يعادل أيا مما يلي: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. تمرين: قم بإعادة كتابة استعلام \"أحفاد باخ\" من قبل لاستخدام هذا النحو.علامة النجمة (*) بعد عنصر المسار تعني \"صفر أو أكثر من هذا العنصر. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS こと Wikidata Query Service は、Wikidata のコンテンツへの洞察を提供する強力なツールです。このガイドでは WDQS の使い方を説明します。interactive tutorial by Wikimedia Israel も参照してください。自分で SPARQL クエリを書く前に、{{Item documentation}}やその他の一般的な SPARQL クエリのテンプレートを調べて、その中にすでに書きたいクエリが含まれていないかどうか確認してください。 Contents 1 はじめる前に 2 SPARQLの基本 3 初めてのクエリ 3.1 自動補完 4 より進んだトリプルのパターン 5 インスタンスとクラス 5.1 プロパティパス 6 修飾子 7 ORDERとLIMIT 7.1 演習 7.1.1 アーサー・コナン・ドイルの本 7.1.2 化学元素 7.1.3 ミシシッピ川に流れ込む川 7.1.4 ミシシッピ川に流れ込む川 その2 8 OPTIONAL 9 式、FILTERとBIND 9.1 データ型 9.2 演算子 9.3 FILTER 9.4 BIND、BOUND、IF 9.5 COALESCE 10 グループ化 10.1 都市の人口 10.2 画材 10.3 メーカー別の銃 10.4 ページ数別の出版社 10.4.1 HAVING 10.5 集約関数の概要 10.6 wikibase:ラベルと集約 11 VALUES 12 Label in multiple languages 13 さらには… 14 関連項目 はじめる前に このガイドはとても長く威圧的に見えるかもしれませんが、どうか敬遠しないでください。SPARQLの基本を学ぶだけでも、かなりのことができるようになります。#初めてのクエリまでで読むのを止めたとしても、興味深いクエリをたくさん書くための知識としては十分です。さらにこのチュートリアルの各セクションを読めば、よりパワフルなクエリを書くことができるでしょう。WikidataやSPARQL、WDQSについて、これまでまったく聞いたことがない方のために、これらの用語について簡単に説明しておきましょう。 Wikidata は知識データベースです。「カナダの首都はオタワである」「モナリザはポプラの木に油絵の具で描かれている」「金の融点は1,064.18度である」といったような、何百万もの文から成ります。 SPARQL は知識データベースに対して定式化された質問（クエリ）を行うための言語です。適切なデータベースとSPARQLクエリがあれば、「音楽のもっとも主要な調性は?」「もっとも多くの俳優に演じられたキャラクターは?」「血液型の分布は?」「今年パブリックドメインになる作家の作品は?」といった疑問に答えることができます。 WDQS こと Wikidata Query Service は、上のふたつを統合したものです。SPARQLクエリを入力すると、Wikidataのデータセットに対して検索を行い、その結果を表示します。  SPARQLの基本 シンプルなSPARQLクエリは次のようなものです。 SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} SELECT節にはクエリの結果として得たい変数を列挙します（変数はクエスチョン・マークで始まります）。WHERE節はそれらの変数に対する制約からなり、ほとんどの場合はトリプルの形をとります。Wikidata（および類似の知識データベース）のすべての情報は、トリプルの形で保存されています。クエリが実行されると、クエリサービスは得たいトリプルの制約を満たすような変数の値を知識データベース上に見つけようと試みます。そしてそのような変数の組み合わせが見つかるごとに、それをひとつの結果として返します。 トリプルは主語、述語、目的語を持つ文のように読むことができます(トリプルがピリオドで終わるのはそのためです)。 SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} このクエリの回答は、例えば “lemon” です。Wikidataでは、ほとんどのプロパティは “has” の性質を持つプロパティです。そのためこのクエリは以下のように書いてもいいでしょう。 SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} これは?fruit has color ‘yellow’ と読めます（?fruit is the color of ‘yellow’ ではありません — parent/child のような対になるプロパティのためにこれは心に留めておいてください）。しかしながら、WDQSの説明のためには、これはあまりいい例ではありませんでした。taste（〜な味がする）は主観的なので、Wikidataにはこれに対応するプロパティがないのです。代わりに、たいていの場合においては曖昧さのない、parent/child（親／子）の関係について考えてみましょう。 初めてのクエリ バロック音楽の作曲家、ヨハン・ゼバスティアン・バッハの、すべての子供を列挙したいものと考えてみてください。上のクエリで見たような擬似要素を使うとして、あなたならどんなクエリを書きますか？こんな感じのクエリを書いたのではないでしょうか。 SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # （注：‘#’ より後ろはすべてはコメントで、WDQSには無視されます。）
} あるいはこんなのや、 SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} こんなのかもしれませんね。 SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} 最初のふたつのトリプルは、?childは parent/father に Bach を持っていなければならない、と言っています。3つめのは、Bach はその子供に?childを持っていなければならない、と言っています。ここでは2つめのを採用することにしましょう。では、これを適切なWDQSクエリに変換するためには、あと何が必要でしょうか。ウィキデータでは、項目やプロパティを特定するために使われているのは、例えば「父親」（プロパティ）とか、「バッハ」（項目）とかいった、人間にわかりやすい名前ではありません。（これにはちゃんとした理由があります。「ヨハン・ゼバスティアン・バッハ」はドイツの画家の名前でもありますし、「バッハ」は人物の姓であるだけでなく、フランスの自治体や、火星のクレーターなどの名前でもあり、これらを指しているかもしれないからです。） 代わりに、ウィキデータの項目とプロパティには、識別子が割り当てられています。ある項目の識別子を見つけるには、項目を検索して、（例えば説明文などから）それらしいものが見つかったら、その Q ナンバーをコピーします。プロパティの識別子を見つけるのにも同じことを行いますが、単に検索窓に探している言葉を入力するのではなく、「P:探している言葉」と入力すれば、プロパティに限定して検索を行います。この検索の結果として、あの有名な作曲家のヨハン・ゼバスティアン・バッハは Q1339 であり、そしてある人物の父親を指定するプロパティは P:P22 であることがわかります。最後に忘れてはいけないのが、接頭辞をつけることです。単純なWDQSトリプルでは、項目にはwd:を、そしてプロパティにはwdt:を、その頭につけなければいけません。（ただしこれは値が決まっているときだけにしてください。変数に接頭辞をつけてはいけません。）これをまとめると、初めての正しいWDQSクエリが出来上がります。 SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! 「Try it!」のリンクをクリックすると、WDQSのページでクエリが実行されます。結果はどうなりましたか？ child wd:Q57225 wd:Q76428 … うーんこれはちょっとがっかりですね。識別子しか表示されていません。識別子をクリックすれば該当のWikidataのページを見ることはできるのですが（そこには人にわかりやすいラベルもあるのですが）、検索結果を見るのにもうちょっといい方法はないのでしょうか？はい、実はこれがあるんですね！（修辞疑問文ってすごいと思いませんか？）次の魔法の一文を WHERE 節のどこかに追加すると、 SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } するとクエリ中のすべての変数に対して、自動的にひとつの変数が追加されます。例えば?fooという変数には?fooLabelという変数が追加され、この変数には?fooを満たす項目のラベルの値が保持されます。この変数をSELECT節に追加すれば、項目とともにそのラベルも得ることができます。 SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! このクエリを実行してみてください。すると項目番号だけでなく、色々と子供の名前が表示されるはずです。 child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  自動補完 でもこのSERVICEから始まるコードを覚えとくのはしんどそうですよね？　それにクエリを書くたびに検索を繰り返すのもうんざりですよね。幸いなことに、WDQSにはこれに対する大いなる解決策、つまり「自動補完」が用意されています。クエリエディタ query.wikidata.org でクエリを書いている途中に、どこででもいいので Ctrl+Space を押すと、そこで入力するのにふさわしいコードの候補が表示されます。そこで適当な候補を up/down の矢印キーで選んでから、Enter キーを押して確定してください。たとえば、SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }と毎回毎回入力する代わりに、SERVとだけ入力して、Ctrl+Space キーを押せばいいんです。すると一番上の候補に、ラベル用のこの魔法の一文がバッチリ表示されているものと思います。準備は整いました！あとは Enter キーを押してこれを確定させるだけです。（入力されたコードのフォーマットは少しばかり違っているかもしれませんが、問題ありません。）自動補完では検索も可能です。wd:やwdt:のようなWikidataの節頭辞を入力したあとに、続けて何か文字を入力し、Ctrl+Space キーを押すと、Wikidataをこの文字で検索し、検索結果を候補として表示します。wd:なら項目を検索しますし、wdt:ならプロパティを検索します。たとえば、Johann Sebastian Bach (Q1339)とfather (P22)を検索して探す代わりに、wd:Bachとwdt:fathとだけ入力して、表示された候補の中から正しいものを選ぶだけでいいのです。（この機能は、wd:Johann Sebastian Bachのようにテキスト中にスペースがある場合でも有効です。） より進んだトリプルのパターン そういうわけで、いまはヨハン・ゼバスティアン・バッハのすべての子供をみたところでした。より具体的にいうと、父親としてヨハン・ゼバスティアン・バッハを持つすべての項目を得たところです。しかしバッハには妻が2人いましたので、これらの項目は2つの異なる母親を持っています。もしヨハン・ゼバスティアン・バッハの、最初の妻であるマリア・バルバラ・バッハ (Q57487) との間の子供だけをみたい場合は、どうしたらいいでしょうか？　上で書いたクエリをもとに、このクエリを書いてみましょう。できましたか？　オッケー、では解答をみていくことにしましょう。いちばんシンプルな方法は、制約に2つめのトリプルを追加することです。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 英語に直すと、これは次のように読むことができます。 Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. 少しばかり不自然に聞こえますね。自然言語であれば、これは次のように略されるでしょう。 Child has father Johann Sebastian Bach and mother Maria Barbara Bach. 実は、SPARQLでも同様に、同じ省略を表現することが可能です。ピリオドの代わりにセミコロン (;) でトリプルを終えると、別の述語 ｰ 目的語の組を追加することができます。これにより上のクエリを次のように略すことが可能です。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 結果は同じですが、クエリ中の繰り返しは減らすことができました。では、ここまでの結果に加えて、作曲家かつピアニストである子供にしか興味がないとしたらどうでしょうか。これに適したプロパティと項目は、occupation (P106)とcomposer (Q36834)、そしてpianist (Q486748)です。私の解答は次のようになります。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! ここでは;を使った省略が、2つの必要な職業を追加するために、 さらに2回使われています。しかし、お気づきかもしれませんが、ご覧のようにここにもまだ繰り返しがあります。このコードだとあたかもこう言っているかのようです。 Child has occupation composer and occupation pianist. これを私たちは普通、こう略します。 Child has occupation composer and pianist. SPARQLにはこのためのシンタックスも同様にあります。;が述語と目的語の組をトリプルに追加することを（主語を再利用することによって）可能にしたのと同じように、,を使うことによって、別の目的語をトリプルに追加することが（主語と述語の双方を再利用することによって）可能になります。これによりクエリは次のように省略することができます。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 注：インデントやその他の空白は、実のところ重要ではありません。クエリがより読みやすくなるように、インデントしただけです。上のクエリは次のように書くことも可能です。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # 両方の職業を1行で
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! あるいは、だいぶ読みにくくはなりますが、次のようなのも可能です。 SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # インデントなし。これは ; と , の識別が難しくなる
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 幸いにもWDQSエディタは自動的に行をインデントしてくれますので、通常はこれを気にする必要はありません。さあ、ではここまでをまとめてみましょう。クエリは文章のように組み立てられることを見てきました。ある主語についてのトリプルは、それぞれがピリオドで終わります。同じ主語についての複数の述語は、セミコロンで区切られます。そして、同じ主語と述語に対する複数の目的語は、コンマで区切って列挙することが可能です。 SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} ここでSPARQLで使用可能なもうひとつの省略形を紹介したいと思います。いまいちど仮定のお話におつきあい願うことになりますが…本当はバッハの子供には関心はなかったとしましょう。（いや、これはひょっとすると、仮定の話ではなかったかもしれませんね！）子供ではなく、その「孫」に（仮定的に）興味があったのでした。ここで厄介な問題がひとつあります。孫は父親がバッハの子供なのかもしれないし、母親がバッハの子供なのかもしれない。どちらでもありうるのです。父親と母親は別々のプロパティなので、これは面倒です。代わりにぐるっと、関係を逆転させてしまいましょう。ウィキデータには「子」というプロパティもあって（P:P40 です）、これは親が主語になって親から子への関係性になるのと同時に、子供の性別を区別しないのです。これを念頭に、バッハの孫を返すクエリを書いてみましょう。書けましたか？私の解答はこうです。 SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 自然言語に直せば、これは次のように読むことができます。 Bach has a child ?child. ?child has a child ?grandChild. ここでも、上の文章を短縮することを提案します。その上で、SPARQLではどうしたら同様の省略をすることができるかお見せしたいと思います。子供に関心がない場合には、実際にはどうするか考えてみてください。孫のことを話すときにしか変数を使わない、というのが答えです。そこで上の文は次のように略すことができるはずです。 Bach has as child someone who has a child ?grandChild. ここではバッハの子供が誰かを言う代わりに、単に “someone” と言いました。それが誰であるかには関心がないからです。しかし someone 'who' と言っておくことで、それについて引き続き言及することができます。つまり関係節を作ることができ、その節の中で “someone” について何かをいうことができるということです。（たとえば、he or she “has a child ?grandChild” という風に。）ある意味で、 “someone” は変数なのです。ただしこの修飾節の中でのみ有効な特別な変数で、さらに、それに明示的に言及することはしない変数です（“someone who is this and does that” とは言いますが、“someone who is this and someone who does that” とは言いません。それだと someone は別々の違う「誰か」になるからです。）SPARQLでは、これを次のように書くことができます。 SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 変数のあった場所に角括弧の組を使うことができ ([])、これが無名変数として機能します。角括弧の中では述語 - 目的語の組を指定することができ、これは通常のトリプルの後に;を置いた場合と同様です。しかしここでの暗黙的な主語は、角括弧が示すところの無名変数になります。（注：;の後とこれもまた同様に、セミコロンを置けばさらに述語 - 目的語の組を追加することができますし、コンマを置けば述語を共有する目的語をさらに追加することができます。）これでトリプル・パターンについては終わりです！　SPARQLについてさらに見ていきますが、自然言語との類似性が高いパートを終えるに当たって、その関係をもう一度まとめておきたいと思います。 自然言語 例 SPARQL 例 文 Juliet loves Romeo. ピリオド juliet loves romeo. 接続詞（節の） Romeo loves Juliet and kills himself. セミコロン romeo loves juliet; kills romeo. 接続詞（名詞の） Romeo kills Tybalt and himself. コンマ romeo kills tybalt, romeo. 関係節 Juliet loves someone who kills Tybalt. 角括弧 juliet loves [ kills tybalt ].  インスタンスとクラス 先に私は、ほとんどのWikidataプロパティは “has” 関係だといいました。has child（子供を持つ）、has father（父親を持つ）、has occupation（職業を持つ）、といったように。しかし時には（実際のところはしばしば）、それがなんで「ある」か（what something is）を話す必要があります。しかし実はそこにも2種類の関係があるのです。 Gone with the Wind is a film.（『風と共に去りぬ』は映画である） A film is a work of art.（映画は芸術作品である） 『風と共に去りぬ』は一つの特定の映画です。そこには特定の監督（ヴィクター・フレミング）がおり、具体的な上映時間（238分）があり、キャストメンバー表（クラーク・ゲーブル、ヴィヴィアン・リー、…）があり、といった具合です。一方で「映画」は一般的な概念です。個々の映画は監督や上映時間やキャストを持つことができますが、「映画」という概念それ自体は、どんな特定の監督も上映時間もキャストも持ちません。そして映画は芸術作品であり（a film is a work of art）、芸術作品は通常その作者を持ちますが、「映画」という概念自体は作者を持ちません。この概念の特定の「実例（インスタンス）」のみが、それを持ちます。この違いゆえに、Wikidataには “is”（〜である）を表すプロパティが2つ、つまり instance of (P31) と subclass of (P279) があるのです。『風と共に去りぬ』は「映画」というクラスの特定のインスタンスです。「映画」というクラスは、より一般的なクラスである「芸術作品」の下位クラス（より具体的なクラス。特殊化）です。この違いをはっきりさせるためには、ふたつの違った動詞を使ってみることが役に立ちます。それは「〜である」と「一種の〜である」です。もし「一種の〜である」を使うことができる場合は（例えば映画は「一種の芸術作品である」のように）、下位クラス、つまりより広いクラスを特殊化したものについて話していることになるので、subclass of (P279)を使うべきです。もし「一種の〜である」が使えない場合は（例えば『風と共に去りぬ』は「一種の映画である」という文章は意味を成しません）、特定の実例について話していることになるので、instance of (P31)を使うべきです。ではSPARQLクエリを書く際にこれが意味することは何でしょうか。それは、「具体的な個々の芸術作品すべて」を検索したい時には、それが「芸術作品」に直接分類されているものをすべて検索したところで、それだけでは十分ではない、ということです。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # 芸術作品に分類されているもの
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! 私がこれを書いている2016年10月の時点では、上のクエリが返すのは2,815件の結果だけです。実際の芸術作品がこれより多いのは明らかです。問題は、このクエリの結果には、「芸術作品」ではなく「映画」にだけ分類されている『風と共に去りぬ』のような、そういった項目が欠けていることです。「映画」は「芸術作品」の下位クラスではあるのですが、SPARQLで検索するときには、これを考慮に入れて検索するよう明示的に指示しなければなりません。ひとつの可能な解決策としては、すでに触れた [] 構文を使うことがあります。『風と共に去りぬ』は「芸術作品」の下位クラスである何らかのクラスに分類される、と表現するのです（練習のために実際にこのクエリを書いてみてください）。しかしこれにも問題があります。 今度は「芸術作品」に直接分類されている項目が含まれなくなります。 また「芸術作品」の下位クラスであってもそれ以外の下位クラスに分類されている項目は含まれないままです。例えば「白雪姫」は「アニメ映画」に分類されていますが、これは「芸術作品」の下位クラスである「映画」のさらに下位クラスです。この場合、「下位クラス」であるという言明を2回繰り返さないと検索で到達することができません。しかし実際はこれは3回でもあり得ますし、4回や5回、いや何回でもあり得ます。 解決策はこうです。 ?item wdt:P31/wdt:P279* ?class ——これが意味するのは、itemはある一つのクラスclassに分類されるが、そのクラスはclassだけでなくその下位クラスであってもよく、さらにその下の下の、どれだけ下のクラスでもあってもよい、ということです。 SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # 芸術作品のあらゆる下位クラスに分類されているもの
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! （このクエリを実行することはお勧めしません。WDQSは（何とかかろうじて）このクエリを処理することはできますが、結果を表示をする際に、件数が多すぎてブラウザが落ちる可能性があるからです。）というわけで、すべての芸術作品、すべてのビル、すべての居留地を検索する方法がわかりました。魔法の呪文 wdt:P31/wdt:P279* を、適切な分類と一緒に使えばよいのです。このクエリではまだ説明していないSPARQLのワザも少しばかり使っていますが、ごく正直にいえば、それらのワザが役立つのはこの時ぐらいのものです。なのでWDQSを効果的に使うためにこの呪文の働きを理解する必要はありません。知りたい方のためにこの後すぐに説明しますが、でも次のセクションは飛ばして、wdt:P31/wdt:P279* だけ覚えておくか、必要な時にここからコピペしてもよいのです。 プロパティパス プロパティパスは、ふたつの項目をつなぐ複数のプロパティの経路（パス）を、ごく簡潔に書き記すための方法です。最もシンプルなパスは単一のプロパティからなります。これは通常のトリプル（3つ組）をつくります。 ?item wdt:P31 ?class. パスを構成する要素（プロパティ）を追加するにはスラッシュ (/) を使います。 ?item wdt:P31/wdt:P279/wdt:P279 ?class. これは以下の二つのいずれとも等しくなります。 ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. 練習として、先に出てきた「バッハの孫」のクエリを、この構文を使って書き直してみましょう。アスタリスク (*) をパス要素の後につけると、その要素のゼロ回以上の繰り返しが可能であることを意味します。 """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service, es una herramienta poderosa para proporcionar información sobre el contenido de Wikidata. Esta guía te enseñará cómo usarla. Mira también el tutorial interactivo de Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Antes de comenzar 2 Conceptos básicos de SPARQL 3 Nuestra primera query 3.1 Autocompletado 4 Funciones avanzadas 5 Instancias y clases 5.1 Propiedades y rutas 6 Calificadores 7 ORDER y LIMIT 7.1 Ejercicios 7.1.1 Libros de Arthur Conan Doyle 7.1.2 Elementos químicos 7.1.3 Ríos que desembocan en el Mississippi 7.1.4 Ríos que desembocan en el Mississippi II 8 OPCIONAL 9 Expresiones, FILTER y BIND 9.1 Tipos de datos 9.2 Operadores 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupación 10.1 Poblaciones de ciudades 10.2 Materiales de pintura 10.3 Armas por fabricante 10.4 Editores por cantidad de páginas 10.4.1 HAVING 10.5 Sumario de las funciones agregación 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 Y más allá… 14 Véase también Antes de comenzar Si bien esta guía puede parecer muy larga e intimidante, ¡no dejes que eso te asuste! El solo hecho de aprender los conceptos básicos de SPARQL te llevará lejos, incluso si dejas de leer después de #Nuestra primera query ya sabrás lo suficiente como para construir muchas consultas interesantes. Cada sección de este tutorial te permitirá crear consultas aún más complejas.Si nunca has oído hablar de Wikidata, SPARQL, o WDQS antes, aquí una breve explicación de estos términos: Wikidata es una base de datos de conocimiento. Contiene muchas declaraciones como \"la capital de Canadá es Ottawa\", o \"la Mona Lisa está pintada al óleo sobre madera de álamo\", o \"el oro tiene un punto de fusión de 1,064.18 grados Celsius\". SPARQL es un lenguaje para formular preguntas (consultas) para bases de datos de conocimiento. Con la base de datos adecuada, una consulta SPARQL podría responder a preguntas como \"¿cuál es la tonalidad más popular en la música?\" o \"¿qué personaje fue representado por la mayoría de los actores? o \"¿cuál es la distribución de los tipos de sangre? o \"¿qué obras pasaron a ser de dominio público este año?\" WDQS, el servicio de consulta de Wikidata, reúne ambas funciones: si escribes una consulta SPARQL, la ejecuta contra el conjunto de datos de Wikidata y te muestra el resultado.  Conceptos básicos de SPARQL Una consulta SPARQL sencilla tiene este aspecto: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La cláusula SELECT enumera las variables que deseas que se respondan (las variables comienzan con un signo de interrogación), y la cláusula WHERE contiene las restricciones, principalmente en forma de ternas. Toda la información en Wikidata (y bases de datos de conocimiento similares) se almacena en forma de terna; cuando se ejecuta una consulta, el servicio de consulta intenta completar las variables con valores reales para que las ternas resultantes aparezcan en la base de datos de conocimiento, y devuelve un resultado para cada combinación de variables que encuentra. Una terna se puede leer como una oración (por eso termina con un punto), con un \"sujeto\", un \"predicado\" y un \"objeto\": SELECT ?fruta
WHERE
{
  
?fruta tieneColor amarillo.
  ?fruta gusto agrio.
} Los resultados para esta consulta podrían incluir, por ejemplo, “limón”. En Wikidata, la mayoría de las propiedades se pueden leer como propiedades que comienzan con “tiene”, así que la consulta podría ser en su lugar: SELECT 
?fruta
WHERE
{
  
?fruta color amarillo.
  ?fruta gusto agrio.
} Lo cual se lee “?fruta tiene color ‘amarillo’” (no como “?fruta es de color ‘amarillo’” – ten esto en cuenta para los pares de propiedades como \"padre\" / \"niño\"!).Sin embargo, ese no es un buen ejemplo para WDQS. El gusto es subjetivo, por lo que Wikidata no tiene una propiedad para ello. En su lugar, pensemos en las relaciones entre padres e hijos, que en su mayoría son inequívocas. Nuestra primera query Supongamos que queremos enumerar a todos los hijos del compositor barroco Johann Sebastian Bach. Usando pseudo-elementos como en las consultas anteriores, ¿cómo escribirías esa consulta?Esperemos que tengas algo como esto: SELECT ?hijo
WHERE
{
  #  hijo \"tiene padre\" Bach
  ?hijo padre Bach.
  # (Nota: todo lo que se escribe después de un '#' es un comentario y es ignorado por WDQS.)
} O esto, SELECT ?hijo
WHERE
{
  # hijo \"tiene padre\" Bach 
  ?hijo papá Bach. 
} o esto, SELECT ?hijo
WHERE
{
  #  Bach \"tiene hijo\" hijo
  
Bach hijo ?hijo.
} Las primeras dos ternas dicen que el ?hijo debe tener el padre Bach; el tercero dice que Bach debe tener el hijo ?hijo. Vayamos con el segundo por ahora.Entonces, ¿qué queda por hacer para convertir esto en una consulta WDQS adecuada? En Wikidata, los elementos y las propiedades no se identifican con nombres legibles como \"padre\" (propiedad) o \"Bach\" (elemento). (Por una buena razón: \"Johann Sebastian Bach\" es también el nombre del pintor alemán, y \"Bach\" también puede referirse al apellido, o a la comuna francesa, o a cráter en Mercurio, etc.) En vez de nombres, a los elementos y propiedades de Wikidata se les asigna un identificador. Para encontrar el identificador de un elemento, buscamos el elemento y copiamos el número \"Q\" que corresponde al elemento que buscamos (lo podés identificar a partir de la descripción, por ejemplo). Para encontrar el identificador de una propiedad, hacemos lo mismo, pero buscamos \"P: término de búsqueda\" en lugar de solo el \"término de búsqueda\", lo que limita la búsqueda a las propiedades. Esto nos dice que el famoso compositor Johann Sebastian Bach es la Q1339, y la propiedad para designar al padre de un elemento es la P:P22.Por último pero no menos importante, necesitamos incluir los prefijos. Para las consultas de ternas simples, los items deberían tener como prefijo wd:, y las propiedades wdt:. (Esto solo aplica a valores fijos - las variables no tienen un prefijo)Juntando esto, llegamos a nuestra primera consulta WDQS: SELECT ?hijo
WHERE
{
# ?hijo padre Bach
  ?hijo wdt:P22 wd:Q1339.
}
 Try it! Haz clic en el enlace \"Pruébalo\", luego \"Ejecutar\" la consulta en la página WDQS. ¿Qué obtienes? Hijo wd:Q57225 wd:Q76428 … Bueno, eso es decepcionante. Acabamos de ver un listado con los identificadores (Q). Puedes hacer clic en ellos para ver su página en Wikidata (incluida la etiqueta legible por humanos), pero ¿no hay una mejor manera de ver los resultados?Bueno, ¡claro que la hay! (¿no son geniales las preguntas retóricas?) Solo tienes que incluir el texto mágico. SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } Dentro de la cláusula WHERE , puedes obtener variables adicionales: por cada variable ?foo en tu consulta, ahora también tienes una variable ?fooLabel, que contiene la etiqueta del elemento detrás de ?foo . Si agrega esto a la cláusula SELECT , obtendrás el artículo y su etiqueta: SELECT ?hijo ?hijoLabel
WHERE
{
# ?hijo padre Bach
  ?hijo wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Intente ejecutar la consulta nuevamente: deberías ver no solo las \"Q\" de los elementos, sino también los nombres de los distintos elementos. hijo hijoLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autocompletado El fragmento de SERVICE parece difícil de recordar, ¿verdad? Y pasar por la función de búsqueda todo el tiempo mientras escribimos la consulta también es tedioso. Afortunadamente, WDQS ofrece una gran solución para esto: \"autocompletar\". En el editor de consultas de query.wikidata.org, puedes presionar Ctrl+Space en cualquier punto de la consulta y obtener sugerencias para generar el código más apropiado; elige la sugerencia correcta con las teclas de flecha arriba / abajo , y presiona Enter para seleccionarla.Por ejemplo, en lugar de escribir SERVICE wikibase: label {bd: serviceParam wikibase: language \"en\". } cada vez que creas una consulta, puedes simplemente escribir SERV, presionar Ctrl+Space, ¡y la primera sugerencia será el conjuro completo del servicio de etiquetas, listo para usar! Simplemente presiona Enter para aceptarlo. (El formato será un poco diferente, pero eso no importa).El autocompletado también puede ayudarte en tus búsquedas. Si escribes uno de los prefijos de Wikidata, como wd: o wdt:, luego escribes el texto, por último presionas Ctrl + < kbd>Space buscará ese texto en Wikidata y sugerirá resultados. wd: busca elementos, wdt: busca propiedades. Por ejemplo, en lugar de buscar los elementos de Johann Sebastian Bach (Q1339) y father (P22), puedes escribir wd:Bach y wdt:padre y luego simplemente seleccionas la entrada correcta del autocompletado. (Esto funciona incluso con espacios en el texto, por ejemplo, wd: Johann Sebastian Bach ). Funciones avanzadas Ahora que hemos visto a todos los hijos de Johann Sebastian Bach, más específicamente: todos los items con el padre Johann Sebastian Bach. Pero Bach tenía dos esposas, y esos items tienen dos madres diferentes: ¿qué pasa si solo queremos ver a los hijos de Johann Sebastian Bach con su primera esposa, Maria Barbara Bach (Q57487)? Intenta escribir esa consulta, basada en la anterior.Listo? Bien, entonces vayamos a la solución! La forma más sencilla de hacerlo es agregar una segunda terna con esa restricción: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339.
  ?hijo wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En español, esto se lee cómo: El niño tiene padre Johann Sebastian Bach. El niño tiene madre Maria Barbara Bach. Suena un poco raro, no? En lengua natural, esto se abreviaría cómo: El niño tiene padre Johann Sebastian Bach y madre Maria Barbara Bach. De hecho, es posible expresar la misma abreviatura en SPARQL: si acabamos una terna con un punto y coma (;) en vez de un periodo (.), puedes añadir otro predicado-par de objeto. Esto nos permite abreviar la consulta de arriba de la siguiente manera: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Lo cual tiene los mismos resultados, pero menos repetición en la consulta.Ahora supongamos que, fuera de estos resultados, estamos interesados solo en aquellos hijos que también eran compositores y pianistas. Las propiedades pertinentes y los elementos son occupation (P106), composer (Q36834) y pianist (Q486748). ¡Prueba actualizar la consulta para añadir estas restricciones!Aquí mi solución: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Esta consulta utiliza la abreviatura ; dos veces más para agregar las dos ocupaciones requeridas. Pero como puedes notar, todavía hay algo repetitivo. Esto es como si dijéramos: El niño tiene como ocupación compositor y como ocupación pianista. Lo cual abreviaríamos normalmente así: El niño tiene como ocupación compositor y pianista. SPARQL también tiene sintaxis para ello: al igual que un ; te permite agregar un par-objeto de predicado a una terna (reutilizando el tema), una , te permite anexar otro objeto a una terna (reutilizando tanto el sujeto como el predicado). Con esto, la consulta puede abreviarse así: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Nota: la sangría y otros espacios en blanco no son realmente importantes- solo agregué los espacios a la consulta para que sea más legible. También puedes escribir esto como: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # ambas ocupaciones en una linea
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! o, algo menos legible: SELECT ?hijo ?hijoLabel
WHERE
{
  ?hijo wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # Ninguna sangría; lo hace duro de distinguir entre ; y ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Afortunadamente, el editor WDQS agrega las sangrías en las líneas automáticamente, así que normalmente no tienes que preocuparte por esto.Bien, hagamos un resumen. Hemos visto que las consultas están estructuradas como un texto. Cada terna sobre un tema se termina con un punto.. Múltiples predicados sobre el mismo sujeto están separados por punto y coma ;, y múltiples objetos para el mismo sujeto y predicado se pueden enumerar separados por comas ,. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Ahora quiero introducir una abreviatura más que ofrece SPARQL. Así que si me haces el favor de seguirme a un escenario hipotético más ...Supongamos que no estamos realmente interesados en los hijos de Bach. (¡Quién sabe, tal vez eso sea realmente cierto para ti!) Pero estamos interesados en sus nietos. (Hipotéticamente.) Hay una complicación aquí: un nieto puede estar relacionado con Bach a través de la madre o del padre. Esas son dos propiedades diferentes, lo cual es un inconveniente. Mejor cambiemos la relación: Wikidata también tiene una propiedad \"secundaria\", P:P40, que apunta de padre a hijo y es independiente del género. Con esta información, ¿puedes escribir una consulta que devuelva a los nietos de Bach?Aquí mi solución: SELECT ?nieto ?nietoLabel
WHERE
{
  wd:Q1339 wdt:P40 ?hijo.
  ?hijo wdt:P40 ?nieto.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En lengua natural, se lee: Bach tiene un hijo ?hijo. ?hijo tiene un hijo ?nieto. Una vez más, propongo que abreviemos esta oración, y luego quiero mostrarles cómo SPARQL admite una abreviatura similar. Observa cómo en realidad no nos importa el niño: no usamos la variable excepto para hablar sobre el nieto. Por lo tanto, podríamos abreviar la frase así: Bach tiene como hijo a alguien que tiene un hijo ?nieto. En lugar de decir quién es el hijo de Bach, solo decimos \"alguien\": no nos importa quién es. Pero podemos referirnos a ellos porque dijimos \"alguien quién'\": esto inicia una cláusula relativa, y dentro de esa cláusula relativa podemos decir cosas sobre \"alguien\" (por ejemplo, que él o ella \"tiene un hijo ?nieto”). En cierto modo, \"alguien\" es una variable, pero una especial que solo es válida dentro de esta cláusula relativa, y una a la que no nos referimos explícitamente (decimos \"alguien que es esto y hace eso\", no \"alguien que es esto y alguien que hace eso\"- son dos \"personas\" diferentes).En SPARQL, esto puede ser escrito así: SELECT ?nieto ?nietoLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?nieto ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Puedes usar un par de corchetes ([]) en lugar de una variable, los cuales actúan como una variable anónima. Dentro de los paréntesis, puedes especificar pares de objetos de predicado, como después de un ; después de una terna normal; el sujeto implícito es en este caso la variable anónima que representan los corchetes. (Nota: al igual que después de un ;, puedes agregar más pares de objetos de predicado con más puntos y coma ;, o más objetos para el mismo predicado con comas).Y eso es todo para patrones de ternas! Hay más en SPARQL, pero como estamos a punto de dejar las partes que son fuertemente análogas al lenguaje natural, me gustaría resumir esa relación una vez más: Lengua natural ejemplo SPARQL ejemplo oración Julieta ama Romeo. Punto Julieta ama Romeo '.' Conjunción (cláusula) Romeo ama Julieta 'y' se mata . Punto y coma Romeo ama Julieta ; mata Romeo. Conjunción (sustantivo) Romeo mata Tybalt 'y' él mismo. Coma Romeo mata tybalt, Romeo. Cláusula relativa Julieta ama a alguien quien mata Tybalt. Corchetes Julieta ama [ mata Tybalt ].  Instancias y clases Antes, dije que la mayoría de las propiedades en Wikidata \"tienen\" relación: \"tiene\" hijo, \"tiene\" padres, \"tiene\" ocupación. Pero a veces (de hecho, frecuentemente), necesitamos hablar acerca de algo que \"es. Pero de hecho, hay dos tipos de relaciones ahí: \"Lo que el viento se llevó\" es una película. Una película \"es\" una obra de arte. Lo que el viento se llevó es una película en particular. Tiene un director en particular (Victor Fleming), una duración específica (238 minutos), una lista de actores de reparto (Clark Gable, Vivien Leigh, ...), y así sucesivamente.Película es un concepto general. Las películas pueden tener directores, una duración y miembros del elenco, pero el concepto “película” como tal no tiene ningún director, duración o miembros del elenco en particular. Y aunque una película 'es' una obra de arte, y una obra de arte generalmente tiene un creador, el concepto de \"película\" en sí no tiene un creador, solo las \"instancias\" particulares de este concepto sí lo tienen.Esta diferencia es la razón por la que hay dos propiedades para \"es\" en Wikidata: instance of (P31) y subclass of (P279). Lo que el viento se llevó es un ejemplo particular de la clase \"película\"; la clase \"película\" es una subclase (clase más específica; especialización) de la clase más general \"obra de arte\".Para ayudarte a comprender la diferencia, puedes intentar usar dos verbos diferentes: \"es un\" y \"es un tipo de\". Si \"es un tipo de\" obra (por ejemplo, una película \"es un tipo de\" obra de arte), indica que estás hablando de una subclase, una especificación de una clase más amplia y debe usar subclass of (P279). Si \"es un tipo de\" no funciona (por ejemplo, la frase \"Lo que se llevó el viento\" es un tipo de \"película\" no tiene sentido), indica que está hablando de una instancia en particular y debe usar instance of (P31).Entonces, ¿qué significa esto cuando estamos escribiendo consultas SPARQL? Cuando queremos buscar \"todas las obras de arte\", no es suficiente buscar todos los elementos que son directamente ejemplos de \"obras de arte\": SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31 wd:Q838948. # instancia de obra de arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mientras escribo esto (octubre de 2016), la consulta solo arroja 2815 resultados, obviamente, ¡hay más obras de arte que eso! El problema es que esta consulta no arroja aquellos elementos como Lo que el viento se llevó , que es solo un ejemplo de \"película\", no de \"obra de arte\". \"Película\" es una subclase de \"obra de arte\", pero tenemos que decirle a SPARQL que lo tenga en cuenta al buscar.Una posible solución a esto es la sintaxis de [] de la que hablamos: Lo que el viento se llevó es una instancia de 'alguna' subclase de \"obra de arte\". (Para ejercicio, ¡intenta escribir esa consulta!) Pero todavía tiene problemas: Ya no incluimos elementos que son directamente ejemplos de obras de arte. Todavía nos faltan elementos que son ejemplos de alguna subclase de alguna otra subclase de \"obra de arte\", por ejemplo, Blancanieves y los siete enanitos es una película animada, la cual es una película, la cual es una obra de arte. En este caso, debemos seguir dos declaraciones de \"subclase de\", pero también pueden ser tres, cuatro, cinco, cualquier número en realidad. La solución: ?item wdt: P31/wdt:P279* ?class. Esto significa que hay una \"instancia de\" y luego cualquier número de declaraciones \"subclase de\" entre el elemento y la clase. SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31/wdt:P279* wd:Q838948. # instancia de cualquier subclase de obra de arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (No recomiendo ejecutar esta consulta. WDQS puede (apenas) manejarlo, pero tu navegador puede bloquearse al intentar mostrar los resultados porque hay demasiados).Ahora ya sabes cómo buscar todas las obras de arte, todos los edificios o todos los asentamientos humanos: solo tienes que escribir el encantamiento mágico wdt:P31/wdt:P279*, junto con la clase correspondiente. Este código utiliza algunas funciones SPARQL que no he explicado todavía, pero honestamente, este es casi el único uso relevante de esas funciones, por lo que no es necesario \"entender\" cómo funciona WDQS para usar WDQS de manera efectiva. Si quieres saberlo, te lo explicaré un poco, pero también puedes omitir la siguiente sección y memorizar o copiar + pegar wdt:P31/wdt:P279* desde aquí cuando necesites eso. Propiedades y rutas Cuando hablamos de \"rutas de propiedades\" nos referimos a la ruta de una propiedad entre dos elementos. La ruta más simple es solo una propiedad, la cual comúnmente tiene forma de terna: ?item wdt:P31 ?class. Puedes agregar elementos de ruta con una barra diagonal (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Esto es equivalente a cualquiera de las siguientes: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Ejercicio: reescribe la query de los \"nietos de Bach\" que hicimos anteriormente pero con esta sintaxis.Un asterisco (*) después de un elemento significa \"'cero' o más de este elemento\" """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, il servizio di query di Wikidata, è un potente strumento per accedere ai contenuti di Wikidata. Questa guida ti insegnerà come usarlo. Leggi anche il tutorial interattivo di Wikimedia Israele Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Prima di iniziare 2 SPARQL di base 3 La nostra prima query 3.1 Completamento automatico 4 Modelli di triple avanzate 5 Istanze e classi 5.1 Percorsi delle proprietà 6 Qualificatori 7 ORDER e LIMIT 7.1 Esercizio 7.1.1 Libri di Arthur Conan Doyle 7.1.2 Elementi chimici 7.1.3 Affluenti del Mississippi 7.1.4 Affluenti del Mississippi II 8 OPTIONAL 9 Espressioni, FILTER e BIND 9.1 Tipi di dati 9.2 Operatori 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Raggruppamento 10.1 Popolazioni delle città 10.2 Materiali per la pittura 10.3 Pistole per produttore 10.4 Editori per numero di pagine 10.4.1 HAVING 10.5 Riepilogo delle funzioni aggregatrici 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 E oltre… 14 Vedi anche Prima di iniziare Questa guida sembra molto lunga, forse addirittura intimidatoria. Per favore, non lasciare che ti spaventi! SPARQL è complicato, ma delle semplici basi già ti faranno fare molta strada – se vuoi, puoi smettere di leggere dopo #La nostra prima query, e ne saprai già abbastanza per scrivere molte query interessanti. Le sezioni successive aggiungono informazioni su questi argomenti che puoi usare per scrivere differenti query. Ognuna di esse ti darà la possibilità di scrivere query ancora più interessanti, ma nessuna di esse è indispensabile - puoi smettere di leggere in qualsiasi momento e avrai comunque utili informazioni!Se non hai mai sentito prima parlare di Wikidata, SPARQL o WDQS, ecco una breve spiegazione di questi termini: Wikidata è un database delle conoscenze. Contiene molte dichiarazioni come “la capitale del Canada è Ottawa”, o “La Gioconda è un dipinto a olio su tavola di legno di pioppo”, o “l'oro ha una capacità termica di 25 418 joule per mole-kelvin”. SPARQL è un linguaggio per formulare domande (query) per i database delle conoscenze. Con il giusto database, una query SPARQL può rispondere a domande come “qual è la tonalità più popolare nella musica?” o “quale personaggio è stato interpretato dal maggior numero di attori?” o “qual è la distribuzione del tipo di sangue?” o “quali opere e di quali autori sono entrate nel pubblico dominio quest'anno?”. WDQS, Wikidata Query Service, unisce i due insieme: tu immetti una query SPARQL, lui la esegue sul dataset di Wikidata e ti mostra il risultato.  SPARQL di base Una semplice query SPARQL ha il seguente aspetto: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clausola SELECT elenca le variabili che si desidera vengano restituite (le variabili iniziano con un punto interrogativo), e la clausola WHERE contiene restrizioni su di esse, principalmente sotto forma di triple. Tutte le informazioni in Wikidata (e database delle conoscenze simili) sono memorizzate sotto forma di triple; quando si esegue la query, il servizio query prova a compilare le variabili con i valori effettivi in modo che le triple risultanti vengano visualizzate come nel database della conoscenza, e restituisce un risultato per ciascuna combinazione di variabili che trova. Una tripla può essere letta come una frase (ecco perché termina con un punto), con un \"soggetto\", un \"predicato\" e un \"oggetto\": SELECT ?frutto
WHERE
{
  ?frutto haColore giallo.
  ?frutto haSapore aspro.
} I risultati per questa query potrebbero includere, ad esempio, \"limone\". In Wikidata, la maggior parte delle proprietà sono proprietà di tipo \"ha\", quindi la query si potrebbe leggere: SELECT ?frutto
WHERE
{
  ?frutto colore giallo.
  ?frutto sapore aspro.
} che si legge come “?frutto ha colore ‘giallo’” (non “?frutto è di colore ‘giallo’” – tienilo a mente per coppie di proprietà come “genitore”/“figlio”!).Tuttavia, questo non è un buon esempio per WDQS. Il gusto è soggettivo, quindi Wikidata non ha una proprietà per questo. Invece, pensiamo alle relazioni genitori/figli, che sono per lo più non ambigue. La nostra prima query Supponiamo di voler elencare tutti i figli del compositore barocco Johann Sebastian Bach. Usando pseudo-elementi come nelle query precedenti, come scriveresti quella query?Spero che tu abbia qualcosa del genere: SELECT ?figlio
WHERE
{
  #  figlio \"ha genitore\" Bach
  ?figlio genitore Bach.
  # (nota: ogni cosa dopo un ‘#’ è un commento ed è ignorato da WDQS.)
} o questo, SELECT ?figlio
WHERE
{
  # figlio \"ha padre\" Bach 
  ?figlio padre Bach. 
} o questo. SELECT ?figlio
WHERE
{
  #  Bach \"ha figlio\" figlio
  Bach figlio ?figlio.
} Le prime due triple dicono che il ?figlio deve avere come padre/genitore Bach; la terza dice che Bach deve avere il figlio ?figlio, Per ora esaminiamo il secondo.Quindi, cosa rimane da fare per trasformare questo in una query WDQS corretta? Su Wikidata, gli oggetti e le proprietà non sono identificati da nomi leggibili dall'utente umano come \"padre\" (proprietà) o \"Bach\" (elemento). (Per una buona ragione: \"Johann Sebastian Bach\" è anche il nome di un pittore tedesco e Bach potrebbe anche riferirsi al cognome, al comune francese, al cratere di Mercurio, etc.) Invece, agli oggetti e alle proprietà di Wikidata viene assegnato un identificatore. Per trovare l'identificatore di un oggetto, cerchiamo l'elemento e copiamo il numero-Q del risultato che sembra sia l'elemento più simile a quello che stiamo cercando (in base alla descrizione, ad esempio). Per trovare l'identificatore di una proprietà, facciamo lo stesso, ma cerchiamo “P:termine cercato” invece che solo “termine cercato”, questo limita la ricerca solo alle proprietà. Questo ci dice che il famoso compositore Johann Sebastian Bach è Q1339, e la proprietà per designare il padre di un oggetto è P:P22.E, ultimo ma non meno importante, abbiamo bisogno di includere dei prefissi. Per semplici triple WDQS, gli elementi devono essere preceduti da wd:, e le proprietà da wdt:. (Ma questo si applica solo ai valori fissi - le variabili non necessitano di un prefisso!)Mettendo insieme tutto questo, arriviamo alla nostra prima query WDQS corretta: SELECT ?figlio
WHERE
{
# ?figlio  padre   Bach
  ?figlio wdt:P22 wd:Q1339.
}
 Try it! Clicca su “Provalo” e poi “Esegui query” nella pagina WDQS. Che cosa ottieni? figlio wd:Q57225 wd:Q76428 … Beh, questo è deludente. Vedi solo gli identificatori. Puoi cliccare su di loro per vedere la corrispondente pagina Wikidata (inclusa un'etichetta leggibile dall'uomo), ma non c'è un modo migliore per vedere i risultati?Certo che sì! (Le domande retoriche non sono grandi?) Se includi il testo magico SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } da qualche parte all'interno della clausola WHERE, otterrai ulteriori variabili: per ogni variabile ?foo nella tua query, ora hai anche una variabile ?fooLabel , che contiene l'etichetta dell'elemento ?foo. Se l'aggiungi alla clausola SELECT, ottieni sia l'elemento che la sua etichetta. SELECT ?figlio ?figlioLabel
WHERE
{
# ?figlio  padre   Bach
  ?figlio wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Prova a eseguire la query: dovresti vedere non solo il numero degli elementi, ma anche i nomi dei vari figli figlio figlioLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Completamento automatico Quel frammento di codice SERVICE sembra difficile da ricordare, giusto? E passare attraverso la funzione di ricerca tutto il tempo mentre scrivi la query è anche noioso. Fortunatamente, WDQS offre un'ottima soluzione a questo: il \"completamento automatico\". Nell'editor di query in query.wikidata.org, puoi premere Ctrl+Spazio in qualsiasi punto della query e ottenere suggerimenti per il codice che potrebbero essere appropriati; seleziona il suggerimento corretto con freccia su/freccia giù e premi Invio per selezionarlo.Ad esempio, invece di scrivere SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } ogni volta, puoi semplicemente scrivere SERV, premere Ctrl+Spazio, e il primo suggerimento completerà magicamente il frammento di codice, pronto per l'uso! Basta premere Invio per accettarlo. (La formattazione sarà leggermente diversa, ma non importa.)E il completamento automatico può anche fare ricerche per te. Se digiti uno dei prefissi di Wikidata, come wd: o wdt:, e poi scrivi semplicemente il testo di seguito, Ctrl+Spazio cercherà quel testo su Wikidata e suggerirà risultati. wd: cerca negli elementi, wdt: cerca nelle proprietà. Ad esempio, invece di cercare gli elementi per Johann Sebastian Bach (Q1339) e father (P22), puoi semplicemente digitare wd:Bach e wdt:pad e quindi basta selezionare la voce giusta dal completamento automatico. (Funziona anche con spazi nel testo, ad es. wd:Johann Sebastian Bach.) Modelli di triple avanzate Così ora abbiamo visto tutti i figli di Johann Sebastian Bach - in particolare: tutti gli elementi che hanno Johann Sebastian Bach come padre. Ma Bach ha avuto due mogli, e quindi quegli elementi hanno due madri diverse: e se volessimo vedere solo i figli di Johann Sebastian Bach con la sua prima moglie, Maria Barbara Bach (Q57487)? Prova a scrivere quella query, in base a quella sopra.Fatto? Ok, allora andiamo alla soluzione! Il modo più semplice per farlo è aggiungere una seconda tripla con quella restrizione: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339.
  ?figlio wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In italiano questo si legge: Figlio che ha padre Johann Sebastian Bach. Figlio che ha madre Maria Barbara Bach. Sembra un po' imbarazzante, no? In linguaggio naturale, dovremmo abbreviare in questa maniera: Figlio che ha padre Johann Sebastian Bach e madre Maria Barbara Bach. In effetti, è possibile esprimere la stessa abbreviazione anche in SPARQL: se si termina una tripla con un punto e virgola (;) anziché un punto, è possibile aggiungere un'altra coppia oggetto-predicato. Questo ci permette di abbreviare la query sopra in: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! che ha gli stessi risultati, ma meno ripetizioni nella query.Ora supponiamo che, al di fuori di questi risultati, siamo interessati solo ai figli che sono stati anche compositori e pianisti. Le proprietà e gli elementi pertinenti sono occupation (P106), composer (Q36834) e pianist (Q486748). Prova ad aggiornare la query precedente per aggiungere queste restrizioni!Ecco la mia soluzione: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Questo usa l'abbreviazione ; altre due volte per aggiungere le due occupazioni richieste. Ma come puoi notare, c'è ancora qualche ripetizione. Questo è come se dicessimo: Il figlio ha occupazione compositore e occupazione pianista. che di solito dovremmo abbreviare come: Il figlio ha occupazione compositore e pianista. E SPARQL ha una sintassi anche per questo: proprio come un ; ti permette di aggiungere una coppia oggetto-predicato ad una tripla (riusando l'oggetto), un , ti permette di aggiungere un altro oggetto a una tripla (riusando sia il soggetto che il predicato). Con questo, la query può essere abbreviata in: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Nota: indentazione e gli altri spazi bianchi non contano davvero: ho appena indentato la query per renderla più leggibile. Puoi anche scrivere questo come: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # entrambe le occupazioni in una riga
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! o, anche se meno leggibile: SELECT ?figlio ?figlioLabel
WHERE
{
  ?figlio wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # nessuna indentazione; rende difficile distinguere tra ; e ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Fortunatamente, l'editor WDQS indenta automaticamente le linee, quindi di solito non devi preoccuparti di questo.Bene, riassumendo: abbiamo visto che le query sono strutturate come testo. Ogni tripla su un argomento è terminata da un punto. Più predicati relativi allo stesso soggetto sono separati da punti e virgola e più oggetti per lo stesso soggetto e predicato possono essere elencati separati da virgole. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Ora voglio introdurre un'altra abbreviazione che SPARQL offre. Così vediamo un altro scenario ipotetico...Supponiamo che non siamo realmente interessati ai figli di Bach. (Chissà, forse è proprio vero per te!) Ma siamo interessati ai suoi nipoti. (Ipoteticamente.) C'è una complicazione qui: un nipote può essere collegato a Bach tramite la madre o il padre. Sono due proprietà diverse, il che è scomodo. Invece, giriamo intorno alla relazione: Wikidata ha anche una proprietà \"figlio\", P:P40, che punta da genitore a figlio ed è indipendente dal genere. Con questa informazione, puoi scrivere una query che restituisce i nipoti di Bach?Ecco la mia soluzione: SELECT ?nipote ?nipoteLabel
WHERE
{
  wd:Q1339 wdt:P40 ?figlio.
  ?figlio wdt:P40 ?nipote.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In linguaggio naturale, si legge: Bach ha un figlio ?figlio. ?figlio ha un figlio ?nipote. Ancora una volta, propongo di abbreviare questa frase italiana, e poi voglio mostrarvi come SPARQL supporta un'abbreviazione simile. Osserva come in realtà non ci importa del figlio: non usiamo la variabile se non per parlare del nipote. Potremmo quindi abbreviare la frase in: Bach ha qualche figlio che ha un figlio ?nipote. Invece di dire chi è il figlio di Bach, diciamo semplicemente “qualche”: non ci interessa chi è. Ma possiamo riferirci a loro perché abbiamo detto “qualche che”: questo avvia una proposizione relativa, e all'interno di quella clausola possiamo dire cose su \"qualche\" (ad esempio, che lui o lei \"ha un figlio <codice>?nipote\"). In un certo senso, \"qualche\" è una variabile, ma una speciale che è valida solo all'interno di questa proposizione relativa, e una a cui non ci riferiamo esplicitamente (diciamo “qualcuno che è questo e fa così\", non \"qualcuno che è questo e qualcuno che lo fa” – questo è due diversi “qualcuno”).In SPARQL, questo può essere scritto come: SELECT ?nipote ?nipoteLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?nipote ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Puoi usare una coppia di parentesi ([]) al posto di una variabile, che agiscono come una variabile anonima. All'interno delle parentesi, puoi specificare le coppie oggetto-predicato, proprio come dopo un ; dopo una normale tripla; il soggetto implicito è in questo caso la variabile anonima rappresentata dalle parentesi. (Nota: anche come dopo ;, puoi aggiungere più coppie oggetto-predicato con più punti e virgola, o più oggetti per lo stesso predicato con le virgole.)E questo vale per tutti i modelli di triple! C'è di più in SPARQL, ma dato che stiamo per lasciare le parti di esso che sono fortemente analoghe al linguaggio naturale, vorrei riassumere questa relazione ancora una volta: linguaggio naturale esempio SPARQL esempio frase Giulietta ama Romeo. punto giulietta ama romeo. congiunzione (di intere frasi) Romeo ama Giulietta e uccide se stesso. punto e virgola romeo ama giulietta; uccide romeo. congiunzione (di singole parole) Romeo uccide Tebaldo e se stesso. virgola romeo uccide Tebaldo, romeo. proposizione relativa Giulietta ama qualcuno che ha ucciso Tebaldo. parentesi giulietta ama [ ucciso tebaldo ].  Istanze e classi In precedenza, ho detto che la maggior parte delle proprietà di Wikidata sono relazioni \"ha\": \"ha\" figlio, \"ha\" padre, \"ha\" occupazione. Ma a volte (di fatto, spesso), devi anche parlare di cosa \"è\". Ma ci sono in effetti due tipi di relazioni: Via col vento è un film. Un film è un'opera d'arte. Via col vento è uno specifico film. Ha uno specifico regista (Victor Fleming), una specifica durata (238 minuti), una lista di membri del cast (Clark Gable, Vivien Leigh, …), e così via.Film è un concetto generale. I film possono avere registi, durata, a membri del cast, ma il concetto “film” in quanto tale non ha un particolare regista, durata o membri del cast. E anche se un film è un'opera d'arte e un'opera d'arte di solito ha un creatore, il concetto stesso di \"film\" non ha un creatore – solo le specifiche \"istanze\" di questo concetto lo hanno.Questa differenza è il motivo per cui su Wikidata ci sono due proprietà per “è”: instance of (P31) e subclass of (P279). Via col vento è una specifica istanza della classe “film”; la classe “film” è una sottoclasse (classe più specifica, specializzazione) della più generica classe “opera d'arte”.Per aiutarti a capire la differenza, puoi provare a utilizzare due verbi diversi: \"è un\" e \"è un tipo di\". Se \"è un tipo di\" opera (ad esempio un film \"è un tipo di\" opera d'arte), indica che stai parlando di una sottoclasse, una specializzazione di una classe più ampia e dovresti usare subclass of (P279). Se \"è un tipo di\" non lavora (per esempio la frase Via col vento \"è un tipo di\" film, non ha molto senso), indica che stai parlando di una particolare istanza e dovresti usare instance of (P31).Che cosa significa questo per noi quando scriviamo una query SPARQL? Quando vogliamo cercare “tutte le opere d'arte”, non è sufficiente cercare tutti gli elementi che sono direttamente istanze di “opere d'arte”: SELECT ?opera ?operaLabel
WHERE
{
  ?opera wdt:P31 wd:Q838948. # istanza di opera d'arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mentre sto scrivendo questo, la query restituisce solo 2815 risultati – ovviamente, ci sono molte più opere d'arte di queste! Il problema è che non trova elementi come Via col vento, che è solo un'istanza di “film”, non di “opera d'arte”. “film” è una sottoclasse di “opera d'arte”, quindi dobbiamo dire a SPARQL di tenerne conto durante la ricerca.Una possibile soluzione a questo è la sintassi [] di cui abbiamo parlato: Via col vento è un'istanza di alcune sottoclassi “opera d'arte”. (Come esercizio, prova a scrivere quella query!) Ma questo ha ancora problemi: Non includiamo più item che sono direttamente istanze di opere d'arte. Ci mancano ancora elementi che sono istanze di sottoclassi di alcune altre sottoclassi di “opera d'arte” – per esempio, Biancaneve e i sette nani è un film d'animazione, che è un film, che è un'opera d'arte. In questo caso, dobbiamo seguire due dichiarazioni \"sottoclassi di\" – ma potrebbe anche essere tre, quattro, cinque, qualsiasi numero in realtà. La soluzione: ?item wdt:P31/wdt:P279* ?class. Ciò significa che esiste una “istanza di” e quindi un numero qualsiasi di dichiarazioni “sottoclasse di” tra l'elemento e la classe. SELECT ?opera ?operaLabel
WHERE
{
  ?opera wdt:P31/wdt:P279* wd:Q838948. # istanza di una qualsiasi sottoclasse di opera d'arte
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Non consiglio di eseguire quella query. WDQS può gestirla (a malapena), ma il browser potrebbe bloccarsi quando si tenta di visualizzare i risultati perché ce ne sono così tanti.)Ora sai come cercare tutte le opere d'arte, o tutti gli edifici, o tutti gli insediamenti umani: il magico wdt:P31/wdt:P279*, insieme alla classe appropriata. Ciò utilizza alcune funzionalità SPARQL che non ho ancora spiegato, ma onestamente, questo è quasi l'unico uso rilevante di queste funzionalità, quindi non è necessario capire come funziona per utilizzarlo in modo efficace in WDQS. Se lo vuoi sapere, lo spiegherò tra poco, ma puoi anche saltare la sezione successiva e memorizzare o copiare+incollare wdt:P31/wdt:P279* da qui quando ti serve. Percorsi delle proprietà I percorsi delle proprietà sono un modo per annotare in modo molto preciso un percorso delle proprietà tra due elementi. Il percorso più semplice è solo una singola proprietà, che forma una tripla ordinaria: ?item wdt:P31 ?class. È possibile aggiungere elementi di percorso anteponendo una barra obliqua (/) ?item wdt:P31/wdt:P279/wdt:P279 ?class. Questo è equivalente a uno dei seguenti: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Esercizio: riscrivi la precedente query \"nipoti di Bach\" per utilizzare questa sintassi.un asterisco (*) dopo un elemento di percorso significa “zero o più di questi elementi”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, el Servei de Consultes, és una eina per respondre preguntes que pugueu tenir, i aquesta guia us ajudarà a aprendre com utilitzar-lo. Vegeu també el tutorial interactiu de Wikimedia Israel.Abans d'escriure la vostra pròpia consulta d'SPARQL, reviseu {{Item documentation}} o qualsevol altra plàntilla de consulta SPARQL genèrica per veure si la vostra consulta ja hi ha estat inclosa. Contents 1 Abans de començar 2 Conceptes bàsics d'SPARQL 3 La nostra primera consulta 3.1 Autocompletat 4 Patrons avançats de ternes 5 Instàncies i classes 5.1 Rutes de propietats 6 Qualificadors 7 ORDER i LIMIT 7.1 Exercici 7.1.1 Llibres d'Arthur Conan Doyle 7.1.2 Elements químics 7.1.3 Rius que desemboquen al Mississippi 7.1.4 Rius que desemboquen al Mississippi II 8 OPTIONAL 9 Expressions, FILTER i BIND 9.1 Tipus de dades 9.2 Operadors 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Agrupant 10.1 Població de ciutats 10.2 Materials de pintura 10.3 Armes per fabricant 10.4 Editorials per nombre de pàgines 10.4.1 HAVING 10.5 Resum de funcions d'agregació 10.6 wikibase: Etiquetes i agregacions 11 VALUES 12 Label in multiple languages 13 I més enllà… 14 Vegeu també Abans de començar Aquesta guia pot semblar llarga, tant que potser intimida. No us espanteu! L'SPARQL és complicat, però només amb els conceptes bàsics ja es pot anar força lluny. Si voleu, podeu deixar de llegir després de la nostra primera consulta i ja podreu escriure moltes consultes interessants. Les seccions que venen a continuació d'això només afegeixen informació sobre altres elements que podeu utilitzar per escriure consultes diferents. Cadascuna d'aquestes seccions us capacitarà per escriure consultes encara més potents, però cap d'elles és necessària: podeu deixar de llegir en qualsevol moment i, tot i així, disposareu de molts coneixements útils.Si no heu sentit mai a parlar de Wikidata, SPARQL o WDQS, aquí en teniu una explicació breu: Wikidata és una base de dades de coneixement. Conté molts fets, com ara que «la capital de Canadà és Ottawa», o que «la Mona Lisa fou pintada a l'oli en una fusta de pollancre», o que «l'or té una conductivitat tèrmica de 25.418 joules per mol kelvin». L'SPARQL és un llenguatge per formular consultes a bases de dades de coneixement. Amb la base de dades correcta, una consulta SPARQL podria preguntar qüestions com ara “quina és la tonalitat musical més popular?” o “quin personatge ha estat interpretat per més actors?” o “quina és la distribució de tipus de sang?” o “quines obres d'autor han entrat en el domini públic enguany?”. WDQS, el Servei de Consulta de Wikidata ajunta les dues coses: en definir una consulta SPARQL, el servei l'executa usant les dades de Wikidata, mostrant-ne el resultat.  Conceptes bàsics d'SPARQL Una consulta senzilla en SPARQL s'assembla a això: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} La clàusula SELECT llista les variables que volem consultar (les variables comencen amb un signe d'interrogació) i la clàusula WHERE conté les restriccions que hi volem aplicar, en forma de ternes. Tota la informació de Wikidata (i d'altres bases de dades de coneixement similars) està desada en forma de ternes; quan executem la consulta, el servei de consultes intenta emplenar les variables amb valors reals existents a la base de dades, tornant un resultat per a cada combinació de variables que troba.Una terna es pot considerar com dos vèrtexs (és a dir, 2 nodes, 2 recursos) connectats per una aresta (un arc, una propietat) dins del vast multigràfic de propietats directe (orientat) que forma Wikidata. Es pot llegir com una frase (per això s'acaba amb un punt), amb un «subjecte», un «predicat» i un «complement directe». SELECT ?fruita
WHERE
{
  ?fruita ésDeColor groc.
  ?fruita téGust agre.
} El resultat d'aquesta consulta pot incloure, per exemple, «llimona». A Wikidata, la majoria de propietats assumeixen que els ítems «tenen» propietats, pel què la consulta podria ser: SELECT ?fruita
WHERE
{
  ?fruita color groc.
  ?fruita gust agre.
} el que es pot llegir com “?fruita té color ‘groc’” (no “?fruita és de color ‘groc’” – tinguem això present per a propietats com “pare”/“fill”!).Tot i això, aquest no és un bon exemple de WDQS. El gust és subjectiu, així que Wikidata no en té una propietat. En canvi, observem la relació pare/fill, que és menys ambigua. La nostra primera consulta Suposem que volem llistar tots els fills del compositor barroc Johann Sebastian Bach. Utilitzant psèudo-elements com a les consultes anteriors, com escriuríem la consulta?Amb sort, aconseguirem una cosa així: SELECT ?fill
WHERE
{
  #  fill «té pare» Bach
  ?fill pare Bach.
  # (Nota: tot el que hi ha darrere d'un ‘#' és un comentari i WDQS ho ignora.)
} o això, SELECT ?fill
WHERE
{
  # fill «té pare» Bach 
  ?fill pare Bach. 
} o això, SELECT ?fill
WHERE
{
  #  Bach «té fill» fill
  Bach fill ?fill.
} Les dues primeres ternes diuen que ?fill ha de tenir Bach com a pare; la tercera diu que Bach ha de tenir el fill ?fill. Per ara i tant, quedem-nos amb la segona.Aleshores, què falta per a convertir això en una consulta vàlida de WDQS? A Wikidata, els ítems i les propietats no s'identifiquen amb noms llegibles-pels-humans com «pare» (una propietat) o «Bach» (un ítem). (I per una bona raó: «Johann Sebastian Bach» també és el nom d'un pintor alemany, i «Bach» també es podria referir al cognom, la comuna francesa, el cràter de Mercuri, etc). En canvi, els ítems i propietats de Wikidata tenen assignades un identificador. Per a trobar l'identificador d'un ítem, fem una cerca de l'ítem i en copien el número Q de l'ítem que coincideixi amb el que estem buscant (per exemple, basant-nos en la descripció). Per trobar l'identificador d'una propietat fem el mateix, però cercant amb «P:terme» amb el que ampliem la cerca a les propietats. Això ens diu que el famós compositor Johann Sebastian Bach és Q1339 i que la propietat per a designar el pare d'un ítem és la P:P22.Finalment, però no per això menys important, necessitem incloure prefixos. Per ternes senzilles de WDQS, els elements s'haurien de prefixar amb wd:, i les propietats amb wdt:. (Però això només s'aplica als valors fixos, les variables no porten prefix!)I, així, arribem a la nostra primera consulta WDQS: SELECT ?fill
WHERE
{
# ?fill  pare   Bach
  ?fill wdt:P22 wd:Q1339.
}
 Try it! Feu clic a l'enllaç «Proveu-ho» i després «Executeu» la consulta a la pàgina de WDQS. Què obteniu? fill wd:Q57225 wd:Q76428 … Bé, això és decebedor. Només veieu els identificadors. Si hi feu clic, anireu a la seva pàgina de Wikidata (on hi ha una etiqueta entenedora pels humans), però no hi ha una forma millor de veure els resultats?Resulta que sí que n'hi ha una (oi que les preguntes retòriques són genials?), si hi incloeu el text màgic SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } en algun lloc dins la clàusula WHERE, aconseguireu variables addicionals: Per a cada variable ?foo de la vostra consulta, ara també tindreu una variable ?fooLabel, la qual conté l'etiqueta de l'element ?foo subjacent. Si afegiu això a la clàusula SELECT, obtindreu tant l'element com la seva etiqueta: SELECT ?fill ?fillLabel
WHERE
{
# ?fill  pare   Bach
  ?fill wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Proveu a executar aquesta consulta i hauríeu de veure els números d'ítem i els noms dels diferents fills. fill fillLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autocompletat El fragment de codi de SERVICE sembla complicat de recordar, oi? I haver d'anar fent consultes tota l'estona mentre escriviu la consulta és tediós. Afortunadament, WDQS ofereix una bona solució per això: l'«autocompletat». A l'editor de consultes de query.wikidata.org, hi podeu prémer en qualsevol moment les tecles Ctrl+Espai (o Alt+Retorn o Ctrl+Alt+Retorn) per a obtenir suggeriments del codi que podríeu necessitar. Seleccioneu el suggeriment correcte fent fletxa amunt/fletxa avall i prement Retorn.Per exemple, en comptes d'escriure SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } cada cop, podeu teclejar només SERV, prémer Ctrl+Espai i el primer suggeriment serà l'etiqueta completa de service, preparada per a ser executada! Premeu Retorn per a acceptar-lo. (El formatat serà una mica diferent, però no importa).I l'autocompletat també pot fer la cerca per sí mateix. Si teclegeu un dels prefixos de Wikidata, com wd: o wdt:, i després escriviu qualsevol cosa darrere, Ctrl+Espai farà la cerca del text a Wikidata i us farà suggeriments. wd: busca ítems i wdt: propietats. Per exemple, en comptes de fer la cerca dels ítems Johann Sebastian Bach (Q1339) i father (P22), podeu senzillament teclejar wd:Bach i wdt:pare i seleccionar el suggeriment correcte de l'autocompletat. Això fins i tot funciona amb espais al text. Per exemple: wd:Johann Sebastian Bach. Patrons avançats de ternes Ara ja sabem els fills d'en Johann Sebastian Bach -més concretament: tots els ítems que tenen com a pare en Johann Sebastian Bach. Però Bach va tenir dues esposes i, per tant, aquests ítems tenien dues mares diferents: i si només volem veure els fills de Johann Sebastian Bach amb la seva primera dona, Maria Barbara Bach (Q57487)? Proveu a escriure aquesta consulta, utilitzant l'anterior com a exemple.Ja ho heu fet? Fem un cop d'ull a la solució! La manera més senzilla és fer-ho afegint una segona terna amb aquesta restricció: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339.
  ?fill wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En català, això és llegiria com: Fill té pare Johann Sebastian Bach. Fill té mare Maria Barbara Bach. Sona estrany, oi? En llenguatge natural, ho hauríem abreujat així: Fill té pare Johann Sebastian Bach i mare Maria Barbara Bach. De fet, és pot expressar la mateixa abreviació en SPARQL: si acabeu una terna amb punt i coma (;), en comptes de amb un punt, podeu afegir un altre parell predicat-complement directe. Això ens permet abreujar la consulta anterior com: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! que ofereix el mateix resultat, però la consulta és més concisa.Ara suposem que, dels resultats, només ens interessen els fills que eren compositors i pianistes. Les propietats i ítems rellevants son occupation (P106), composer (Q36834) i pianist (Q486748). Feu la prova d'actualitzar la consulta anterior amb aquestes restriccions!Aquesta és la meva solució: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Aquí s'utilitza l'abreviació ; dos cops més per a afegir les dues ocupacions requerides. Però ja us haureu adonat que encara hi ha algunes repeticions. Això és com si diguéssim: Fill té l'ocupació compositor i l'ocupació pianista. que podríem abreujar com: Fill té ocupació compositor i pianista. I l'SPARQL té sintaxi per a això també: de la mateixa forma que ; us permet afegir un parell predicat-complement directe a una terna (reutilitzant el subjecte), una , ens permet afegir un altre complement directe a la terna (reutilitzant tant el subjecte com el predicat). Amb això, la consulta es pot abreujar com: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Nota: la indentació i altres espais en blanc realment no son importants -només fan el codi més llegible. També es pot escriure com: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # les dues ocupacions en una línia
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! o, força menys llegible: SELECT ?fill ?fillLabel
WHERE
{
  ?fill wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # sense indentació; costa bastant distingir entre ; i ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Per sort, l'editor de WDQS indenta les línies de forma automàtica i habitualment no us n'heu de preocupar.Fem un resum: Hem vist que les consultes s'estructuren com a text. Cada terna sobre un subjecte s'acaba amb un punt. Diversos predicats sobre el mateix subjecte es poden separar amb punt i coma, i diversos complements directes del mateix subjecte i predicat es poden llistar separats per comes. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Ara introduirem una abreviació més que ofereix l'SPARQL. Imaginem un altre escenari hipotètic...Suposem que no volem els fills d'en Bach. Però estem interessants en els seus nets. Tenim una complicació aquí: els nets poden relacionar-se amb en Bach mitjançant la mare o el pare, que son dues propietats diferents. Fem-ho diferent, capgirem la relació: Wikidata també té la propietat «fill», P:P40, que apunta de pare a fill i és independent del gènere. Amb aquesta informació, podeu escriure la consulta que retornaria els nets d'en Bach?Aquesta és la solució proposada: SELECT ?net ?netLabel
WHERE
{
  wd:Q1339 wdt:P40 ?fill.
  ?fill wdt:P40 ?net.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! En llenguatge natural, això es llegeix com: Bach té un fill ?fill. ?fill té un fill ?net. Un cop més, podem abreujar la frase en català i, després, veurem com l'SPARQL permet fer la mateixa abreviació. Observem com, de fet, no ens importa el fill: només utilitzem la variable per relacionar-la amb el net. Podem, per tant, abreujar la frase com: Bach té com a fill algú que té com a fill ?net. En comptes de dir qui és el fill d'en Bach, només diem «algú»: no ens importa qui és. Però podem utilitzar-los de referència per què diem «algú «que»»: això inicia una clàusula relativa, i dins d'aquesta clàusula relativa hi podem dir coses com «algú» (per exemple, «que tingui un fill ?net»). En certa manera, «algú» és una variable, però una d'especial que només és vàlida dins d'una clàusula relativa, i una a la qual no ens hi referim de forma explícita (diem, «algú que és X i fa Y» -això són dos «algú» diferents).En SPARQL, això es pot escriure com: SELECT ?net ?netLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?net ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Podeu utilitzar un parell de claudàtors ([]) al lloc d'una variable, que actuarien com una variable anònima. Dins d'aquests claudàtors, podem especificar-hi parells predicat-complement directe, tal i com ho fem després de ; després d'una terna normal; el subjecte implícit és, en aquest cas, la variable anònima que representen els claudàtors. (Nota:igual que després de ;, podeu afegir més parells de predicat-complement directe amb més punts i coma, o més objectes pel mateix predicat amb comes).I això és tot sobre els patrons de ternes! Hi ha molt més a parlar d'SPARQL, però com que estem a punt de deixar les parts que tenen relació directa amb el llenguatge natural, resumirem aquesta relació un altre cop: llenguatge natural exemple SPARQL exemple frase Julieta estima Romeo. punt julieta estima romeo. conjunció (clàusula) Romeo estima Julieta i mata ell mateix. punt i coma romeo estima julieta; mata romeo. conjunció (nom) Romeo mata Tybalt i ell mateix. coma romeo mata tybalt, romeo. clàusula relativa Julieta estima algú que mata Tybalt. claudàtors julieta estima [ mata tybalt ].  Instàncies i classes Abans, hem dit que la majoria de propietats de Wikidata contenen relacions de «té»: «té» fill, «té» pare, «té» ocupació. Però algun cop (de fet, sovint), també hem de parlar de que alguna cosa «és». Però, de fet, això són dos tipus de relacions: Allò que el vent s'endugué és una pel·lícula. Una pel·lícula és una obra d'art. Allò que el vent s'endugué és una pel·lícula en concret. Té un director concret (Victor Fleming), una durada concreta (238 minuts), un repartiment (Clark Gable, Vivien Leigh, etc), i més coses.Pel·lícula és un concepte general. Les pel·lícules poden tenir directors, durades i actors del repartiment, però el concepte «pel·lícula» com a tal no té cap director, durada, ni intèrprets. I tot i que una pel·lícula és una obra d'art, i les obres d'art acostumen a tenir un creador, el concepte de «pel·lícula» no té un creador -només «instàncies» concretes d'aquest concepte en tenen.Aquesta diferència és la raó pel què hi ha dues propietats «és» a Wikidata: instance of (P31) i subclass of (P279). «Allò que el vent s'endugué» és una instància concreta de la classe «pel·lícula»; la classe «pel·lícula» és una subclasse (més específicament, una especialització d'una classe) d'una classe més general, «obra d'art».Per ajudar-vos a entendre la diferència, podeu provar a utilitzar dos verbs diferents: «és un» i «és una mena de». Si «és una mena de» funciona (per exemple: una pel·lícula «és una mena de» obra d'art), indica que estem parlant d'una subclasse, d'una especialització d'una classe més general i que hauríem d'utilitzar subclass of (P279). Si «és una mena de» no funciona (per exemple: la frase Allò que el vent s'endugué «és una mena de» pel·lícula no té sentit), indica que estem parlant d'una instància concreta i que hem d'utilitzar instance of (P31).Així, què implica això quan estem escrivint consultes d'SPARQL? Quan volem buscar «totes les obres d'art», no és suficient buscar tots els ítems que són directament instàncies d'«obra d'art». SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31 wd:Q838948. # instància d'obra d'art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Mentre escric això (octubre de 216), la consulta retorna solament 2.815 resultats, però, evidentment, existeixen més obres d'art! El problema és que no obtenim elements com ara Allò que el vent s'endugué, que és solament una instància de «pel·lícula», no d'«obra d'art». «Pel·lícula» és una subclasse d'«obra d'art», però li hem de dir a l'SPARQL que ho ha de tenir en compte en fer la cerca.Una solució possible és la sintaxi amb [] que hem comentat abans: Allò que el vent s'endugué és una instància d'alguna subclasse d'«obra d'art». (Com a exercici, proveu a escriure aquesta consulta!) Però això encara genera problemes: No hi incloem ítems que son instàncies directes d'obra d'art. Encara estem obviant ítems que són instàncies d'alguna subclasse d'alguna altra subclasse d'«obra d'art – per exemple, Blancaneus i els set nanets és una pel·lícula animada, el qual és una pel·lícula, que és una obra d'art. En aquest cas, hem de seguir dues declaracions de «subclasse de» – però també podrien ser tres, o quatre, o cinc, qualsevol nombre, de fet. La solució: ?item wdt:P31/wdt:P279* ?class. Això significa que hi ha una «instància de» i després qualsevol nombre de declaracions «subclasse de» entre l'ítem i la classe. SELECT ?obra ?obraLabel
WHERE
{
  ?obra wdt:P31/wdt:P279* wd:Q838948. # instància de qualsevol subclasse d'obra d'art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (no recomanem executar aquesta consulta. WDQS ho pot suportar (amb prou feines), però el vostre navegador pot blocar-se en intentar mostrar els resultats, per la gran quantitat que n'obtindrà).Ara sabeu com cercar totes les obres d'art, o edificis, o establiments humans: la màgia de wdt:P31/wdt:P279*, acompanyat de la classe apropiada. Això utilitza més característiques d'SPARQL de les que hem explicat fins ara però, sincerament, és gairebé l'únic rellevant d'aquestes característiques, així que «no necessitem» entendre com funciona a fi d'utilitzar WDQS de forma efectiva. Si ho voleu aprendre ho explicarem en breu, però també podeu saltar-vos la propera secció i memoritzar, o copiar, wdt:P31/wdt:P279* per a quan ho necessiteu. Rutes de propietats En general, el camí que connecta el node font (subjecte) amb el node destinació (objecte) a través del gràfic no és sempre directe: és possible que calgui concatenar zero, un o molts enllaços (segments, és a dir, \"elements del camí\") en una cadena; i hi pot haver diversos d'aquests camins (rutes). L'objecte d'un element de camí de la cadena esdevé el subjecte de l'element següent. A SPARQL, les rutes de propietats són una forma concisa d'escriure la ruta de propietats entre dos ítems. La ruta més simple és una sola propietat, la qual forma una terna normal: ?item wdt:P31 ?class. Podeu afegir elements de ruta amb una barra inclinada (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Això és equivalent a qualsevol dels següents: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercici: reescriure la consulta dels «nets de Bach» amb aquesta sintaxi.Un asterisc (*) després d'un element de ruta significa «zero o més d'aquests elements». """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidatas frågetjänst, är ett kraftfullt verktyg som erbjuder insyn i Wikidatas innehåll. Denna guide lär dig hur man använder den. Se även Wikimedia Israels interaktiva guide.Innan du skriver din egen SPRAQL-sökfråga, ta en titt på {{Item documentation}} eller någon annan generisk SPARQL-sökfrågemall och se om din sökfråga redan finns där. Contents 1 Innan vi börjar 2 SPARQL basics 3 Our first query 3.1 Autocompletion 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Qualifiers 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Chemical elements 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Datatyper 9.2 Operators 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Se även Innan vi börjar While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result. SPARQL basics A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach … Autocompletion That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, der Wikidata Query Service, ist ein leistungsfähiges Werkzeug, das dir Einblick in die Inhalte von Wikidata verschafft. In diesem Tutorial lernst du, wie du den WDQS benutzen kannst. Siehe auch das interaktive Tutorial von Wikimedia Israel.Bevor du deine eigene SPARQL-Abfrage schreibst, schaue nach, ob deine Abfrage bereits in {{Item documentation}} oder den anderen SPARQL-Beispielvorlagen enthalten ist. Contents 1 Bevor wir beginnen 2 SPARQL-Basics 3 Unsere erste Abfrage 3.1 Autovervollständigung 4 Fortgeschrittene Tripelmuster 5 Instanzen und Klassen 5.1 Eigenschaftspfade 6 Qualifikatoren 7 ORDER und LIMIT 7.1 Übung 7.1.1 Bücher von Arthur Conan Doyle 7.1.2 Chemische Elemente 7.1.3 Flüsse, die in den Mississippi fließen 7.1.4 Flüsse, die in den Mississippi fließen II 8 OPTIONAL 9 Ausdrücke, FILTER und BIND 9.1 Datentypen 9.2 Operatoren 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Gruppierung 10.1 Einwohnerzahlen von Städten 10.2 Gemäldematerialien 10.3 Waffen nach Hersteller 10.4 Verlage nach Seitenanzahl 10.4.1 HAVING 10.5 Zusammenfassung der Aggregat-Funktionen 10.6 wikibase:Label und Aggregat 11 VALUES 12 Label in multiple languages 13 Und darüber hinaus… 14 Siehe auch Bevor wir beginnen Auch wenn dieser Leitfaden lang und einschüchternd wirkt, lass dich davon nicht abschrecken! Alleine mit den SPARQL-Grundlagen kommst du schon sehr weit. Wenn du nach #Unsere erste Abfrage aufhörst, wirst du schon genug wissen, um viele interessante Abfragen zu erstellen. Mit jedem weiteren Kapitel wirst du in der Lage sein, noch umfangreichere Abfragen zu schreiben.Du hast noch nie von Wikidata, SPARQL oder WDQS gehört? Hier eine kurze Erklärung dieser Begriffe: Wikidata ist eine Wissensdatenbank. Sie enthält Millionen von Aussagen wie zum Beispiel „Die Hauptstadt von Kanada ist Ottawa” oder „Die Mona Lisa wurde mit Ölfarbe auf Pappelholz gemalt” oder „Gold hat einen Schmelzpunkt von 1064,18 Grad Celsius”. SPARQL ist eine Sprache, um Abfragen (Queries) für Wissensdatenbanken zu formulieren. Mit der richtigen Datenbank kann eine SPARQL-Abfrage Fragen wie “Was ist die beliebteste Tonart in der Musik?” oder “Welche Rolle wurde von den meisten Schauspielern gespielt?” oder “Wie ist die Verteilung von Blutgruppen?” oder “Welche Werke von Autoren sind in diesem Jahr frei zugänglich geworden?” beantworten. WDQS, der Wikidata Query Service, bringt diese beiden Dinge zusammen: Du gibst eine SPARQL-Abfrage ein, sie durchsucht die Wikidata-Datensätze und zeigt dir das Resultat.  SPARQL-Basics Eine einfache SPARQL-Abfrage sieht so aus: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Unter SELECT werden die Variablen aufgeführt, die du als Ausgabe haben willst (Variablen beginnen mit einem Fragezeichen) und unter WHERE steht, worauf sie eingeschränkt werden sollen, meistens in Form von Tripeln. Alle Informationen in Wikidata (und ähnlichen Wissensdatenbanken) sind in Tripeln gespeichert. Wenn du die Abfrage durchführst, versucht der Query Service, die Variablen so mit tatsächlichen Werten zu füllen, dass der Tripel in der Wissensdatenbank vorkommt. Zurückgegeben wird dann ein Resultat für jede Kombination von Variablen, die gefunden wird.Ein Tripel kann man wie einen Satz lesen (deshalb endet es auch mit einem Punkt): Es hat ein „Subjekt“, ein „Prädikat“ und ein „Objekt“. Und er hört mit einem Punkt auf. SELECT ?frucht
WHERE
{
  ?frucht hatFarbe gelb.
  ?frucht schmeckt sauer.
} Das Resultat dieser Abfrage könnte zum Beispiel “Zitrone” enthalten. In Wikidata sind die meisten Eigenschaften “hat”-Eigenschaften; die Abfrage sieht somit folgendermaßen aus: SELECT ?frucht
WHERE
{
  ?frucht farbe gelb.
  ?frucht geschmack sauer.
} ... was sich folgendermaßen liest: “?frucht hat farbe ‘gelb’” (nicht “?frucht ist die Farbe von ‘gelb’”. Merk dir das für Eigenschafts-Paare wie “eltern”/“kind”!).Das ist jedoch kein gutes Beispiel für WDQS. Geschmack ist subjektiv, also hat Wikidata dafür keine Eigenschaft. Reden wir stattdessen über Eltern-/Kind-Beziehungen nachdenken, diese sind meistens eindeutig. Unsere erste Abfrage Angenommen wir möchten alle Kinder des Barock-Komponisten Johann Sebastian Bach auflisten. Wie würdest du diese Abfrage schreiben, wenn du Pseudo-Elemente wie im Beispiel oben verwendest?Es sollte etwas in dieser Art sein: SELECT ?kind
WHERE
{
  #  kind \"hat Elternteil\" Bach
  ?kind elternteil Bach
  # (Hinweis: alles nach einem „#“ ist ein Kommentar und wird vom WDQS ignoriert.)
} oder das: SELECT ?kind
WHERE
{
  # kind \"hat Vater\" Bach 
  ?kind vater Bach 
} oder das: SELECT ?kind
WHERE
{
  #  Bach \"hat Kind\" Kind
  Bach unterelement ?kind.
} Die ersten beiden Tripel sagen: ?kind muss den Elternteil/Vater Bach haben; das dritte sagt, dass Bach das Kind ?kind haben muss. Fangen wir erst einmal mit dem zweiten an:Was müssen wir also noch machen, um daraus eine richtige WDQS-Abfrage zu machen? In Wikidata sind Objekte und Eigenschaften nicht mit für Menschen verständlichen Namen wie “Vater” (Eigenschaft) oder “Bach” (Gegenstand) bezeichnet. (Aus gutem Grund: “Johann Sebastian Bach” ist auch der Name eines Deutschen Malers und “Bach” könnte auch ein Vorname, eine Französische Gemeinde, ein Krater auf dem Merkur usw. sein.) Stattdessen teilt Wikidata jedem Objekt und jeder Eigenschaft einen Identifikator zu. Um den Identifikator eines Objekts zu finden, suchen wir das Objekt und kopieren die Q-Nummer des Resultates, welches uns passend erscheint (zum Beispiel aufgrund der Beschreibung). Um den Identifikator für eine Eigenschaft zu finden, machen wir es genauso, suchen aber nach „P:Suchbegriff” statt nur „Suchbegriff”, was unsere Suche auf Eigenschaften beschränkt. Das sagt uns dann, dass der berühmte Komponist Johann Sebastian Bach Q1339 ist und die Eigenschaft, um den Vater eines Gegenstandes zu bestimmen, ist P:P22.Zum Schluss müssen wir noch Präfixe einbinden. Bei einfachen WDQS-Triples sollte Objekten das Präfix wd: und Eigenschaften das Präfix wdt: vorangestellt werden. (Das betrifft aber nur feste Werte, Variablen bekommen kein Präfix!)Zusammengenommen erhalten wir unsere erste richtige WDQS-Abfrage: SELECT ?kind
WHERE
{
# ?kind vater Bach
  ?kind wdt:P22 wd:Q1339.
}
 Try it! Klicke auf den Link „Versuche es” und dann „Abfrage ausführen” auf der WDQS-Seite. Was ist das Ergebnis? kind wd:Q57225 wd:Q76428 … Das Ergebnis ist enttäuschend: Du siehst nur die Identifikatoren der Ergebnisse. Du kannst auf diese Identifikatoren klicken und die dazugehörige Wikidata-Seite (mit verständlichen Beschriftungen) öffnen. Aber kann man die Ergebnisse nicht besser anzeigen?Nun, tatsächlich, das kannst du! (Sind rhetorische Fragen nicht großartig?) Indem du die Zauberworte SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } irgendwo innerhalb des WHERE-Abschnitts einfügst, erhältst du zusätzliche Variablen: Für jede Variable ?foo hast du jetzt eine Variable ?fooLabel, der die Bezeichnung für ?foo beinhaltet. Wenn Du also diese Variable dem SELECT-Abschnitt hinzufügst, wird auch die Bezeichnung angezeigt. SELECT ?kind ?kindLabel
WHERE
{
# ?kind vater Bach
  ?kind wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Probiere die Anfrage aus. Du solltest nun nicht nur die Objektnummern sehen, sondern auch die Namen der verschiedenen Kinder. kind kindLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autovervollständigung Dieses SERVICE-Snippet lässt sich jedoch schwer merken. Und beim Schreiben einer Abfrage die ganze Zeit in der Suchfunktion nachzuschlagen ist umständlich. Glücklicherweise bietet WDQS eine ausgezeichnete Lösung für dieses Problem: „Autovervollständigung”. Im query.wikidata.org Abfrage-Editor kannst du an jedem Punkt der Abfrage mit Strg+Leertaste (oder Alt+Eingabe oder Strg+Alt+Leertaste) Vorschläge für möglicherweise passenden Code angezeigt bekommen. Wähle den richtigen Vorschlag mit den Pfeiltasten nach oben/nach unten aus und bestätige mit der Enter-Taste.Beispielsweise kannst du, statt jedes Mal SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } zu schreiben, einfach SERV tippen, dann Ctrl+Leertaste betätigen. Der erste Vorschlag wird immer der gesamte Label-Service-Aufruf sein, bereit zum Einsatz! Betätige einfach Enter um den Vorschlag anzunehmen. (Die Formatierung wird ein bisschen anders sein, aber das macht nichts.)Die Autovervollständigung kann dir auch beim Suchen helfen. Wenn du eines der Wikidata-Präfixe eingibst, wie zum Beispiel wd: oder wdt:, und dann einfach Text hintendran schreibst, kannst du mit Ctrl+Leertaste eine Suche nach diesem Text in Wikidata veranlassen und dir Suchergebnisse zeigen lassen. wd: sucht nach Datenobjekten, wdt: nach Eigenschaften. Ein Beispiel: Statt nach den Objekten für Johann Sebastian Bach (Q1339) und father (P22)zu suchen, kannst du wd:Bach und wdt:Vat eingeben und dann einfach den richtigen Eintrag aus der Autovervollständigung wählen. (Das funktioniert auch mit Leerzeichen im Text, z. B. wd:Johann Sebastian Bach.) Fortgeschrittene Tripelmuster Jetzt haben wir also alle Kinder von Johann Sebastian Bach gesehen, genauer gesagt: alle Objekte mit dem Vater Johann Sebastian Bach. Aber Bach war zweimal verheiratet, und diese Objekte können verschiedene Mütter haben. Was ist, wenn wir nur die Kinder von Johann Sebastian Bach und seiner ersten Ehefrau, Maria Barbara Bach (Q57487), sehen möchten? Versuche diese Abfrage zu schreiben, basierend auf der von weiter oben.Fertig? OK, dann zur Lösung!Am einfachsten machst du es, indem du ein zweites Tripel mit dieser Beschränkung hinzufügst: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339.
  ?kind wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Übersetzt heißt das: Kind hat Vater Johann Sebastian Bach. Kind hat Mutter Maria Barbara Bach. Klingt ein bisschen umständlich, oder? In natürlicher Sprache würden wir das abkürzen: Kind hat Vater Johann Sebastian Bach und Mutter Maria Barbara Bach. Du kannst diese Abkürzung auch in SPARQL ausdrücken: Wenn du ein Tripel mit einem Semikolon (;) statt mit einem Punkt beendest, kannst du ein weiteres Eigenschaft-Objekt-Paar hinzufügen. Damit verkürzt sich die obige Abfrage zu: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Das ergibt dieselben Ergebnisse – ohne Wiederholungen in der Abfrage.Angenommen, von all diesen Ergebnissen interessieren uns nur die Kinder, die auch Komponisten und Pianisten waren. Die relevanten Eigenschaften und Objekte sind occupation (P106), composer (Q36834) und pianist (Q486748). Versuche, die vorige Abfrage anzupassen, um diese Beschränkung hinzuzufügen!Hier ist meine Lösung: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Diese Lösung verwendet die Abkürzung \";\" zwei weitere Male, um die zwei geforderten Berufe hinzuzufügen. Aber wie du vielleicht merkst, gibt es immer noch Wiederholungen. Es ist als ob wir sagen würden: Das Kind hat den Beruf Komponist und den Beruf Pianist. Das würden wir normalerweise so abkürzen: Das Kind hat die Berufe Komponist und Pianist. SPARQL hat auch hierfür die passende Syntax: Genauso wie ein ; es dir ermöglicht, einem Tripel ein Prädikat-Objekt-Paar hinzuzufügen (unter Wiederverwendung des Subjekts), erlaubt ein , es dir, einem Tripel ein weiteres Objekt hinzuzufügen (unter Wiederverwendung sowohl des Subjekts als auch des Prädikats). So kann die Abfrage wie folgt abgekürzt werden: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Beachte: Einzüge und Leerzeichen spielen keine Rolle, sie machen es nur leichter lesbar. Man könnte es auch so schreiben: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # beide Berufe in einer Zeile
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! oder, nicht so gut lesbar: SELECT ?kind ?kindLabel
WHERE
{
  ?kind wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # ohne Einzüge. Das macht es schwierig, zwischen ; und , zu unterscheiden.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Glücklicherweise rückt der WDQS-Editor Zeilen automatisch ein, d. h. du musst dich normalerweise nicht darum kümmern.Gut, lasst uns hier mal zusammenfassen. Wir haben gesehen, dass Abfragen wie Text strukturiert sind. Jedes Tripel zu einem Subjekt wird mit einem Punkt beendet. Verschiedene Prädikate zum selben Subjekt werden getrennt durch Semikolons und verschiedene Objekte für dasselbe Subjekt und dasselbe Prädikat können getrennt durch Kommas aufgelistet werden. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Jetzt möchte ich dir eine weitere Abkürzung aus dem Repertoire von SPARQL vorstellen. Lass mich dazu wieder ein hypothetisches Szenario beschreiben.Gehen wir davon aus, dass uns Bachs Kinder nicht interessieren. (Wer weiß, vielleicht trifft das ja tatsächlich auf dich zu!). Aber seine Enkelkinder interessieren uns (hypothetisch). Hier wird es kompliziert: Ein Enkelkind kann mit Bach über seine Mutter oder über seinen Vater verwandt sein. Das sind zwei verschiedene Eigenschaften, was unpraktisch ist. Drehen wir lieber die Beziehung um: Wikidata hat auch eine „Kind“-Eigenschaft, P:P40, die vom Elternteil auf das Kind zeigt, und geschlechtsunabhängig ist. Kannst du mithilfe dieser Information eine Abfrage schreiben, die Bachs Enkelkinder ausgibt?Hier ist meine Lösung: SELECT ?enkelkind ?enkelkindLabel
WHERE
{
  wd:Q1339 wdt:P40 ?kind.
  ?kind wdt:P40 ?enkelkind.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Übersetzt heißt das: Bach hat das Kind ?kind. ?kind hat das Kind ?enkelkind. Wieder möchte ich vorschlagen, dass wir diesen Satz abkürzen, und dann möchte ich dir zeigen, wie SPARQL eine ähnliche Abkürzung unterstützt. Du siehst: das Kind ist uns eigentlich egal. Wir verwenden die Variable nur, um etwas über das Enkelkind auszusagen. Wir könnten den Satz also wie folgt abkürzen: Bach hat als Kind jemanden, der das Kind ?enkelkind hat. Statt zu sagen, wer Bachs Kind ist, sagen wir einfach „jemand“: Wer das ist, ist uns egal. Aber wir können auf diese Person verweisen, da wir gesagt haben „jemand der“: Hiermit wird ein Relativsatz angefangen, und innerhalb dieses Satzes können wir Aussagen machen über „jemanden“ (z. B. dass er oder sie „ein Kind ?enkelkind hat“). In gewisser Weise ist „jemand“ eine Variable, aber eine spezielle, die nur gültig ist innerhalb dieses Relativsatzes, und eine, auf die wir nicht explizit verweisen (wir sagen „jemand der dies ist und jenes macht“, nicht „jemand der dies ist und jemand der jenes macht“ - das wären zwei verschiedene Personen).In SPARQL kann dies wie folgt geschrieben werden: SELECT ?enkelkind ?enkelkindLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?enkelkind ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Statt einer Variable kannst du ein Klammernpaar ([]) verwenden, das sich wie eine anonyme Variable verhält. Innerhalb der Klammern kannst du Prädikat-Objekt-Paare spezifizieren, genau so wie nach einem ; nach einem normalem Tripel. Das implizite Subjekt ist in diesem Fall die anonyme Variable, wofür die Klammern stehen. (Anmerkung: genauso wie nach einem ; kannst du mehr Prädikat-Objekt-Paare mit Semikolons hinzufügen, oder mehr Objekte für dasselbe Prädikat mit Kommas.)Und das war’s auch schon mit den Tripelmustern! Es gibt in SPARQL noch mehr davon. Aber wir verlassen jetzt die Bereiche, die der gesprochenen Sprache sehr ähnlich sind. Ich fasse deshalb diesen Zusammenhang noch einmal zusammen: gesprochene Sprache Beispiel SPARQL Beispiel Satz Julia liebt Romeo. Punkt julia liebt romeo. Konjunktion (Klausel) Romeo liebt Julia und tötet sich selbst. Semikolon romeo liebt julia; tötet romeo. Konjunktion (Substantiv) Romeo tötet Tybalt und sich selbst. Komma romeo tötet tybalt, romeo. Relativsatz Julia liebt jemanden der tötet Tybalt. Klammern julia liebt [ tötet tybalt ].  Instanzen und Klassen Vorhin habe ich erzählt, dass die meisten Wikidata-Eigenschaften „hat“-Eigenschaften sind: „hat“ das Kind, „hat“ den Vater, „hat“ den Beruf. Aber manchmal (eher häufig) geht es auch mal um etwas, das „ist“. Tatsächlich gibt es in diesem Fall zwei verschiedene Arten der Beziehung: „Vom Winde verweht“ ist ein Film. Ein Film ist ein Kunstwerk. „Vom Winde verweht“ ist ein bestimmter Film. Er hat einen bestimmten Regisseur (Victor Fleming), eine bestimmte Dauer (238 Minuten), eine Reihe von Darstellern (Clark Gable, Vivien Leigh, …) und so weiter.„Film“ ist ein allgemeines Konzept. Filme können Regisseure, Längen und Darsteller haben, aber das Konzept „Film“ als solches hat keinen bestimmten Regisseur, keine bestimmte Dauer oder keinen bestimmten Darsteller. Und obwohl ein Film ein Kunstwerk ist, und ein Kunstwerk normalerweise einen Urheber hat, hat das Konzept „Film“ selber keinen Urheber – nur bestimmte „Instanzen“ dieses Konzeptes haben einen.Dieser Unterschied ist der Grund, warum es in Wikidata zwei Eigenschaften für „ist“ gibt : instance of (P31) und subclass of (P279). „Vom Winde verweht“ ist eine bestimmte Instanz der Klasse „Film“; die Klasse „Film“ ist eine Unterklasse (spezifischere Klasse; Spezialisierung) der mehr allgemeinen Klasse „Kunstwerk“.Um den Unterschied besser zu verstehen, kannst du zwei verschiedene Formulierungen ausprobieren: „ist ein“ und „ist eine Art von“. Wenn „ist eine Art von“ funktioniert (z.B. ein Film „ist eine Art von“ Kunstwerk), weist das darauf hin, dass du über eine Unterklasse redest – eine Spezialisierung einer größeren Klasse, und du solltest subclass of (P279) verwenden. Wenn „ist eine Art von“ nicht funktioniert (z.B. ergibt der Satz „‚Vom Winde verweht‘ ist eine Art von Film“ wenig Sinn), zeigt das an, dass du über eine bestimmte Instanz redest. Hier solltest du instance of (P31) verwenden.Was bedeutet das für uns, wenn wir SPARQL-Abfragen schreiben? Wenn wir „alle Kunstwerke“ suchen wollen, genügt es nicht, alle Datenobjekte, die unmittelbare Instanzen von „Kunstwerk“ sind, zu suchen: SELECT ?kunstwerk ?kunstwerkLabel
WHERE
{
  ?kunstwerk wdt:P31 wd:Q838948. # Instanz von Kunstwerk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Diese Abfrage ergibt zurzeit (Oktober 2016) 2815 Ergebnisse. Doch natürlich gibt es viel mehr Kunstwerke! Das Problem ist, dass die Abfrage Objekte wie „Vom Winde verweht“ nicht findet. Das Objekt ist eine Instanz von „Film“, nicht aber von „Kunstwerk“. „Film“ ist eine Unterklasse von „Kunstwerk“, aber wir müssen SPARQL sagen, dass das bei der Suche berücksichtigt werden muss.Eine mögliche Lösung hierfür ist die []-Syntax, von der wir gerade sprachen: Vom Winde verweht ist eine Instanz einer bestimmten Unterklasse von „Kunstwerk“. (Versuche diese Abfrage zu schreiben, als Übung!) Aber das verursacht immer noch Probleme: Wir verwenden nun keine Objekte mehr, die eine unmittelbare Instanz von „Kunstwerk“ sind. Objekte, die eine Instanz von Unterklassen von anderen Unterklassen sind, entgehen uns: So ist z.B. Schneewittchen und die sieben Zwerge ein Zeichentrickfilm, was ein Film ist, was ein Kunstwerk ist. In diesem Fall müssen zwei „Unterklasse von“-Aussagen folgen - aber es könnten auch drei, vier, fünf, oder beliebig mehr sein. Die Lösung: ?objekt wdt:P31/wdt:P279* ?klasse. Dies heißt, dass es eine \"Instanz von\" und dann eine beliebige Anzahl von \"Unterklassen von\" Aussagen zwischen dem Datenobjekt und der Klasse. SELECT ?kunstwerk ?kunstwerkLabel
WHERE
{
  ?kunstwerk wdt:P31/wdt:P279* wd:Q838948. # Instanz von einer beliebigen Unterklasse von Kunstwerk
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (Ich empfehle, diese Abfrage nicht auszuführen. WDQS kann damit (gerade so) umgehen, aber dein Browser könnte beim Versuch abstürzen, die Ergebnisse anzuzeigen, weil die Liste extrem lang ist.)Jetzt weißt du, wie man alle Kunstwerke suchen kann, oder alle Gebäude, oder alle menschlichen Siedlungen: verwende den magischen Aufruf wdt:P31/wdt:P279*, zusammen mit der passenden Klasse. Dies verwendet einige SPARQL-Merkmale die ich noch nicht erklärt habe, aber mal ganz ehrlich, dies ist fast der einzige relevante Gebrauch von diesen Merkmalen, also du \"brauchst\" nicht zu verstehen wie sie funktionieren um WDQS wirksam zu benutzen. Falls du es wissen möchtest: ich erkläre es etwas später, aber du kannst auch einfach den nächsten Abschnitt überspringen und dir wdt:P31/wdt:P279* merken oder es von hier aus kopieren und einfügen, wenn du es benötigst. Eigenschaftspfade Eigenschaftspfade sind eine Möglichkeit, einen Pfad von Eigenschaften zwischen zwei Objekten in sehr kurzer Form auszudrücken. Der einfachste Pfad ist eine einzige Eigenschaft, also ein gewöhnliches Tripel: ?item wdt:P31 ?class. Du kannst Pfadelemente mit einen Schrägstrich (/) hinzufügen. ?item wdt:P31/wdt:P279/wdt:P279 ?class. Dies entspricht einer der folgenden Varianten: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Übung: Schreibe die obige \"Enkelkinder von Bach\"-Abfrage mit dieser Syntax.Ein Sternchen (*) nach einem Pfad-Element bedeutet \"keines oder mehr von diesem Element\". """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 Сервис запросов Викиданных (WDQS, Wikidata Query Service) – мощный инструмент, позволяющий работать с содержимым Викиданных. Данное руководство расскажет, как работать с этим сервисом. См. также интерактивное руководство от Wikimedia Israel.Перед тем как написать свой собственный запрос SPARQL, посмотрите на шаблон {{Item documentation}} или любой другой шаблон запроса SPARQL и посмотрите, не включён ли уже туда ваш запрос. Contents 1 Перед началом 1.1 Основы SPARQL 2 Ваш первый запрос 2.1 Автозаполнение 3 Advanced triple patterns 4 Частные случаи и классы 4.1 Property paths 5 Квалификаторы 6 ORDER and LIMIT 6.1 Упражнение 6.1.1 Книги Артура Конан Дойля 6.1.2 Химические элементы 6.1.3 Реки, впадающие в Миссисипи 6.1.4 Rivers that flow into the Mississippi II 7 OPTIONAL 8 Expressions, FILTER and BIND 8.1 Типы данных 8.2 Операторы 8.3 FILTER 8.4 BIND, BOUND, IF 8.5 COALESCE 9 Группирование 9.1 Население города 9.2 Painting materials 9.3 Guns by manufacturer 9.4 Publishers by number of pages 9.4.1 HAVING 9.5 Aggregate functions summary 9.6 wikibase:Label and aggregations 10 VALUES 11 Label in multiple languages 12 И далее… 13 См. также Перед началом Хотя это руководство может показаться очень длинным и пугающим, не позвольте этому вас отпугнуть! Простое изучение основ SPARQL поможет вам пройти долгий путь — даже если вы перестанете читать после вашего первого запроса, вы уже будете понимать достаточно, чтобы построить много интересных запросов. Каждый раздел этого руководства даст вам возможность писать еще более мощные запросы.Если вы никогда прежде не слышали о Викиданных, SPARQL или WDQS, вот краткое описание этих понятий: Викиданные — это база знаний. Она содержит миллионы таких утверждений, как, например, «столицей Канады является Оттава», «„Мона Лиза“ написана масляными красками по тополю» или «золото имеет температуру плавления 1064,18 градусов Цельсия». SPARQL — это язык формулировки вопросов (запросов) к базам знаний. При обращении к подходящей базе запрос SPAQRL может дать ответы на такие вопросы, как «Какая самая распространённая музыкальная тональность?», «Какого персонажа играло наибольшее количество актёров?», «Каково распределение групп крови?» или «Произведения каких авторов перешли в общественное достояние в этом году?». WDQS, Wikidata Query Service (Сервис запросов Викиданных), совмещает их: вы вводите запрос SPARQL, сервис обращается с ним к содержимому Викиданных и показывает вам результат.  Основы SPARQL Простой SPARQL-запрос выглядит следующим образом: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} В секции SELECT перечислены переменные, которые вы хотите получить в результате запроса (переменные начинаются со знака вопроса). В секции WHERE содержатся условия, уточняющие их, в основном в виде троек. Вся информация в Викиданных (и аналогичных базах данных знаний) хранится в виде троек; когда вы запускаете запрос, служба запроса пытается заполнить переменные фактическими значениями, чтобы получаемые тройки присутствовали в базе данных знаний, и возвращает один результат для каждой комбинации переменных, которую она находит. Тройку можно рассматривать как предложение (поэтому она заканчивается точкой), содержащее \"субъект\", \"предикат\" и \"объект\": SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Результаты этого запроса могут включать, например, «лимон». В Викиданных большинство свойств подразумевают «имеет», так что запрос можно прочитать так: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} который читается как \"?fruit\" имеет цвет \"жёлтый\" (но не \"?fruit\" есть цвета \"желтого\" - имейте это в виду, пары свойств похожи как сотношение \"родители\"/\"дети\"!).Однако это не хороший пример для WDQS. Вкус субъективен, поэтому Викиданные не имеют такого свойства. Вместо этого, давайте подумаем об отношениях родители/дети, которые в основном однозначны. Ваш первый запрос Предположим, мы хотим получить список всех детей композитора эпохи барокко Иоганна Себастьяна Баха. При использовании псевдоэлементов, как в запросах выше, как бы вы составили такой запрос?Надеемся у вас получилось что-то вроде этого: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (Примечание: текст после символа \"#\" - это комментарий и игнорируется WDQS.)
} или этого: SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} или этого: SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} Первые два триплета говорят, что у ?child должен быть родитель/отец Бах; третий говорит, что у Баха должен быть ребенок ?child. Давайте присмотримся ко второму.Итак, что еще нужно сделать, чтобы превратить это в правильный запрос WDQS? На Викиданных элементы и свойства не обозначаются человекочитаемыми именами, такими как \"отец\" (свойство) или \"Бах\" (элемент). (по уважительной причине: \"Иоганн Себастьян Бах\" это и имя немецкого художника, и фамилия, и французская коммуна, и кратер Меркурия и т. д.) Вместо этого, элементам и свойствам в Викиданных присваивается идентификатор. Чтобы найти идентификатор для элемента мы ищем элемент и копируем Q-номер результата, описание которого походит на элемент, который мы ищем. Чтобы найти идентификатор для свойства, мы делаем то же самое, но ищем \"P:search term\" вместо просто \"search term\" (соответственно, \"P:отец\" и \"Бах\"), что ограничивает поиск именно поиском в свойствах. В результате узнаём, что знаменитый композитор Иоганн Себастьян Бах имеет код Q1339, а свойство для обозначения отца предмета - это P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Автозаполнение That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! По-русски это читается так: У рёбёнка есть отец Иоганн Себастьян Бах. У ребёнка есть мать Мария Барбара Бах. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: У ребёнка есть отец Иоганн Себастьян Бах и мать Мария Барбара Бах. На самом деле возможно произвести такое сокращение и в SPARQL: если вы завершаете тройку точкой с запятой (;) вместо точки, вы можете добавить ещё пару предикат-объект. Это позволяет сократить запрос выше до такого: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! что позволяет получить те же результаты, но с меньшими повторениями внутри запроса. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! или, чуть хуже читаемо: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! К счастью, редактор WDQS делает отступы строчек автоматически, так что обычно вам не нужно беспокоиться об этом. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). На языке SPARQL это может быть записано следующим образом: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language пример SPARQL пример sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. квадратные скобки juliet loves [ kills tybalt ].  Частные случаи и классы Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: «Унесённые ветром» является фильмом. Фильм является произведением искусства. «Унесённые ветром» — это один конкретный фильм. У него есть определённый режиссёр (Виктор Флеминг), определённая длительность (238 минут), актёрская труппа (Кларк Гейбл, Вивьен Ли, …) и так далее.Фильм — это более общее понятие. У фильмов есть режиссёры, длительность, актёры, но у самого по себе понятия «фильм» нет конкретных режиссёра, длительности или актёров. И хотя фильм является произведением искусства, а у произведения искусства обычно есть создатель, само понятие «фильм» не имеет создателя — лишь его частные случаи имеют такового.Из-за этого различия в Викиданных есть два свойства для «является»: instance of (P31) и subclass of (P279). «Унесённые ветром» — это конкретный, частный случай класса «фильм»; класс «фильм», в свою очередь, — это подкласс (более узкий класс) более общего класса «произведение искусства». To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). Так что это означает для нас при написании запросов SPARQL? Когда мы хотим найти «все произведения искусства», недостаточно искать все элементы, которые являются непосредственно частным случаем «произведения искусства»: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, Wikidata Query Service (Служба запитів Вікіданих) – це потужний інструмент для надання інформації про вміст Вікіданих. Цей підручник навчить вас, як користуватися WDQS. Див. також інтерактивний підручник від Wikimedia Israel.Перш ніж писати свій власний запит SPARQL, подивіться {{Item documentation}} або будь-який інший типовий шаблон запиту SPARQL і подивіться, чи ваш запит уже включено. Contents 1 Перед тим, як почати 2 Основи SPARQL 3 Наш перший запит 3.1 Автозавершення 4 Удосконалені схеми триплетів 5 Екземпляри й класи 5.1 Шляхи властивостей 6 Кваліфікатори 7 ORDER і LIMIT 7.1 Вправа 7.1.1 Книги Артура Конана Дойла 7.1.2 Хімічні елементи 7.1.3 Річки, що впадають у Міссісіпі 7.1.4 Річки, що впадають у Міссісіпі II 8 OPTIONAL 9 Вирази, FILTER і BIND 9.1 Типи даних 9.2 Оператори 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Групування 10.1 Міське населення 10.2 Матеріал для картин 10.3 Вогнепальна зброя за виробником 10.4 Видавці за кількістю сторінок 10.4.1 HAVING 10.5 Огляд агрегатних функцій 10.6 wikibase:Назви й агрегації 11 VALUES 12 Label in multiple languages 13 А далі… 14 Див. також Перед тим, як почати Хоча цей посібник може виглядати дуже довгим і складним, будь ласка, не дозволяйте цьому лякати вас! Просто вивчивши основи SPARQL, ви пройдете довгий шлях - навіть якщо ви перестанете читати після нашого першого запиту, ви вже зрозумієте достатньо, щоб створити багато цікавих запитів. Кожен розділ цього підручника дозволить вам писати ще потужніші запити.Якщо ви ніколи раніше не чули про Вікідані, SPARQL або WDQS, ось коротке пояснення цих термінів: Вікідані – це база даних знань. Вона містить мільйони тверджень, наприклад, «столиця Канади — Оттава», «Мона Ліза намальована олійною фарбою на дереві тополі», або «золото має температуру плавлення 1064,18 градуса за Цельсієм». SPARQL – це мова для формулювання питань (запитів) до баз даних знань. Для правильної бази даних запит SPARQL міг би відповісти на такі запитання, як \"яка найпопулярніша тональність у музиці?\" або \"який персонаж був зображений більшістю акторів?\" або \"який розподіл груп крові?\" або \"роботи яких авторів перейшли у суспільне надбання цього року?\". WDQS, служба запитів Вікіданих, об’єднує їх разом: ви вводите запит SPARQL, служба запускає його з набором даних Вікіданих та показує вам результат.  Основи SPARQL Простий запит SPARQL виглядає так: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} Пункт SELECT перераховує змінні, які ви хочете повернути (змінні починаються із знака питання), а пункт WHERE містить обмеження на них, переважно у формі триплетів. Уся інформація у Вікіданих (і аналогічних базах даних знань) зберігається у вигляді триплетів; коли ви запускаєте запит, служба запитів намагається заповнити змінні фактичними значеннями, так, як отримані триплети з'являються в базі знань, і повертає один результат для кожної комбінації змінних, які вона знаходить.Триплет можна розглядати як дві вершини (псевдоніми — два вузли, два ресурси), з’єднані ребром (дугою, властивістю) всередині величезного орієнтованого (спрямованого) мультиграфа властивостей, який утворює Вікідані. Його можна читати як речення (тому він закінчується крапкою), з суб'єктом (підметом, subject), предикатом (присудком, predicate) і об'єктом (додатком, object): SELECT ?fruit
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} Результати для цього запиту можуть включати, наприклад, «лимон». У Вікіданих більшість властивостей є властивостями типу «має» («has»), тому запит можна читати навпаки: SELECT ?fruit
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} який читається як «?fruit має колір 'yellow'» (не «?fruit є колір 'yellow'» – майте це на увазі для таких пар властивостей, як «батько»/«дитина»!).Однак це не дуже хороший приклад для WDQS. Смак суб’єктивний, тому Вікідані не мають властивостей для нього. Натомість давайте подумаємо про відношення між батьками та дітьми, які переважно однозначні. Наш перший запит Припустимо, ми хочемо скласти список усіх дітей барокового композитора Йоганна Себастьяна Баха. Використовуючи псевдоелементи, як у запитах вище, як би ви написали цей запит?Сподіваємось, у вас є щось на зразок цього: SELECT ?child
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (примітка: все після ‘#’ є коментарем й ігнорується у WDQS.)
} або цього SELECT ?child
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} або цього SELECT ?child
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?child
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
}
 Try it! Натисніть посилання \"Виконати!\", потім \"Виконати запит\" на сторінці WDQS. Що ви отримуєте? child wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?child wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. child childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Автозавершення That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.)  Удосконалені схеми триплетів Отже, тепер ми побачили всіх дітей Йогана Себастьяна Баха - конкретніше: усі елементи з батьком Йоганном Себастьяном Бахом. Але Бах мав двох дружин, і тому в цих елементах є дві різні матері: що, якщо ми хочемо бачити дітей Йогана Себастьяна Баха зі своєю першою дружиною, Марією Барбарою Бах (Q57487)? Спробуйте записати цей запит, виходячи із зазначеного вище.Зробили це? Добре, тоді до рішення! Найпростіший спосіб зробити це - додати другий триплет з цим обмеженням: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339.
  ?child wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?child wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?child.
  ?child wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language example SPARQL example sentence Juliet loves Romeo. period juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. semicolon romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. comma romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ].  Екземпляри й класи Раніше я сказав, що більшість властивостей Wikidata відношення \"має\": \"має\" дитину, \"має\" батька, \"має\" професію. Але іноді (насправді, часто), вам також потрібно поговорити про те, що \"є\". Але існують фактично два види відношень: Звіяні вітром є фільмом. Фільм є мистецьким твором. Звіяні вітром - це один конкретний фільм. Він має конкретного режисера (Віктор Флемінг), певну тривалість (238 хвилин), список акторів (Кларк Гейбл, Вів'єн Лі, ...) тощо.\"Фільм\" - це загальне поняття. Фільми можуть мати режисерів, тривалості й акторів, але поняття \"фільм\" як таке не має жодного конкретного режисера, тривалості або акторів. І хоча фільм є мистецьким твором, а мистецький твір зазвичай має творця, у самому понятті \"фільм\" немає творця - його мають лише окремі \"екземпляри\" (\"instances\") цього поняття.Ця різниця полягає в тому, що у Вікіданих є дві властивості для \"є\": instance of (P31) і subclass of (P279). Звіяні вітром - це окремий примірник класу \"фільм\"; клас \"фільм\" - це підклас (більш специфічний клас, спеціалізація) більш загального класу \"витвір мистецтва\".Щоб допомогти вам зрозуміти різницю, ви можете спробувати використовувати два різних дієслова: \"є\" і \"є свого роду\". Якщо \"є свого роду\" твір (наприклад, фільм - це \"є свого роду\" \"витвір мистецтва\"), це означає, що ви говорите про підклас, спеціалізацію ширшого класу, і ви повинні використовувати subclass of (P279). Якщо \"є свого роду\" не працює (наприклад, вислів \"Звіяні вітром \"є свого роду\" фільмом\" не має сенсу), це означає, що ви говорите про конкретний екземпляр, і ви повинні використовувати instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it.  Шляхи властивостей Загалом, шлях, що з'єднує вузол-джерело (суб'єкт) з цільовим вузлом (об'єктом) через граф, не завжди є прямим: може знадобитися об'єднати нуль, одну або багато ланок (сегментів, тобто елементів шляху) в ланцюг; і таких шляхів (маршрутів) може бути кілька. Об'єкт елемента шляху в ланцюгу стає суб'єктом наступного елемента. У SPARQL Шляхи властивостей — це спосіб дуже стисло записати такий шлях властивостей між двома елементами. Найпростішим шляхом є лише одна властивість, що формує звичайний триплет: ?item wdt:P31 ?class. Ви можете додати елементи шляху, використовуючи косу риску (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. Це еквівалентно одному з таких записів: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Вправа: перепишіть попередній запит \"онуки Баха\" з використанням цього синтаксису.Зірочка (*) після елемента шляху означає “нуль або більше цих елементів\". """@en,
    """Other languages: Bahasa Indonesia British English Deutsch English Lëtzebuergesch Nederlands Türkçe català dansk eesti español français italiano polski português do Brasil svenska ślůnski русский українська հայերեն עברית العربية 中文 日本語 WDQS, the Wikidata Query Service, is a powerful tool to provide insight into Wikidata's content. This guide will teach you how to use it. See also the interactive tutorial by Wikimedia Israel. Before writing your own SPARQL query, look at {{Item documentation}} or any other generic SPARQL query template and see if your query is already included.  Contents 1 Zanim zaczniemy 2 Podstawy SPARQL 3 Our first query 3.1 Autouzupełnianie 4 Advanced triple patterns 5 Instances and classes 5.1 Property paths 6 Kwalifikatory 7 ORDER and LIMIT 7.1 Exercise 7.1.1 Arthur Conan Doyle books 7.1.2 Pierwiastki chemiczne 7.1.3 Rivers that flow into the Mississippi 7.1.4 Rivers that flow into the Mississippi II 8 OPTIONAL 9 Expressions, FILTER and BIND 9.1 Typy danych 9.2 Operatory 9.3 FILTER 9.4 BIND, BOUND, IF 9.5 COALESCE 10 Grouping 10.1 City populations 10.2 Painting materials 10.3 Guns by manufacturer 10.4 Publishers by number of pages 10.4.1 HAVING 10.5 Aggregate functions summary 10.6 wikibase:Label and aggregations 11 VALUES 12 Label in multiple languages 13 And beyond… 14 Zobacz też Zanim zaczniemy While this guide may look very long and intimidating, please don’t let that scare you away! Just learning the SPARQL basics will get you a long way – even if you stop reading after #Our first query, you will already understand enough to construct many interesting queries. Each section of this tutorial will empower you to write even more powerful queries. If you have never heard of Wikidata, SPARQL, or WDQS before, here’s a short explanation of those terms: Wikidata is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”. SPARQL is a language to formulate questions (queries) for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. WDQS, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result.  Podstawy SPARQL A simple SPARQL query looks like this: SELECT ?a ?b ?c
WHERE
{
  x y ?a.
  m n ?b.
  ?b f ?c.
} The SELECT clause lists variables that you want returned (variables start with a question mark), and the WHERE clause contains restrictions on them, mostly in the form of triples. All information in Wikidata (and similar knowledge databases) is stored in the form of triples; when you run the query, the query service tries to fill in the variables with actual values so that the resulting triples appear in the knowledge database, and returns one result for each combination of variables it finds. A triple can be viewed as two vertices (alias 2 nodes, 2 resources) connected by an edge (an arc, a property) inside the vast directed (oriented) property multigraph which forms Wikidata. It can be read like a sentence (which is why it ends with a period), with a subject, a predicate, and an object: SELECT ?owoc
WHERE
{
  ?fruit hasColor yellow.
  ?fruit tastes sour.
} The results for this query could include, for example, “lemon”. In Wikidata, most properties are “has”-kind properties, so the query might instead read: SELECT ?owoc
WHERE
{
  ?fruit color yellow.
  ?fruit taste sour.
} which reads like “?fruit has color ‘yellow’” (not “?fruit is the color of ‘yellow’” – keep this in mind for property pairs like “parent”/“child”!). However, that’s not a good example for WDQS. Taste is subjective, so Wikidata doesn’t have a property for it. Instead, let’s think about parent/child relationships, which are mostly unambiguous. Our first query Suppose we want to list all children of the baroque composer Johann Sebastian Bach. Using pseudo-elements like in the queries above, how would you write that query? Hopefully you got something like this: SELECT ?dziecko
WHERE
{
  #  child \"has parent\" Bach
  ?child parent Bach.
  # (note: everything after a ‘#’ is a comment and ignored by WDQS.)
} or this, SELECT ?dziecko
WHERE
{
  # child \"has father\" Bach 
  ?child father Bach. 
} or this, SELECT ?dziecko
WHERE
{
  #  Bach \"has child\" child
  Bach child ?child.
} The first two triples say that the ?child must have the parent/father Bach; the third says that Bach must have the child ?child. Let’s go with the second one for now. So what remains to be done in order to turn this into a proper WDQS query? On Wikidata, items and properties are not identified by human-readable names like “father” (property) or “Bach” (item). (For good reason: “Johann Sebastian Bach” is also the name of a German painter, and “Bach” might also refer to the surname, the French commune, the Mercury crater, etc.) Instead, Wikidata items and properties are assigned an identifier. To find the identifier for an item, we search for the item and copy the Q-number of the result that sounds like it’s the item we’re looking for (based on the description, for example). To find the identifier for a property, we do the same, but search for “P:search term” instead of just “search term”, which limits the search to properties. This tells us that the famous composer Johann Sebastian Bach is Q1339, and the property to designate an item’s father is P:P22. And last but not least, we need to include prefixes. For simple WDQS triples, items should be prefixed with wd:, and properties with wdt:. (But this only applies to fixed values – variables don’t get a prefix!) Putting this together, we arrive at our first proper WDQS query: SELECT ?dziecko
WHERE
{
# ?child  father   Bach
  ?dziecko wdt:P22 wd:Q1339.
}
 Try it! Click that “Try it” link, then “Run” the query on the WDQS page. What do you get? dziecko wd:Q57225 wd:Q76428 … Well that’s disappointing. You just see the identifiers. You can click on them to see their Wikidata page (including a human-readable label), but isn’t there a better way to see the results? Well, as it happens, there is! (Aren’t rhetorical questions great?) If you include the magic text SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". } somewhere within the WHERE clause, you get additional variables: For every variable ?foo in your query, you now also have a variable ?fooLabel, which contains the label of the item behind ?foo. If you add this to the SELECT clause, you get the item as well as its label: SELECT ?child ?childLabel
WHERE
{
# ?child  father   Bach
  ?dziecko wdt:P22 wd:Q1339.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Try running that query – you should see not only the item numbers, but also the names of the various children. dziecko childLabel wd:Q57225 Johann Christoph Friedrich Bach wd:Q76428 Carl Philipp Emanuel Bach …  Autouzupełnianie That SERVICE snippet looks tough to remember though, right? And going through the search function all the time while you’re writing the query is also tedious. Fortunately, WDQS offers a great solution to this: autocompletion. In the query.wikidata.org query editor, you can press Ctrl+Space (or Alt+Enter or Ctrl+Alt+Enter) at any point in the query and get suggestions for code that might be appropriate; select the right suggestion with the up/down arrow keys, and press Enter to select it. For example, instead of writing out SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". } every time, you can just type SERV, hit Ctrl+Space, and the first suggestion will be that complete label service incantation, ready for use! Just hit Enter to accept it. (The formatting will be a bit different, but that doesn’t matter.) And autocompletion can also search for you. If you type one of the Wikidata prefixes, like wd: or wdt:, and then just write text afterwards, Ctrl+Space will search for that text on Wikidata and suggest results. wd: searches for items, wdt: for properties. For example, instead of looking up the items for Johann Sebastian Bach (Q1339) and father (P22), you can just type wd:Bach and wdt:fath and then just select the right entry from the autocompletion. (This even works with spaces in the text, e.g. wd:Johann Sebastian Bach.) Advanced triple patterns So now we’ve seen all children of Johann Sebastian Bach – more specifically: all items with the father Johann Sebastian Bach. But Bach had two wives, and so those items have two different mothers: what if we only want to see the children of Johann Sebastian Bach with his first wife, Maria Barbara Bach (Q57487)? Try writing that query, based on the one above. Done that? Okay, then onto the solution! The simplest way to do this is to add a second triple with that restriction: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339.
  ?dziecko wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In English, this reads: Child has father Johann Sebastian Bach. Child has mother Maria Barbara Bach. That sounds a bit awkward, doesn’t it? In natural language, we’d abbreviate this: Child has father Johann Sebastian Bach and mother Maria Barbara Bach. In fact, it’s possible to express the same abbreviation in SPARQL as well: if you end a triple with a semicolon (;) instead of a period, you can add another predicate-object pair. This allows us to abbreviate the above query to: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! which has the same results, but less repetition in the query. Now suppose that, out of those results, we’re interested only in those children who were also composers and pianists. The relevant properties and items are occupation (P106), composer (Q36834) and pianist (Q486748). Try updating the above query to add these restrictions! Here’s my solution: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834;
         wdt:P106 wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! This uses the ; abbreviation two more times to add the two required occupations. But as you might notice, there’s still some repetition. This is as if we said: Child has occupation composer and occupation pianist. which we would usually abbreviate as: Child has occupation composer and pianist. And SPARQL has some syntax for that as well: just like a ; allows you to append a predicate-object pair to a triple (reusing the subject), a , allows you to append another object to a triple (reusing both subject and predicate). With this, the query can be abbreviated to: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834,
                  wd:Q486748.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Note: indentation and other whitespaces don’t actually matter – they just make it more readable. You can also write this as: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
         wdt:P25 wd:Q57487;
         wdt:P106 wd:Q36834, wd:Q486748.
  # both occupations in one line
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! or, rather less readable: SELECT ?child ?childLabel
WHERE
{
  ?dziecko wdt:P22 wd:Q1339;
  wdt:P25 wd:Q57487;
  wdt:P106 wd:Q36834,
  wd:Q486748.
  # no indentation; makes it hard to distinguish between ; and ,
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! Luckily, the WDQS editor indents lines for you automatically, so you usually don’t have to worry about this. Alright, let’s summarize here. We’ve seen that queries are structured like text. Each triple about a subject is terminated by a period. Multiple predicates about the same subject are separated by semicolons, and multiple objects for the same subject and predicate can be listed separated by commas. SELECT ?s1 ?s2 ?s3
WHERE
{
  ?s1 p1 o1;
      p2 o2;
      p3 o31, o32, o33.
  ?s2 p4 o41, o42.
  ?s3 p5 o5;
      p6 o6.
} Now I want to introduce one more abbreviation that SPARQL offers. So if you’ll humor me for one more hypothetical scenario… Suppose we’re not actually interested in Bach’s children. (Who knows, perhaps that’s actually true for you!) But we are interested in his grandchildren. (Hypothetically.) There’s one complication here: a grandchild may be related to Bach via the mother or the father. That’s two different properties, which is inconvenient. Instead, let’s flip the relation around: Wikidata also has a “child” property, P:P40, which points from parent to child and is gender-independent. With this information, can you write a query that returns Bach’s grandchildren? Here’s my solution: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 ?dziecko.
  ?dziecko wdt:P40 ?grandChild.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! In natural language, this reads: Bach has a child ?child. ?child has a child ?grandChild. Once more, I propose that we abbreviate this English sentence, and then I want to show you how SPARQL supports a similar abbreviation. Observe how we actually don’t care about the child: we don’t use the variable except to talk about the grandchild. We could therefore abbreviate the sentence to: Bach has as child someone who has a child ?grandChild. Instead of saying who Bach’s child is, we just say “someone”: we don’t care who it is. But we can refer back to them because we’ve said “someone who”: this starts a relative clause, and within that relative clause we can say things about “someone” (e.g., that they “have a child ?grandChild”). In a way, “someone” is a variable, but a special one that’s only valid within this relative clause, and one that we don’t explicitly refer to (we say “someone who is this and does that”, not “someone who is this and someone who does that” – that’s two different “someone”s). In SPARQL, this can be written as: SELECT ?grandChild ?grandChildLabel
WHERE
{
  wd:Q1339 wdt:P40 [ wdt:P40 ?grandChild ].
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! You can use a pair of brackets ([]) in place of a variable, which acts as an anonymous variable. Inside the brackets, you can specify predicate-object pairs, just like after a ; after a normal triple; the implicit subject is in this case the anonymous variable that the brackets represent. (Note: also just like after a ;, you can add more predicate-object pairs with more semicolons, or more objects for the same predicate with commas.) And that’s it for triple patterns! There’s more to SPARQL, but as we’re about to leave the parts of it that are strongly analogous to natural language, I’d like to summarize that relationship once more: natural language przykład SPARQL przykład zdanie Juliet loves Romeo. kropka juliet loves romeo. conjunction (clause) Romeo loves Juliet and kills himself. średnik romeo loves juliet; kills romeo. conjunction (noun) Romeo kills Tybalt and himself. przecinek romeo kills tybalt, romeo. relative clause Juliet loves someone who kills Tybalt. brackets juliet loves [ kills tybalt ]. Instances and classes Earlier, I said that most Wikidata properties are “has” relations: has child, has father, has occupation. But sometimes (in fact, frequently), you also need to talk about what something is. But there are in fact two kinds of relations there: Gone with the Wind is a film. A film is a work of art. Gone with the Wind is one particular film. It has a particular director (Victor Fleming), a specific duration (238 minutes), a list of cast members (Clark Gable, Vivien Leigh, …), and so on. Film is a general concept. Films can have directors, durations, and cast members, but the concept “film” as such does not have any particular director, duration, or cast members. And although a film is a work of art, and a work of art usually has a creator, the concept of “film” itself does not have a creator – only particular instances of this concept do. This difference is why there are two properties for “is” in Wikidata: instance of (P31) and subclass of (P279). Gone with the Wind is a particular instance of the class “film”; the class “film” is a subclass (more specific class; specialization) of the more general class “work of art”. To help you to figure about the difference, you can try to use two different verbs: \"is a\" and \"is a kind of\". If \"is a kind of\" works (e.g. A film \"is a kind of\" work of art), it indicates that you are talking about a subclass, a specialization of a broader class and you should use subclass of (P279). If \"is a kind of\" does not work (e.g. the sentence Gone with the wind \"is a kind of\" film does not make sense), it indicates that you are talking about a particular instance and you should use instance of (P31). So what does this mean for us when we’re writing SPARQL queries? When we want to search for “all works of art”, it’s not enough to search for all items that are directly instances of “work of art”: SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31 wd:Q838948. # instance of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! As I’m writing this (October 2016), that query only returns 2,815 results – obviously, there are more works of art than that! The problem is that this misses items like Gone with the Wind, which is only an instance of “film”, not of “work of art”. “film” is a subclass of “work of art”, but we need to tell SPARQL to take that into account when searching. One possible solution to this is the [] syntax we talked about: Gone with the Wind is an instance of some subclass of “work of art”. (For exercise, try writing that query!) But that still has problems: We’re no longer including items that are directly instances of work of art. We’re still missing items that are instances of some subclass of some other subclass of “work of art” – for example, Snow White and the Seven Dwarfs is an animated film, which is a film, which is a work of art. In this case, we need to follow two “subclass of” statements – but it might also be three, four, five, any number really. The solution: ?item wdt:P31/wdt:P279* ?class. This means that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. SELECT ?work ?workLabel
WHERE
{
  ?work wdt:P31/wdt:P279* wd:Q838948. # instance of any subclass of work of art
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE]\". }
}
 Try it! (I don’t recommend running that query. WDQS can handle it (just barely), but your browser might crash when trying to display the results because there are so many of them.) Now you know how to search for all works of art, or all buildings, or all human settlements: the magic incantation wdt:P31/wdt:P279*, along with the appropriate class. This uses some more SPARQL features that I haven’t explained yet, but quite honestly, this is almost the only relevant use of those features, so you don’t need to understand how it works in order to use WDQS effectively. If you want to know, I’ll explain it in a bit, but you can also just skip the next section and memorize or copy+paste wdt:P31/wdt:P279* from here when you need it. Property paths In general, the path which connects the source-node (subject) to the target-node (object) through the graph is not always direct: one may have to concatenate zero, one or many links (segments, namely path elements) into a chain; and there may be several such paths (routes). The object of a path element in the chain becomes the subject of the next element. In SPARQL, Property paths are a way to very tersely write down such a path of properties between two items. The simplest path is just a single property, which forms an ordinary triple: ?item wdt:P31 ?class. You can add path elements with a forward slash (/). ?item wdt:P31/wdt:P279/wdt:P279 ?class. This is equivalent to either of the following: ?item wdt:P31 ?temp1.
?temp1 wdt:P279 ?temp2.
?temp2 wdt:P279 ?class. ?item wdt:P31 [ wdt:P279 [ wdt:P279 ?class ] ]. Exercise: rewrite the “grandchildren of Bach” query from earlier to use this syntax. An asterisk (*) after a path element means “zero or more of this element”. """@en;
  dcterms:isPartOf <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/lb>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/he>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/szl>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/en-gb>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/zh>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/et>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/pt-br>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/hy>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/tr>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/id>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/da>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ar>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ja>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/es>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/it>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ca>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/sv>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/de>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/ru>, <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/uk>,
    <https://www.wikidata.org//wiki/Wikidata:SPARQL_tutorial/pl>;
  dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/>;
  sh:prefixes _:wikidata_prefixes, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-wikidata_prefixes,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-3B6992BB44CDFE6F54DA37A6D40EFC7B, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-C8E6F068397E4FE4B34F91D839F6FF2A,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-0A02614E93131D1C40E2B1A14580857F, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-43FA9E0BEB946BD68A003D3E39BB1275,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-11BED62A75FC1CE1122BAE6BB21707C0, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-7ABCF2C06C15C521FDB336E232398982,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-D5EA179168BA5E06698CE795857D8375, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-F83BFEC3652840E9F44CA3AB6F6F616B,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-D1DD1C5A376E487D7300F20D24646F12, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-0F816478B8B665AE5667D404D9995C99,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-3BB8709BB3114A1A31D328415166AAA8, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-ABBD43907EC5589DCF08101E8F780E91,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-D40D1353E00C6DB0D4A851D498D7D1D8, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-4DE8CE5B733269C9605FC85BCD8B3F29,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-9CC6FE814CD2268605E3F9FC462F8E50, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-EEE22FCA9A7220BD398DBEE43220FF42,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-6D3200D6C37571EE57889433A9A2990B, _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-BFC23B9E98453C4834F5B62B78423F4D,
    _:genid-9eb55b2583ef4ad09d9d48ff9f18ffec115163-3F5FDA5144488211231F2C75F913B63B;
  schema:target <https://query.wikidata.org/sparql/> .

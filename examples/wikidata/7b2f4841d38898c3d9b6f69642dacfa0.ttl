@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix schema: <https://schema.org/> .

<https://www.wikidata.org/#query-7b2f4841d38898c3d9b6f69642dacfa0> a sh:SPARQLExecutable;
  rdfs:comment """ This page is an archive. Please do not modify it. Use the current page, even to continue an old discussion. Contents 1 Instances of website (Q35127) that do not have privacy policy (P7101) 2 List of works entering the public domain in a given year 3 find an artist by the signing date of an art work and the initials of the artist 4 P31=Q11173 with missing german description 5 One condition works fine, two time out 6 Norwegians date of death 7 Look for continent first and then country 8 Query about women artists in Latin America 9 Need help with request 10 Struggling to import strings via quickstatements 11 refine a stats query 12 Search for text string with accompanying main subject (P921) 13 Items with existing it.wiki article but without wikidata Italian label 14 People that died on January 2021 15 Searching for result by matching item label with request parameter 16 Get items where \"instance of\" is a subclass of another item 17 Places near the sea 18 quick question about querying for qualifiers 19 List of data for stars with distance from Earth of less than 30 LY or parallax > 100 milli arc seconds. 19.1 What units do normalised values use 20 Get wikis statistics from a query 21 youtube videos published by The Great War (Q30598122) 22 wikipedia page name 23 Ranking airports by their biggest fall / smallest fall patronage (P3872) 24 Brothers and sisters without P3373 25 Query all triples of a page 26 Wikidata list 27 ?COUNT and ?BIND 28 hint:Query hint:optimizer \"Runtime\" . hint:Query hint:maxParallel 50 29 Continent of a city 30 The wrong reference 31 Unconnected pages (SQL) 32 Count gender in a list Instances of website (Q35127) that do not have privacy policy (P7101) AntisocialRyan (talk) 06:58, 1 January 2021 (UTC) @AntisocialRyan: Lots of them. SELECT ?item ?itemLabel 
WHERE 
{
  ?item wdt:P31 wd:Q35127.
  FILTER NOT EXISTS {?item wdt:P7101 [] .}
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! --Tagishsimon (talk) 07:47, 1 January 2021 (UTC) This is what I needed! Thanks! AntisocialRyan (talk) 18:13, 1 January 2021 (UTC) But if you mean website items where it is explicitly stated with a novalue values that no privacy policy exists there are currently none: SELECT ?item ?itemLabel 
WHERE 
{
  ?item wdt:P31 wd:Q35127 .
  ?item a wdno:P7101 .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! --Dipsacus fullonum (talk) 14:06, 1 January 2021 (UTC) List of works entering the public domain in a given year Inspired by this, I'd like a query for creative works entering the public domain in the US on the account of the date of publication/release. So for this year, that would mean works published in 1925. But next year, 1926. I'd like to see a query that will not need to be tweaked every year and will always be current. NMaia (talk) 12:54, 1 January 2021 (UTC) I'm going to duck the larger question of the list of works based on publication date, for now, and just focus on \"not need to be tweaked every year\", which for the example query looks something like this: # Find works with a public domain date (P3893) in the calendar year in which the query is run
SELECT ?work ?workLabel ?type ?typeLabel ?date ?articles ?now ?then WHERE {
  ?work p:P3893/psv:P3893 ?date_node .
  ?date_node wikibase:timeValue ?date .
  BIND(xsd:dateTime(concat(str(year(now())),\"-01-01T00:00:00Z\")) as ?now) 
  BIND(xsd:dateTime(concat(str(year(now()+\"P1Y\"^^xsd:duration)),\"-01-01T00:00:00Z\")) as ?then) 
#  FILTER( ?date >= \"2021-01-01T00:00:00\"^^xsd:dateTime && ?date < \"2022-01-01T00:00:00\"^^xsd:dateTime )
  FILTER( ?date >= ?now && ?date < ?then )
  ?work wdt:P31 ?type ;
           wikibase:sitelinks ?articles .
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"fr,en,de,it,es,nl\" . }
}
# Order by number or articles on Wikimedia sites
ORDER BY DESC(?articles)
 Try it! --Tagishsimon (talk) 17:14, 1 January 2021 (UTC) Thank you! The issue is that public domain date (P3893) is not (yet) widespread, so publication date seems like it would catch nearly all cases. NMaia (talk) 04:41, 2 January 2021 (UTC) @NMaia: I don't have my copyright thinking hat on, but, is publication date the key, or is date of death of the author? I vaguely thought copyright in written works was life+nn years. If so, the query would find people who died in the pertinent year, and then list their works? Something like this. SELECT ?item ?itemLabel ?person ?personLabel ?dod WITH {
  SELECT DISTINCT ?item ?person ?dod WHERE {
  ?person wdt:P570 ?dod .
  BIND(xsd:dateTime(?dod + \"P96Y\"^^xsd:duration) as ?date)
  BIND(xsd:dateTime(concat(str(year(now())),\"-01-01T00:00:00Z\")) as ?now) 
  BIND(xsd:dateTime(concat(str(year(now()+\"P1Y\"^^xsd:duration)),\"-01-01T00:00:00Z\")) as ?then) 
  FILTER( ?date >= ?now && ?date < ?then )
  ?item wdt:P50 ?person .
    }  } as %i
WHERE
{
  INCLUDE %i
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\" . }
}
 Try it! If instead we want to assess by publication date (P577) I regret to inform there are quite a lot of those, and we'd probably need to select subsets of the written work (Q47461344) class tree in order to get the query to run without timeout. We'd also need to be savvy about the difference between works and editions ... P31 values for written works (scholarly articles and some others aside) are a hotching great mess, which is why I'm not mad keen to dive in. --Tagishsimon (talk) 05:23, 2 January 2021 (UTC) find an artist by the signing date of an art work and the initials of the artist I have tried this: # find an artist by the signing date of an art work and the initials of the artist.
SELECT ?item ?itemLabel ?itemDescription ?yearOfBirth ?yearOfDeath $firstnameLabel ?lastnameLabel WITH {
  SELECT DISTINCT ?item WHERE {
    ?item wdt:P31 wd:Q5.
    ?item wdt:P106/wdt:P279* wd:Q21148249 . #wd:Q3391743 . #Q483501 
    ?item wdt:P569 [].
    ?item wdt:P735 [].
    ?item wdt:P734 [].
}
} AS %subquery1 WHERE {
  INCLUDE %subquery1 .
    BIND (1670 as ?yearOfWork). # year on the work of art
    BIND (\"^J.*\" as ?firstnamePattern). # first letter of initials, assuming firstname
    BIND (\"^B.*\" as ?lastnamePattern). # second letter of initials, assuming lastname

    #?item wdt:P31 wd:Q5.
    #?item wdt:P106/wdt:P279* wd:Q21148249 . #Q3391743 . #Q483501 
    ?item wdt:P569 ?birthDate .
    bind (year(?birthDate) as ?yearOfBirth)
    Filter (?yearOfBirth+20 < ?yearOfWork) # assuming was not creative before the age of 20
    optional {?item wdt:P570 ?deathDate .
              bind (year(?deathDate) as ?yearOfDeath)
              Filter (?yearOfDeath >= ?yearOfWork)
             }
    ?item wdt:P735 ?firstname.
    ?item wdt:P734 ?lastname.
    ?firstname rdfs:label ?firstnameLabel .
    ?lastname rdfs:label ?lastnameLabel .
    FILTER(LANG(?firstnameLabel) = 'de' && LANG(?lastnameLabel) = 'de'
                && regex(?firstnameLabel, ?firstnamePattern, \"i\") && regex(?lastnameLabel, ?lastnamePattern, \"i\")) .

  SERVICE wikibase:label { bd:serviceParam wikibase:language '[AUTO_LANGUAGE,de,en]' }
} GROUP BY ?item ?itemLabel ?itemDescription ?yearOfBirth ?yearOfDeath $firstnameLabel ?lastnameLabel ORDER BY ASC(?lastnameLabel)
 limit 100
 Try it! It works for small sets of matches, but runs into timeout when e.g. changing from enameler (Q21148249) to visual artist (Q3391743) (which I really want). Any hints on how to improve the performance? --Herzi Pinki (talk) 16:23, 1 January 2021 (UTC) See Wikidata:Request_a_query/Archive/2020/11#publications_from_a_particular_year_and_place about the date queries. Instead of rdfs:label for the name, you might want to use the native label statement. commenting out '?firstname rdfs:label ?firstnameLabel' and the following (as ?firstnameLabel is predefined anyway), will be fast, but not return any result. I do not understand why this makes a difference, but it obviously does. --Herzi Pinki (talk) 20:18, 1 January 2021 (UTC) Possibly, year of death is more frequently available than date of birth. Some artists also have only work period specified. There is a tradeoff with artists still living. Who will not have a date of death. But date of birth should be optional too. --Herzi Pinki (talk) 20:18, 1 January 2021 (UTC) After \"?item wdt:P106/wdt:P279* wd:Q21148249\" you might want to add hint:Prior hint:gearing \"forward\". . --- Jura 17:39, 1 January 2021 (UTC) @Herzi Pinki: I would first filter for the least common initial in a new named subquery, and then for the other initial in another new named subquery, and then for the other conditions (years) in other subqueries. The goal would be to reduce the result set as fast as possible so you can avoid using time to process the last name and compare with the last name initial if first name doesn't match the first name initial, or inverse, and so on. But I doubt that timeout can be avoided even with the best possible optimization for visual artist (Q3391743) because there are too many (around 423900 distinct items) of these. --Dipsacus fullonum (talk) 18:52, 1 January 2021 (UTC) Your last statement says: Wikidata does not scale well? This will be an ever growing problem as more and more data get put into wikidata. I was thinking that '&& regex(?firstnameLabel, ?firstnamePattern, \"i\") && regex(?lastnameLabel, ?lastnamePattern, \"i\")' will only evaluate the second condition, if and only if the first one evaluates to true. Is this correct (like in C)? --Herzi Pinki (talk) 20:18, 1 January 2021 (UTC) @Herzi Pinki: SELECT (COUNT(*) as ?count) 
{
    ?item wdt:P569 ?d1 ; wdt:P570 ?d2 . 
    hint:Prior hint:rangeSafe true .
    FILTER( ?d1 < \"1670-00-00\"^^xsd:dateTime
            && ?d2 > \"1671-00-00\"^^xsd:dateTime )
    ?item wdt:P735 / wdt:P1705 ?nl0 . FILTER( REGEX(?nl0, \"^J\" ) )
    ?item wdt:P734 / wdt:P1705 ?nl1 . FILTER( REGEX(?nl1, \"^B\" ) )
}
 Try it! Counts 325 in a few seconds --- Jura 20:33, 1 January 2021 (UTC)@Jura1: helped a lot. thx. Now my query looks like this (with visual artist (Q3391743) and with null-values for missing dates): SELECT ?item ?itemLabel ?itemDescription (GROUP_CONCAT(DISTINCT ?profLabel; SEPARATOR=', ') AS ?profLabels) ?yearOfBirth ?yearOfDeath ?firstnameLabel ?lastnameLabel where 
{
    ### variable search parameters
    BIND (1960 as ?dateOfWork) .
    BIND (\"^D\" as ?firstnamePattern). # first letter of initials, assuming firstname
    BIND (\"^K\" as ?lastnamePattern). # second letter of initials, assuming lastname
    ###
  
    optional {?item wdt:P569 ?d1.}
    optional {?item wdt:P570 ?d2.}
    BIND(IF(BOUND(?d1), year(?d1), 0) AS ?yearOfBirth) . # use null value
    BIND(IF(BOUND(?d2), year(?d2), 3000) AS ?yearOfDeath) .
    hint:Prior hint:rangeSafe true .
    ?item wdt:P106/wdt:P279* wd:Q3391743 . #Q483501 
    ?item wdt:P106 ?prof.
    OPTIONAL {
      ?prof rdfs:label ?profLiteral .
      FILTER(LANG(?profLiteral) = 'de') .
    }

    BIND(IF(BOUND(?prof), IF(BOUND(?profLiteral), ?profLiteral, STRAFTER(STR(?prof), 'entity/')), 'no Prof') AS ?profLabel) .

    FILTER( ?yearOfBirth+20 <= ?dateOfWork && ?yearOfDeath >= ?dateOfWork )
    ?item wdt:P735 / wdt:P1705 ?firstname . FILTER( REGEX(?firstname, \"^D\" ) ) # ok
    ?item wdt:P734 / wdt:P1705 ?lastname . FILTER( REGEX(?lastname, \"^K\" ) )
    #?item wdt:P735 / wdt:P1705 ?firstname . FILTER( REGEX(?firstname, ?firstnamePattern ) ) # not ok
    #?item wdt:P734 / wdt:P1705 ?lastname . FILTER( REGEX(?lastname, ?lastnamePattern ) )
    OPTIONAL { ?firstname rdfs:label ?firstnameLabel . FILTER(LANG(?firstnameLabel) = 'de') . }
    OPTIONAL { ?lastname rdfs:label ?lastnameLabel . FILTER(LANG(?lastnameLabel) = 'de') . }

    SERVICE wikibase:label { bd:serviceParam wikibase:language '[AUTO_LANGUAGE,de,en]' }
} group by ?item ?itemLabel ?itemDescription ?profLabels ?yearOfBirth ?yearOfDeath ?firstnameLabel ?lastnameLabel
 Try it!and finishes in time. I tried something else:SELECT ?item ?itemLabel ?itemDescription (GROUP_CONCAT(DISTINCT ?profLabel; SEPARATOR=', ') AS ?profLabels) ?yearOfBirth ?yearOfDeath ?firstnameLabel ?lastnameLabel where 
{
    ### variable search parameters
    BIND (1960 as ?dateOfWork) .
    BIND (\"^D\" as ?firstnamePattern). # first letter of initials, assuming firstname
    BIND (\"^K\" as ?lastnamePattern). # second letter of initials, assuming lastname
    ###
  
    optional {?item wdt:P569 ?d1.}
    optional {?item wdt:P570 ?d2.}
    BIND(IF(BOUND(?d1), year(?d1), 0) AS ?yearOfBirth) . # use null value
    BIND(IF(BOUND(?d2), year(?d2), 3000) AS ?yearOfDeath) .
    hint:Prior hint:rangeSafe true .
    ?item wdt:P106/wdt:P279* wd:Q3391743 . #Q483501 
    ?item wdt:P106 ?prof.
    OPTIONAL {
      ?prof rdfs:label ?profLiteral .
      FILTER(LANG(?profLiteral) = 'de') .
    }

    BIND(IF(BOUND(?prof), IF(BOUND(?profLiteral), ?profLiteral, STRAFTER(STR(?prof), 'entity/')), 'no Prof') AS ?profLabel) .

    FILTER( ?yearOfBirth+20 <= ?dateOfWork && ?yearOfDeath >= ?dateOfWork )
    #?item wdt:P735 / wdt:P1705 ?firstname . FILTER( REGEX(?firstname, \"^D\" ) ) # ok
    #?item wdt:P734 / wdt:P1705 ?lastname . FILTER( REGEX(?lastname, \"^K\" ) )
    ?item wdt:P735 / wdt:P1705 ?firstname . FILTER( REGEX(?firstname, ?firstnamePattern ) ) # not ok
    ?item wdt:P734 / wdt:P1705 ?lastname . FILTER( REGEX(?lastname, ?lastnamePattern ) )
    OPTIONAL { ?firstname rdfs:label ?firstnameLabel . FILTER(LANG(?firstnameLabel) = 'de') . }
    OPTIONAL { ?lastname rdfs:label ?lastnameLabel . FILTER(LANG(?lastnameLabel) = 'de') . }

    SERVICE wikibase:label { bd:serviceParam wikibase:language '[AUTO_LANGUAGE,de,en]' }
} group by ?item ?itemLabel ?itemDescription ?profLabels ?yearOfBirth ?yearOfDeath ?firstnameLabel ?lastnameLabel
 Try it! (filtering names via patterns set in advance - the only diff is the 2 lines doing the filtering with regex near the end) and this again runs into timeout. As far as I understand, BIND is the sparql equivalent for setting a local variable. Seems to be a bug, that using the same regular pattern as a literal will finish in time, and using the same regular pattern set via a variable will fail.One more question / problem: running the query with D and K will yield also Theodor Kelter (Q2417843) (and others, all with Initials T & K), where the firstname is shown as Dr. Theodor (this explains the match). I have no idea where the title in the first name comes from and how to skip those matches.The hint:Prior hint:rangeSafe true . does not seem to make much difference now. best --Herzi Pinki (talk) 12:24, 2 January 2021 (UTC) for the initial problem to identify DK on File:1160 Neulerchenfelder Straße 10 - Wandrelief Gründung der Gemeinde Neulerchenfeld IMG 3110.jpg I failed --Herzi Pinki (talk) 12:28, 2 January 2021 (UTC) SELECT DISTINCT ?item ?d1 ?d2 ?nl0 ?nl1 ?itemDescription
{
    ?item wdt:P569 ?d1 ; wdt:P570 ?d2 .
    hint:Prior hint:rangeSafe true .
    FILTER( ?d1 > \"1880-00-00\"^^xsd:dateTime &&
             ?d2 > \"1964-00-00\"^^xsd:dateTime &&
            ?d1 < \"1944-00-00\"^^xsd:dateTime
          )
    ?item wdt:P735 / wdt:P1705 ?nl0 . FILTER( REGEX(?nl0, \"^D\" ) )
    ?item wdt:P734 / wdt:P1705 ?nl1 . FILTER( REGEX(?nl1, \"^K\" ) )
    ?item wdt:P106/wdt:P279* wd:Q3391743 .
     hint:Prior hint:gearing \"forward\".   
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! @Herzi Pinki: I think once saw a bug report about the BIND problem. It's slower than directly setting the regex. \"hint:Prior hint:rangeSafe true\" probably wont work in your sample if I understood Dipsacus fullonum's explanation at Wikidata:Request_a_query/Archive/2020/11#publications_from_a_particular_year_and_place correctly. \"Dr. Theodor\" is from @Geertivp:'s edit. I hope they eventually clean it up (it happened on other names as well). Above one for DK in 1964. Maybe you need to add more P734 to make it work. --- Jura 13:24, 2 January 2021 (UTC)  Items used: visual artist (Q3391743)   Properties used: occupation (P106)   , subclass of (P279)   , given name (P735)   , family name (P734)   # completeness P735/734 for visual artists
SELECT
  (COUNT(DISTINCT ?item) as ?all)
  (COUNT(DISTINCT ?hasP735) as ?P735)
  (COUNT(DISTINCT ?hasP734) as ?P734)
WHERE
{
    ?item wdt:P106/wdt:P279* wd:Q3391743 .
    hint:Prior hint:gearing \"forward\".   
    OPTIONAL { ?item wdt:P735 [] . BIND(?item as ?hasP735) } 
    OPTIONAL { ?item wdt:P734 [] . BIND(?item as ?hasP734) } 
} Try it! --- Jura 13:33, 2 January 2021 (UTC) P31=Q11173 with missing german description Hello, could anyone help me out with a query that gives out all items with instance of (P31)=chemical compound (Q11173) and no description for de? Best regards --Ameisenigel (talk) 21:15, 3 January 2021 (UTC) @Ameisenigel: That is impossible as there would be 709,952 results (found with this Search). A normal query will look like this: SELECT ?item
WHERE
{
  ?item wdt:P31 wd:Q11173 .
  FILTER NOT EXISTS
  {
    ?item schema:description ?description .
    FILTER (LANG(?description) = \"de\")
  }
}
 Try it! but it will timeout without adding a LIMIT. You can use the CirrusSearch from above via the MWAPI service: SELECT ?item
WHERE
{
  SERVICE wikibase:mwapi
  {
    bd:serviceParam wikibase:api \"Search\" .
    bd:serviceParam wikibase:endpoint \"www.wikidata.org\" .
    bd:serviceParam mwapi:srsearch \"haswbstatement:P31=Q11173 -hasdescription:de\" .
    ?item wikibase:apiOutputItem mwapi:title.
  }
}
 Try it! but that query will only give 10000 results as that is a MWAPI hard limit --Dipsacus fullonum (talk) 21:51, 3 January 2021 (UTC) @Dipsacus fullonum: Thanks! This is perfect. --Ameisenigel (talk) 08:12, 4 January 2021 (UTC)  I think that this discussion is resolved and can be archived. If you disagree, don't hesitate to replace this template with your comment. Ameisenigel (talk) 08:12, 4 January 2021 (UTC) One condition works fine, two time out I often have a problem when I want the intersection of two conditions that work fine in their own queries, but when combined they time out.For example, I want to know the people that is both descendant of Alexander VI (Q108316) and ascendant of Philippe of Belgium (Q155004). Asking for just one condition works fine: SELECT DISTINCT ?persona ?personaLabel
WHERE {
  wd:Q108316 wdt:P40* ?persona.
SERVICE wikibase:label {
bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],ca,en,es,an,eu\" .
}
}
 Try it! SELECT DISTINCT ?persona ?personaLabel
WHERE {
   ?persona wdt:P40* wd:Q155004.
SERVICE wikibase:label {
bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],ca,en,es,an,eu\" .
}
}
 Try it! However, a query combining both conditions times out: SELECT DISTINCT ?persona ?personaLabel
WHERE {
   ?persona wdt:P40* wd:Q155004.
   wd:Q108316 wdt:P40* ?persona.
SERVICE wikibase:label {
bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],ca,en,es,an,eu\" .
}
}
 Try it! My guess is that I should tell the query to work on one condition and there work in the other one but using only the results from the previous one, but I don't know how to tell that to the optimizer.--Pere prlpz (talk) 23:55, 3 January 2021 (UTC) @Pere prlpz: One way to be absolutely sure that two graph patterns are evaluated independently of each other is to put each in a separate named subquery: SELECT DISTINCT ?persona ?personaLabel
WITH { SELECT ?persona WHERE { ?persona wdt:P40* wd:Q155004 . } } AS %1
WITH { SELECT ?persona WHERE { wd:Q108316 wdt:P40* ?persona. } } AS %2
WHERE {
  INCLUDE %1
  INCLUDE %2
  SERVICE wikibase:label {
    bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],ca,en,es,an,eu\" .
  }
}
 Try it! --Dipsacus fullonum (talk) 00:36, 4 January 2021 (UTC) @Pere prlpz: By the way, I think the problem with your query above was that the engine would first find all solutions to one part, e.g. all descendants of Alexander VI (Q108316) and then for each of these find all their descendants in order to check if Philippe of Belgium (Q155004) is one of them. That meant that it would find all descendants or ascendants for thousands people instead of only for 2 people. That's why I separated the two parts in named subqueries to be sure they ran independently. --Dipsacus fullonum (talk) 00:52, 4 January 2021 (UTC) @Dipsacus fullonum: Great. Thank you. I think an example like this one should be included in Wikidata:SPARQL_query_service/query_optimization#Named_subqueries, because from reading that section I couldn't manage to understand how to implement it.--Pere prlpz (talk) 10:56, 4 January 2021 (UTC) Norwegians date of death Is it possible to have a list of country of citizenship (P27) Norway (Q20) who do not have a date of death (P570) Pmt (talk) 10:35, 4 January 2021 (UTC) Items used: Norway (Q20)   Properties used: country of citizenship (P27)   , date of birth (P569)   , date of death (P570)   SELECT ?item ?itemLabel ?itemDescription ?dob
WHERE
{
	?item wdt:P27 wd:Q20 . 
	# ?item wdt:P569 ?dob . hint:Prior hint:rangeSafe true . FILTER ( ?dob < \"1910-00-00\"^^xsd:dateTime )
	FILTER NOT EXISTS { ?item wdt:P570 [] }
	SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],nn,nb,en\". }
} Try it!--- Jura 10:44, 4 January 2021 (UTC) @Jura1: Thank a lot! May be I should have been more presicee and aked to have sorted out only persons born before 1920, wich will be compliant with the last norwegian census available. Breg Pmt (talk) 12:35, 4 January 2021 (UTC) The problem is how to remove people that are living, but don't have a DOB. If you have ideas for criteria, you could add them to the above (more \"FILTER NOT EXISTS\" parts in the query). --- Jura 12:39, 4 January 2021 (UTC) So if I want to see only persons born before 1920 I should useSELECT ?item ?itemLabel ?itemDescription ?dob WHERE { ?item wdt:P27 wd:Q20 . # ?item wdt:P569 ?dob . hint:Prior hint:rangeSafe true . FILTER ( ?dob < \"1910-00-00\"^^xsd:dateTime ) FILTER ( ?dob < \"1920-00-00\"^^xsd:dateTime ) FILTER NOT EXISTS { ?item wdt:P570 [] } SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],nn,nb,en\". } }Pmt (talk) 12:58, 4 January 2021 (UTC) SELECT ?item ?itemLabel ?itemDescription ?dob
WHERE
{
	?item wdt:P27 wd:Q20 . 
	?item wdt:P569 ?dob . hint:Prior hint:rangeSafe true . FILTER ( ?dob < \"1920-00-00\"^^xsd:dateTime )
	FILTER NOT EXISTS { ?item wdt:P570 [] }
	SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],nn,nb,en\". }
}
 Try it!--- Jura 13:02, 4 January 2021 (UTC)Nice thanks a lot :) Pmt (talk) 13:28, 4 January 2021 (UTC) Look for continent first and then country Hi, I have a large query where I search for mathematicians of the world, along with their country and continent, and other optional properties.This is probably very not optimised, but I somehow managed to have all the results in due time, except for the country label, but it times out when I request the country label.I'm really lost in writing SPARQL queries and mainly got there by copy/pasting and trial/error attempts. I would just like to retrieve countries names, and I feel somehow the search is badly performed, it would be smarter to loop over continents, and then loop over countries, but my knowledge is too limited and since the query is already long I don't manage to make it work with trial/error method. Could you help me out? SELECT ?id ?idLabel ?country ?countryLabel ?continent  ?occupation ?parentId ?optionAward ?optionAwardLabel ?mgid ?optionNotable_work ?optionNotable_workLabel ?optionWikipedia_article ?influencer (SAMPLE(?student) AS ?student) (SAMPLE(?img) AS ?img) WHERE {
  ?id wdt:P106 wd:Q170790;
    rdfs:label ?idLabel.
  FILTER((LANG(?idLabel)) = \"en\")
  ?country rdfs:label ?countryLabel.
  FILTER((LANG(?countryLabel)) = \"en\")
  ?id wdt:P27 ?country.
  ?country wdt:P30 ?continent.
  OPTIONAL {
    ?optionWikipedia_article schema:about ?id;
      schema:isPartOf <https://en.wikipedia.org/>.
  }
  OPTIONAL { ?id wdt:P18 ?img. }
  OPTIONAL {
    ?id p:P800 _:b102.
    _:b102 ps:P800 ?optionNotable_work.
    ?optionNotable_work rdfs:label ?optionNotable_workLabel.
    FILTER((LANG(?optionNotable_workLabel)) = \"en\")
  }
  OPTIONAL {
    ?id wdt:P166 ?optionAward.
    ?optionAward rdfs:label ?optionAwardLabel.
    FILTER((LANG(?optionAwardLabel)) = \"en\")
  }
  OPTIONAL {
    ?id (wdt:P802|wdt:P185) ?student.
    ?student wdt:P106 wd:Q170790.
  }
  OPTIONAL {
    ?id (p:P1066|p:P184) _:b103.
    _:b103 (ps:P1066|ps:P184) ?parentId.
    ?parentId wdt:P106 wd:Q170790.
  }
  OPTIONAL { ?id wdt:P737 ?influencer. }
}
GROUP BY ?id ?idLabel ?country ?countryLabel ?continent    ?occupation ?parentId ?optionAward ?optionAwardLabel ?mgid ?optionNotable_work ?optionNotable_workLabel ?optionWikipedia_article ?influencer
 Try it! Because some countries have parts in more than one continent, it isn't possible to know what continent a person is from if you only know their country of citizenship. It is not possible to query for the continent of mathematicians because the data isn't available. --Dipsacus fullonum (talk) 18:21, 2 January 2021 (UTC) Actually it's not a big deal if one item has more than one continent (and it turns out that some mathematicians have many countries and many continents), I have some kind of merge function that I apply afterwards, I would just like the query to go through. Well, I suppose that some would find it a problem to say that e.g. all Americans come from both North America and Oceania, but if it is no big deal for you then fine. I could run the query unchanged in 45 seconds. I suppose some optimizations can be done, but as the query has 83,099 results it will always take considerably time to run. --Dipsacus fullonum (talk) 23:10, 2 January 2021 (UTC) Mmmh I see your point. From what I observed, the 'main continent' is listed first. Is there a way to access specifically the first item of such a list or properties? Alternatively, I could manually modify property ranking for those that I spot, so that the query only retrieves the preferred property, for instance 'Europe' is preferable than 'North America' for 'Russian Empire'. Unfortunately I can't see the 'Edit button', is it because I'm not confirmed? I have only 10 registered edits, because I've done many of them anonymously. Could someone 'confirm me'? There is no defined order of statements in Wikidata, so none is \"listed first\". I wouldn't change rankings for this. Russia is both in Europe and Asia; USA is both in North America and Oceania (e.g. Hawaii) etc. What are the criteria for considering one part higher ranked than another? --Dipsacus fullonum (talk) 11:38, 4 January 2021 (UTC) I have not understood everything in this system but it seems some properties are'preferred' to others. An example I stumbled upon recently is the 'notable works' of the Mathematician Henri Poincaré (https://www.wikidata.org/wiki/Q81082) His book 'science and hypothesis' is preferred to others and it is the only match to the query select ?notableWork  where {  wd:Q81082  wdt:P800  ?notableWork. }
 Try it! I don't really understood why but why not? But in this respect if North America is not a preferred continent for USA than Oceani then what is?? As a side question why can I modify notable works of 'Henri Poincaré' but not those of 'Russian Empire'? North America and Oceania are preferred rank for the USA item b/c those are the two continents where the USA has territory. Asia is normal rank b/c USA once had territory there, but no longer. The point of the preferred statements is to indicate, in effect, the truth of the situation NOW is that the USA has 2 continents; and of the normal rank 'that it once had this continent.' It would annoy Hawaii somewhat if North America alone were preferred since WD would suggest that the USA is not in Oceania. So Preferred tends to be used where there are a plurality of statements, some true now, some true once. Rank is very useful. Also very dangerous. In a set of notable works statements, to make one or some preferred, and others normal, begs the question of on what basis the selection is made. Douobtless the ranks will make sense presuming a set of assumptions, and will make no sense based on others. The way to deal with this in SPARQL is to use p:/ps: property paths if you want to see all values, and wdt: if you wish to see only truthy values. Meanwhile you can edit the notable works of 'Henri Poincaré' b/c that item has some. You cannot edit those of the 'Russian Empire' b/c there are none to edit. You can add some & then edit ... but does an Empire have notable works? --Tagishsimon (talk) 14:41, 4 January 2021 (UTC) Ok thanks for the explanation, I have indeed used p/ps for some other times when I wanted ALL properties, but here it is the opposite I am looking for 'the most relevant property'. I agree Hawaii could be upset that Oceania is not related to USA but it could understand North America is more relevant than Oceania if only one has to be chosen, and that could be useful for many ways one has to use WD. My point is that it seems that what is ranked higher or not is mainly subjective, as you can see with the notable works of Poincaré, they are all 'truly' works he has done (in the past), so why some are ranked higher? Is it somewhere in the guidelines of WD that a property is ranked higher if it is true now and lower if it was only true in the past? It obviously does not apply to all categories. I will not modify Russian Empire before I have totally understood this point, but why can't I modify continents of a country (neither Oceania nor Asia for USA) when I can modify notable works of Poincaré? Yes; on Poincare, generally agree it is invideous to prefer some of his works. I don't follow your point on 'why can't I modify continents of a country'. You almost certainly can add, remove, qualify, change rank. Explain some more? --Tagishsimon (talk) 15:22, 4 January 2021 (UTC) I just don't see any 'Edit' link anywhere in the page of the USA. Do you? Maybe some pages are considered more sensitive than others. Back to the main topic, basically if someone asks me what is the continent of USA I would answer 'North America' and I would probably not be the only one, I was wondering why this could not come up as a 'preferred statement', and what are in general the guidelines that determine how to choose how prefered statements are decided. Query about women artists in Latin America Hello! I've been trying to set up a query about cis (Q6581072) and transgender (Q1052281) women and non-binary people (Q48270) from Latin America and the Caribbean (Q72829598) who are artists (Q483501) and/or authors (Q482980) and who don't have an article in the Spanish Wikipedia. I used the examples and tried to mix them but failed. Please, can you help me? Thank you very much.--Pablísima (talk) 15:10, 4 January 2021 (UTC) @Pablísima: It can done like this. Note that some persons are in the result more than once due several occupations or countries. SELECT DISTINCT ?item ?gender ?country ?occupation
WITH { SELECT ?country WHERE { wd:Q72829598 wdt:P527+ ?country . } } AS %get_countries  
WHERE
{
  ?item wdt:P31 wd:Q5 . # humans
  VALUES ?gender { wd:Q6581072 wd:Q1052281 wd:Q48270 }
  ?item wdt:P21 ?gender .
  INCLUDE %get_countries
  ?item wdt:P27 ?country .
  ?item wdt:P106 ?occupation .
  {
    ?occupation wdt:P279* wd:Q483501 .
    hint:Prior hint:gearing \"forward\" .
  }
  UNION
  {
    ?occupation wdt:P279* wd:Q482980 .
    hint:Prior hint:gearing \"forward\" .
  }
  FILTER NOT EXISTS
  {
    [] schema:about ?item ; schema:isPartOf <https://es.wikipedia.org/> .
  }
}
 Try it! --Dipsacus fullonum (talk) 16:04, 4 January 2021 (UTC) @Dipsacus fullonum: Thank you very much! Last questions: How can you make the results be sorted alphabetically by country? And how can you see the results by item label, country label and occupation label? Thanks again, this is very helpful.--Pablísima (talk) 16:24, 4 January 2021 (UTC) @Pablísima: Here is version with labels and sorted by country. It is slower and may sometimes timeout. SELECT ?item ?itemLabel ?genderLabel ?countryLabel ?occupationLabel
WITH { SELECT ?country WHERE { wd:Q72829598 wdt:P527+ ?country . } } AS %get_countries
WITH
{
  SELECT DISTINCT ?item ?gender ?country ?occupation
  WHERE
  {
    ?item wdt:P31 wd:Q5 .
    VALUES ?gender { wd:Q6581072 wd:Q1052281 wd:Q48270 }
    ?item wdt:P21 ?gender .
    INCLUDE %get_countries
    ?item wdt:P27 ?country .
    ?item wdt:P106 ?occupation .
    {
      ?occupation wdt:P279* wd:Q483501 .
      hint:Prior hint:gearing \"forward\" .
    }
    UNION
    {
      ?occupation wdt:P279* wd:Q482980 .
      hint:Prior hint:gearing \"forward\" .
    }
    FILTER NOT EXISTS
    {
      [] schema:about ?item ; schema:isPartOf <https://es.wikipedia.org/> .
    }
  }
} AS %main
WHERE
{
  INCLUDE %main
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],es,pt,fr,en\" . }
}
ORDER BY ?countryLabel
 Try it! --Dipsacus fullonum (talk) 16:56, 4 January 2021 (UTC) @Dipsacus fullonum: Thank you so much again. I really appreciate your answers. Regards, --Pablísima (talk) 01:28, 5 January 2021 (UTC) Need help with request In German Wikipedia I created lists people who's work get into Public Domain. See de:Wikipedia:Public Domain Day/2021 in Public Domain. Listeria bot cannot handle the request. Can anyone help me to streamline the request? SELECT ?item (COUNT(DISTINCT ?sitelink) as ?articlecount) WHERE {
 ?item wdt:P570 ?deathdate .
 FILTER ( YEAR(?deathdate)=1950 ) .
 OPTIONAL { ?sitelink schema:about ?item . }
 ?item p:P106 ?occupationStatement .
 ?occupationStatement ps:P106/wdt:P279* wd:Q2500638 .
 MINUS { ?occupationStatement wikibase:rank wikibase:DeprecatedRank . }
} GROUP BY ?item ORDER BY DESC (?articlecount) Thanks in advance, --Sebastian Wallroth (talk) 19:20, 3 January 2021 (UTC) @Sebastian Wallroth: I did this: Found persons died in 1950 first in a named subquery Found persons died in 1950 with date comparison without using the YEAR function first Added a rangesafe hint to ?deathdate Added a gearing hint to the property chain for finding subclases of creator (Q2500638) Used the wikibase:sitelinks predicate instead of counting the sitelinks The resulting query is: SELECT DISTINCT ?item ?articlecount
WITH
{
  SELECT ?item
  WHERE
  {
    ?item wdt:P570 ?deathdate .
    hint:Prior hint:rangeSafe true .
    FILTER ( ?deathdate < \"1951-00-00\"^^xsd:dateTime && ?deathdate >= \"1950-00-00\"^^xsd:dateTime )
  }
}
AS %1
WHERE
{
  INCLUDE %1
  ?item wikibase:sitelinks ?articlecount .
  ?item p:P106 ?occupationStatement .
  ?occupationStatement ps:P106/wdt:P279* wd:Q2500638 .
  hint:Prior hint:gearing \"forward\" .
  MINUS { ?occupationStatement wikibase:rank wikibase:DeprecatedRank . }
}
ORDER BY DESC (?articlecount)
 Try it! --Dipsacus fullonum (talk) 20:02, 3 January 2021 (UTC) Hi Dipsacus fullonum, Thank you very much! I do not completely understand your code. I tried it here an got the error message Killed by OS for overloading memory. --Sebastian Wallroth (talk) 20:41, 3 January 2021 (UTC) @Sebastian Wallroth: That is strange. The query runs fine directly in WDQS giving 2877 results in about 4 seconds. I don't know why ListeriaBot cannot run it. I tried changing the name of the named subquery, but that didn't make any difference. --Dipsacus fullonum (talk) 21:08, 3 January 2021 (UTC) The new Rust Listeria has teething troubles. This may well be one of them, albeit if so, it's not on Magnus's radar yet. --Tagishsimon (talk) 04:26, 4 January 2021 (UTC) I think 2877 rows are too many items to load, especially in manual mode. BTW, date precision should probably be checked too. --- Jura 15:34, 4 January 2021 (UTC) Listeria used to have a limit of 5k rows. I've seen the current version produce more. --Tagishsimon (talk) 20:53, 4 January 2021 (UTC) Duly logged. --Tagishsimon (talk) 20:57, 4 January 2021 (UTC) The number of items loaded can be higher than the number of rows depending on the columns displayed and the description used (autodescription). It did seem to get lower .. Another problem is the actual size of items: many country items went through the roof. --- Jura 11:16, 5 January 2021 (UTC) Struggling to import strings via quickstatements Please can anyone help with uploading strings to Wikidata via Quickstatements...specifically a DOI string?The csv I'm using is below (also error on Den string but just hangs on P356):qid,Len,Den,P31,P356,P921 Q100412985,Ovine annulus fibrosus interlamellar material model calibration data set,Experimental data: microscopy images and geometrical data of unloaded and radially loaded samples of ovine lumbar annulus fibrosus tissue; Computational data: input file and raw results of load/extension FE models built from the experimental data; Results data: values of calibrated interlamellar behaviour,Q1172284,10.5518/2,Q193378I've tried with and without quotes - suggested by User:Tagishsimon that further \"quote\" foibles - triple or mismatched? https://twitter.com/Tagishsimon/status/1334899075104247811Thanks! Yes, As I kinda noted there, this is why I use tab separated QS batches. I vaguely remember this mismatched quotes business from an episode of helping someone else who has QS string issues, but it's all very dim. If you have the data in CSV format, you're only a little ingenious formulii thinking away from converting it into tab separated & saving yourself your current world of pain. (Others may have more of a CSV clue than me). --Tagishsimon (talk) 14:16, 5 January 2021 (UTC) @OAnick: (Updated). I've been playing some more today, and current thinking is that the following works; Your choice of no double-quotes (\") or double-quotes around the Len and Den. Seems happy either way. The Len and Den string length needs to be 250 char each or less. No trailing commas (despite what I thought last night. Who knows.) And for reasons I know not, the DOI needs to be in triple double-quotes (\"\"\"). I'm not satisfied that I've characterised its behaviour when a string has a comma or double quote in it. Might return to that later. qid,Len,Den,P31,P356,P921 Q4115189,Ovine annulus fibrosus interlamellar material model calibration data set,of unloaded and radially loaded samples of ovine lumbar annulus fibrosus tissue; Computational data: input file and raw results of load/extension FE models built from the experimental data; Results data: values of calibrated interlamellar behaviour,Q1172284,\"\"\"10.5518/2\"\"\",Q193378 hth --Tagishsimon (talk) 09:31, 6 January 2021 (UTC) refine a stats query Hello, given that basis SELECT DISTINCT ?month ?mois_brut ?Mois_Nom ?year ?patronage   (SAMPLE(?reference_URL) AS ?sample_reference_URL)
WHERE
{    ?item wdt:P238 ?airport_code
VALUES ?airport_code    { \"BKK\"}
    ?item p:P3872 ?statement.
  ?statement ps:P3872 ?patronage.
  ?statement pqv:P585 ?timevalue.
  OPTIONAL { ?statement prov:wasDerivedFrom / (pr:P854|pr:P4656) ?reference_URL. }
  ?timevalue wikibase:timeValue ?time.
  ?timevalue wikibase:timePrecision 10 . # Precision only month (10)
  BIND (MONTH(?time) AS ?month)
  BIND (YEAR(?time) AS ?year)
  VALUES (?mois_brut ?Mois_Nom)  { (1 \"jan\") 
                                  (2 \"fév\" ) 
                                  (3 \"mar\" )  
                                  (4 \"avr\" ) 
                                   (5 \"mai\" ) 
                                   (6 \"juin\" ) 
                                   (7 \"juil\" ) 
                                   (8 \"aoû\" ) 
                                   (9 \"sep\" ) 
                                   (10 \"oct\" ) 
                                   (11 \"nov\" ) 
                                   (12 \"déc\" ) 
  }
  filter(?month = ?mois_brut)
filter(?year>=2018)
} GROUP BY ?month ?mois_brut ?Mois_Nom ?year ?patronage
ORDER BY ?month ?year
 Try it! how to select only one statement P3872 per month and per year ? Thanks Remove ?patronage from the GROUP BY clause, and add a aggregation function like MIN, MAX, AVG or SAMPLE to the SELECT clause for the multiple values of ?patronage. --Dipsacus fullonum (talk) 03:36, 6 January 2021 (UTC) Hello, thank you. Won't it take any deprecated statement ? Is it automatically removed or do we need to declare deprecated out of scope? --Bouzinac 💬●✒️●💛 08:41, 6 January 2021 (UTC) @Bouzinac: Yes. It uses statements of all ranks now, with or without the change. To only use statements of best rank (truthy statemenents) add: ?statement a wikibase:BestRank.
 To exclude deprecated statements (i.e. only use statements of normal or preferred rank) add: VALUES ?rank { wikibase:NormalRank wikibase:PreferredRank } 
?statement wikibase:rank ?rank.
 --Dipsacus fullonum (talk) 11:33, 6 January 2021 (UTC) Thank you Dipsacus fullonum, looks really nice now here https://fr.wikipedia.org/wiki/A%C3%A9roport_international_Pearson_de_Toronto#Statistiques ;) --Bouzinac 💬●✒️●💛 13:25, 6 January 2021 (UTC) Search for text string with accompanying main subject (P921) Greetings. I'd like to find items with instance of (P31) = scholarly article (Q13442814), with main subject (P921) = anything of instance of (P31) or subclass of (P279) = meteorite (Q60186) that have a particular string in the title, for this example, either \"Northwest Africa\" or \"NWA\". Complex, maybe too complex, maybe. Is it possible? Thanks. Trilotat (talk) 15:46, 7 January 2021 (UTC)@Trilotat: This SELECT DISTINCT ?item ?itemLabel 
WHERE {
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
    bd:serviceParam wikibase:api \"Search\";
                    wikibase:endpoint \"www.wikidata.org\";
                    mwapi:srsearch \"NWA haswbstatement:P31=Q13442814\".
    ?title wikibase:apiOutput mwapi:title.
  }
  BIND(IRI(CONCAT(STR(wd:), ?title)) AS ?item)
  ?item wdt:P921/wdt:P31/wdt:P279* wd:Q60186.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! --Tagishsimon (talk) 15:55, 7 January 2021 (UTC) Noting this, I should be using wikibase:apiOutputItem, but it all goes wrong. @Dipsacus fullonum: SELECT DISTINCT ?item ?itemLabel 
WHERE {
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
    bd:serviceParam wikibase:api \"Search\";
                    wikibase:endpoint \"www.wikidata.org\";
                    mwapi:srsearch \"NWA haswbstatement:P31=Q13442814\".
    ?title wikibase:apiOutput mwapi:title.
    ?item wikibase:apiOutputItem mwapi:item.
  }
 # BIND(IRI(CONCAT(STR(wd:), ?title)) AS ?item)
  ?item wdt:P921/wdt:P31/wdt:P279* wd:Q60186.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! --Tagishsimon (talk) 16:04, 7 January 2021 (UTC) So on the one hand, I can see this works: SELECT DISTINCT ?item ?itemLabel 
WHERE {
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
    bd:serviceParam wikibase:api \"Search\";
                    wikibase:endpoint \"www.wikidata.org\";
                    mwapi:srsearch \"NWA haswbstatement:P31=Q13442814\".
    ?title wikibase:apiOutput mwapi:title.
    ?item wikibase:apiOutputItem mwapi:title.
  }
 # BIND(IRI(CONCAT(STR(wd:), ?title)) AS ?item)
  ?item wdt:P921/wdt:P31/wdt:P279* wd:Q60186.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! and on the other, so does this. So. Confused. SELECT distinct ?item ?itemLabel ?title ?name ?nameLabel ?institution?institutionLabel ?P971 ?P971Label ?P4224 where
{
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
     bd:serviceParam wikibase:endpoint \"en.wikipedia.org\";
                     wikibase:api \"Generator\";
                     mwapi:generator \"categorymembers\";
                     mwapi:gcmtitle \"Category:Academics by university or college in England\" ;         # specifically here
                     mwapi:gcmprop \"ids|title|type\";
                     mwapi:gcmlimit \"max\".
     # out
     ?name wikibase:apiOutput mwapi:title.        # en-wikipedia article / category name
     ?item wikibase:apiOutputItem mwapi:item.            # wikidata QId for the person's item
    }
  ?item wdt:P31 wd:Q4167836 .
  optional {?item wdt:P971 ?P971 . }
  optional {?item wdt:P4224 ?P4224 . }
  optional {?item p:P4224 [pq:P108 ?institution ]. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! @Tagishsimon: @Dipsacus fullonum: Thanks to you both! Trilotat (talk) 16:21, 7 January 2021 (UTC) @Tagishsimon: You can use wikibase:apiOutputItem like this: SELECT DISTINCT ?item ?itemLabel 
WHERE {
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
    bd:serviceParam wikibase:api \"Search\";
                    wikibase:endpoint \"www.wikidata.org\";
                    mwapi:srsearch \"NWA haswbstatement:P31=Q13442814\".
    ?item wikibase:apiOutputItem mwapi:title.
  }
  ?item wdt:P921/wdt:P31/wdt:P279* wd:Q60186.
  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
}
 Try it! Note that the object in the triple ?item wikibase:apiOutputItem mwapi:title specifies which data from the API call to use. mwapi:title fetches the title (Q number on Wikidata, article on Wikipedias etc.) which is what you want when you call Wikidata's API to get items. mwapi:item fetches the name of the connected item when you call API's of other wikis like Wikipedias and others, but you don't use mwapi:item on Wikidata itself. The predicate decides how to interpret the value. wikibase:apiOutputItem gives you an item URI, while wikibase:apiOutput gives a string. I hope that helps with your confusion. --Dipsacus fullonum (talk) 16:51, 7 January 2021 (UTC) Ah. Wikidata. Wikipedia. Different things. I think I'm up to speed again; thx. --Tagishsimon (talk) 17:13, 7 January 2021 (UTC) Items with existing it.wiki article but without wikidata Italian label Dear friends, I would like to have a list of wikidata items missing the Italian label albeit having it.wiki article connected. Bonus point, to filter only items of the previous list where it.wiki \"article name\" substantially differ from English wikidata label (e.g. Blanche of Anjou (Q3458673)). Luckyz (talk) 10:54, 8 January 2021 (UTC) @Luckyz: I don't think it's easily possible to provide you with the lists you want, because there are too many items to consider. The best you can do it hunt around in subsets of articles - call them haystacks - looking for your needles. As far as I know there are three approaches open in SPARQL: a regular query; a query based on interrogating IT wiki categories; and a query invoking the MWAPI search. Start with the latter; wikidata is indexed by a CirrusSearch, a MediaWiki extension that uses Elasticsearch to provide enhanced search features over the default MediaWiki search. Lovely. WikibaseCirrusSearch further extends it with some parameters useful for wikidata, but, not enough for us. We can launch a search looking for items that lack an IT label (\" -haslabel:it\") and constrain the search to items that have specific properties, such as IT citizenship (\"haswbstatement:P27=Q38\"), but iirc the search returns a max 10k items to be considered and only one of them meets the other of your conditions. Not least, it may well be that the search is returning items that have no IT sitelink & afaics we can't stop if from doing that, but only test for an IT sitelink once we have the results. SELECT ?item ?itemLabel_en ?sitelink ?itemLabel_it
WHERE 
{
  SERVICE wikibase:mwapi
  {
    bd:serviceParam wikibase:api \"Search\" .
    bd:serviceParam wikibase:endpoint \"www.wikidata.org\" .
    bd:serviceParam mwapi:srsearch \"haswbstatement:P27=Q38 -haslabel:it\" .
    ?item wikibase:apiOutputItem mwapi:title.
  }
  ?article schema:about ?item ;
           schema:name ?sitelink ;
           schema:isPartOf <https://it.wikipedia.org/> .
  OPTIONAL { ?item rdfs:label ?itemLabel_en . filter(lang(?itemLabel_en)=\"en\") }
  FILTER (str(?itemLabel_en) != str(?sitelink))
}
 Try it! Or we can do the same thing without search; a regular query which starts by selecting a subset of items - here, politicians with IT citizenship; and then run the various tests you specify - they have an IT sitelink, have no IT label, have a sitelink that differs from the EN label. But, again, thin pickings. You can choose different subsets to prime this query with; but anything too ambitious (the class tree of landforms, for instance (?item wdt:P31/wdt:P279* wd:Q271669 . ) will time out. SELECT ?item ?itemLabel_en ?sitelink ?itemLabel_it
WHERE 
{
  ?item wdt:P106 wd:Q82955 . 
  ?item wdt:P27 wd:Q38 .
  ?article schema:about ?item ;
           schema:name ?sitelink ;
           schema:isPartOf <https://it.wikipedia.org/> .
  FILTER NOT EXISTS { ?item rdfs:label ?itemLabel_it . filter(lang(?itemLabel_it)=\"it\") }
  OPTIONAL { ?item rdfs:label ?itemLabel_en . filter(lang(?itemLabel_en)=\"en\") }
  FILTER (str(?itemLabel_en) != str(?sitelink))
}
 Try it! The final approach; look at IT wiki category membership. Tiresome and yielding mainly zero results. SELECT ?item ?itemLabel_en ?sitelink ?itemLabel_it
{
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
     bd:serviceParam wikibase:endpoint \"it.wikipedia.org\";
                     wikibase:api \"Generator\";
                     mwapi:generator \"categorymembers\";
                     mwapi:gcmtitle \"Categoria:Politici italiani del XXI secolo\" ;         
                     mwapi:gcmprop \"ids|title|type\";
                     mwapi:gcmlimit \"max\".
     # out
     ?name wikibase:apiOutput mwapi:title.        # en-wikipedia article / category name
     ?item wikibase:apiOutputItem mwapi:item.            # wikidata QId for the person's item
    }
  ?article schema:about ?item ;
           schema:name ?sitelink ;
           schema:isPartOf <https://it.wikipedia.org/> .
  FILTER NOT EXISTS { ?item rdfs:label ?itemLabel_it . filter(lang(?itemLabel_it)=\"it\") }
  OPTIONAL { ?item rdfs:label ?itemLabel_en . filter(lang(?itemLabel_en)=\"en\") }
  FILTER (str(?itemLabel_en) != str(?sitelink))
}
 Try it! So, they're my best shots. Sorry it didn't work out. @Dipsacus fullonum: may wish to comment on whether it is possible to recurse through a category tree in the last search; I imagine we might want to start higher in the tree - https://it.wikipedia.org/wiki/Categoria:Politici_italiani - and look at members of all of the subcats. --Tagishsimon (talk) 09:26, 9 January 2021 (UTC) Hello, I've tried that way https://w.wiki/tjE : it looks to work but I'm surprised by the few number of results. Surely Dipsacus will help out ;) --Bouzinac 💬●✒️●💛 09:51, 9 January 2021 (UTC) I have a few quick comments now: I think Tagishsimon did a good explanation of the possibilities and I agree with it. But some optimizations are possible in the last query with the MWAPI call to itwiki. 1) There is no need to also check in SPARQL code if there is an article in itwiki (and I think that the check will cause a timeout if any article in the category happens not to be connected to Wikidata leaving ?item unbound.) 2) It may be faster to try to get the Italian label from the Wikipedia. You have access to Wikidata labels via the API parameter prop=pageterms. 3) You cannot make a deecategory search in it:Categoria:Politici italiani (too many subcategories) It may be possible to manually recurse the category tree (I have never tried) but you will run into the 10K limit, and I would not be surprised by a timeout. I may return to this when I have better time. --Dipsacus fullonum (talk) 14:38, 9 January 2021 (UTC) First of all, @Tagishsimon: thank you very much. I didn't realized that dimensions of database is, also in this case, the main problem. I managed to select specific occupation and I'm succeeding in extracting intersting results. So, thank you again! You're awesome. Luckyz (talk) 14:45, 9 January 2021 (UTC) Obviously, if it would be possible to have an increased dataset with more results, I would be able to better integrate labels. If @Dipsacus fullonum: will find time, I'm here to listen. thank you again. Luckyz (talk) 14:52, 9 January 2021 (UTC) Here is the last query without getting the ?sitelink variable. The was unnecessary because it already have the value in the variable ?name. I also inserted FILTER BOUND (?item): SELECT ?item ?itemLabel_en ?name ?itemLabel_it
{
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
     bd:serviceParam wikibase:endpoint \"it.wikipedia.org\";
                     wikibase:api \"Generator\";
                     mwapi:generator \"categorymembers\";
                     mwapi:gcmtitle \"Categoria:Politici italiani del XXI secolo\" ;         
                     mwapi:gcmprop \"ids|title|type\";
                     mwapi:gcmlimit \"max\".
     # out
     ?name wikibase:apiOutput mwapi:title.        # en-wikipedia article / category name
     ?item wikibase:apiOutputItem mwapi:item.            # wikidata QId for the person's item
    }
  FILTER BOUND (?item)
  FILTER NOT EXISTS { ?item rdfs:label ?itemLabel_it . filter(lang(?itemLabel_it)=\"it\") }
  OPTIONAL { ?item rdfs:label ?itemLabel_en . filter(lang(?itemLabel_en)=\"en\") }
  FILTER (str(?itemLabel_en) != ?name)
}
 Try it! --Dipsacus fullonum (talk) 15:07, 9 January 2021 (UTC) I wrote \"It may be faster to try to get the Italian label from the Wikipedia.\" I tried this and it is not faster. It is slower. I will show how it done, but don't use this query: SELECT ?item ?itemLabel_en ?name ?itemLabel_it
{
  hint:Query hint:optimizer \"None\".
  SERVICE wikibase:mwapi {
     bd:serviceParam wikibase:endpoint \"it.wikipedia.org\";
                     wikibase:api \"Generator\";
                     mwapi:generator \"categorymembers\";
                     mwapi:gcmtitle \"Categoria:Politici italiani del XXI secolo\" ;         
                     mwapi:gcmprop \"ids|title|type\";
                     mwapi:gcmlimit \"max\";
                     mwapi:prop \"pageprops|pageterms\";
                     mwapi:wbptterms \"label\".
     # out
     ?name wikibase:apiOutput mwapi:title.      # it-wikipedia article / category name
     ?item wikibase:apiOutputItem mwapi:item.      # wikidata QId for the person's item
     ?itemLabel_it wikibase:apiOutput \"terms/label/term/text()\".      # Wikidata label in the language of the Wikipedia (it)
    }
  FILTER BOUND (?item)
  FILTER (! BOUND (?itemLabel_it))
  OPTIONAL { ?item rdfs:label ?itemLabel_en . filter(lang(?itemLabel_en)=\"en\") }
  FILTER (str(?itemLabel_en) != ?name)
}
 Try it! --Dipsacus fullonum (talk) 19:30, 9 January 2021 (UTC) People that died on January 2021 Hello. I want to find all people that died on January 2021, sorting by date. (1st January first, 2nd January second etc). Data Gamer play 09:07, 11 January 2021 (UTC) @Data Gamer: This. There are some issues with date precision which I have not addressed here - in short, deaths may be specified as happening in a month or year rather than on a day, but will appear in this report as if they had occurred on 1 Jan. That can be dealt with - specified as a column in the report - if necessary. SELECT ?item ?itemLabel ?dateOfDeath WHERE {
  ?item wdt:P31 wd:Q5;
        wdt:P570 ?dateOfDeath. hint:Prior hint:rangeSafe true.
  FILTER(\"2020-12-31\"^^xsd:dateTime < ?dateOfDeath &&
         ?dateOfDeath < \"2021-02-01\"^^xsd:dateTime)
    SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }
} order by ?dateOfDeath ?itemLabel
 Try it! --Tagishsimon (talk) 10:14, 11 January 2021 (UTC) Thanks! Data Gamer play 11:57, 11 January 2021 (UTC) Searching for result by matching item label with request parameter Searching for result by matching item label with request parameterDear WikiData contributorsI'd like to consult is it possible to perform a query so that to searching from wikidata by item label, and get all property values returned.For example, in python I may have a list containing [‘monash university’, 'peking university'. 'harward university'] I will loop this list, so that sending query to wikidata, searching for any matching result for the above three universities.So in short, the searching parameter will be the title of the university. And I'd like to matching the university title with the wikidata item label, and get all matched data returned with all available property and values. (ideally returned in json format) (So that I can do further filtering locally)I watched the wikidata official 1 hour and 51 minutes tutorial, which is https://www.youtube.com/watch?v=kJph4q0Im98, but it's not solving my problem.Huge thanks to any help effort.Jay Young This, at least for the English label. An adaption of this can be made to look across all labels. I'm sure you can cause Python to talk to the API and get a JSON result, but that's above my paygrade. Note the match here is case specific; again, if case is an issue that can be tackled. SELECT ?item ?label  WHERE {
  VALUES ?label {
   \"Monash University\"@en
   \"Peking University\"@en
   \"Harvard University\"@en
 } .
  ?item rdfs:label ?label . 
}
 Try it! --Tagishsimon (talk) 10:21, 11 January 2021 (UTC) The SPARQL query will give all relevant items. You can get all claims (properties and values including qualifiers and references) in json format from the API. E.g. https://www.wikidata.org/w/api.php?action=wbgetclaims&entity=Q13371&format=json for Q13371 etc. Documentation is available at https://www.mediawiki.org/wiki/API:Main_page (Main page for MediaWiki API), https://www.mediawiki.org/wiki/Wikibase/API (The Wikibase extension), https://www.wikidata.org/w/api.php?action=help&modules=wbgetclaims (the wbgetclaims module). --Dipsacus fullonum (talk) 13:53, 11 January 2021 (UTC) Get items where \"instance of\" is a subclass of another item I am working on this query to get the items where instance of (P31) is a subclass of (P279) fictional character (Q95074): SELECT DISTINCT ?character ?characterLabel ?birth ?death
WHERE {
  {
    SELECT DISTINCT ?fictiontype
    WHERE {
      # fictional character subclasses
      ?fictiontype wdt:P279 wd:Q95074.
    }
  }
  ?character wdt:P31 ?fictiontype.
  OPTIONAL { ?character wdt:P570 ?death .}
  OPTIONAL { ?character wdt:P569 ?birth }
  SERVICE wikibase:label {
    bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\" .
  }
}
 Try it! The problem is that it always times out (even if the subquery is only limited to one result) and I don't know how else the same can be achieved. While I could do something like this: """@en;
  dcterms:isPartOf <https://www.wikidata.org//wiki/Wikidata:Request_a_query/Archive/2021/01>;
  dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/>;
  sh:prefixes _:wikidata_prefixes;
  schema:target <https://query.wikidata.org/sparql/> .
